import{_ as d,c as e,e as r,o as s}from"./app-CggKXFlf.js";const l="/assets/image-20250316174337495-CO564BMc.png",n="/assets/image-20250404215904436-CXm_c510.png",a="/assets/image-20250316174428287-Cv9C5KZq.png",i="/assets/image-20250316174449320-DXoe8KSh.png",o="/assets/image-20250316174549313-D7x92kug.png",g="/assets/image-20250316174625466-BSTq1sdl.png",h="/assets/image-20250405110413577-DyhoXqts.png",p="/assets/59-y9hSpkC8.png",c="/assets/60-CiLiK6D9.png",f="/assets/61-gU8K_lwm.png",x="/assets/62-CNJUt_sp.png",y="/assets/63-C2hs4Npk.png",m="/assets/64-D81HV21A.png",u="/assets/65-C8UEHjrl.png",b="/assets/66-N5Nz1Mkt.png",k="/assets/67-D4gOsU_7.png",C="/assets/68-B_v9o9Ig.png",A={};function S(P,t){return s(),e("div",null,t[0]||(t[0]=[r('<h1 id="上午题知识点" tabindex="-1"><a class="header-anchor" href="#上午题知识点"><span>上午题知识点</span></a></h1><h2 id="计算机组成原理" tabindex="-1"><a class="header-anchor" href="#计算机组成原理"><span>计算机组成原理</span></a></h2><h3 id="计算机基本工作原理" tabindex="-1"><a class="header-anchor" href="#计算机基本工作原理"><span>计算机基本工作原理</span></a></h3><h4 id="冯诺依曼体系结构" tabindex="-1"><a class="header-anchor" href="#冯诺依曼体系结构"><span>冯诺依曼体系结构</span></a></h4><p><strong>一、核心思想</strong></p><p><strong>存储程序 + 程序控制</strong> 计算机的 <strong>程序和数据统一存储在内存中</strong>，CPU 按顺序读取指令并执行。</p><p><strong>二、五大组成部分</strong></p><table><thead><tr><th><strong>部件</strong></th><th><strong>功能</strong></th><th><strong>类比</strong></th></tr></thead><tbody><tr><td><strong>运算器</strong></td><td>算术运算（如加减乘除）和逻辑运算（如与或非）</td><td>计算器</td></tr><tr><td><strong>控制器</strong></td><td>指挥各部件协调工作（取指令、译码、执行）</td><td>指挥官</td></tr><tr><td><strong>存储器</strong></td><td>存放程序和数据（内存、硬盘等）</td><td>仓库</td></tr><tr><td><strong>输入设备</strong></td><td>将外部信息（如键盘、鼠标）输入到计算机</td><td>眼睛 / 耳朵</td></tr><tr><td><strong>输出设备</strong></td><td>将处理结果输出（如显示器、打印机）</td><td>嘴巴 / 手</td></tr></tbody></table><p><strong>三、工作流程</strong></p><ol><li><p><strong>输入</strong>：用户通过输入设备（如键盘）输入程序或数据。</p></li><li><p><strong>存储</strong>：程序和数据存入存储器（如内存）。</p></li><li><p><strong>执行</strong></p><ul><li><strong>取指令</strong>：控制器从内存读取指令到 CPU。</li><li><strong>译码</strong>：分析指令功能（如加法、跳转）。</li><li><strong>执行</strong>：运算器完成操作，结果存入内存或寄存器。</li></ul></li><li><p><strong>输出</strong>：结果通过输出设备（如屏幕）显示。</p><hr></li></ol><h4 id="计算机工作基本原理" tabindex="-1"><a class="header-anchor" href="#计算机工作基本原理"><span>计算机工作基本原理</span></a></h4><p><img src="'+l+'" alt="image-20250316174337495"></p><p><img src="'+n+'" alt="image-20250404215904436"></p><p><img src="'+a+'" alt="image-20250316174428287"></p><p><img src="'+i+'" alt="image-20250316174449320"></p><p><img src="'+o+'" alt=""></p><p><img src="'+g+'" alt="image-20250316174625466"></p><hr><h4 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器"><span>寄存器</span></a></h4><h5 id="一、寄存器是什么" tabindex="-1"><a class="header-anchor" href="#一、寄存器是什么"><span><strong>一、寄存器是什么？</strong></span></a></h5><p><strong>定义</strong>：寄存器是 CPU 内部的 <strong>高速存储单元</strong>，用于 <strong>临时存放数据、指令或地址</strong>。 <strong>特点</strong>：</p><ul><li>访问速度极快（纳秒级，比内存快 100 倍以上）。</li><li>容量极小（通常每个 CPU 有几十个寄存器）。 <strong>比喻</strong>：类似你办公桌上的 <strong>临时小抽屉</strong>，存放你正在处理的文件（数据 / 指令），伸手就能拿到。</li></ul><h5 id="二、寄存器的分类与作用" tabindex="-1"><a class="header-anchor" href="#二、寄存器的分类与作用"><span><strong>二、寄存器的分类与作用</strong></span></a></h5><table><thead><tr><th><strong>寄存器类型</strong></th><th><strong>作用</strong></th><th><strong>典型例子</strong></th></tr></thead><tbody><tr><td><strong>通用寄存器</strong></td><td>存放临时数据、运算结果</td><td>AX（累加器）、BX（基址寄存器）</td></tr><tr><td><strong>程序计数器（PC）</strong></td><td>存储 <strong>下一条要执行的指令地址</strong></td><td>PC</td></tr><tr><td><strong>指令寄存器（IR）</strong></td><td>存放 <strong>当前正在执行的指令</strong></td><td>IR</td></tr><tr><td><strong>地址寄存器（MAR）</strong></td><td>存放 <strong>内存访问的地址</strong>（如读取数据或指令）</td><td>MAR</td></tr><tr><td><strong>状态寄存器（FLAGS）</strong></td><td>记录运算状态（如进位、溢出、零标志）</td><td>CF（进位标志）、ZF（零标志）</td></tr></tbody></table><hr><h4 id="校验码" tabindex="-1"><a class="header-anchor" href="#校验码"><span>校验码</span></a></h4><ul><li>CRC：<strong>模 2 运算</strong> 生成校验码，<strong>检错不纠错</strong>。</li><li>海明码：<strong>校验位定位错误</strong>，<strong>纠错能力强</strong>。</li><li>奇数校验：<strong>简单检错</strong>，但 <strong>可靠性低</strong>。</li></ul><h5 id="循环冗余校验-crc" tabindex="-1"><a class="header-anchor" href="#循环冗余校验-crc"><span>循环冗余校验（CRC）</span></a></h5><p><strong>循环冗余校验（CRC）</strong></p><ul><li><strong>核心原理</strong>：通过 <strong>多项式除法</strong>（模 2 运算）生成校验码，用于 <strong>检错</strong>。</li><li>常考点： <ul><li>生成多项式选择（如 CRC-16、CRC-32）。</li><li><strong>计算步骤</strong>：在数据后补 0，与生成多项式进行模 2 除法，余数即为校验码。</li><li><strong>检错能力</strong>：可检测 <strong>所有奇数位错误</strong> 和 <strong>突发错误</strong>（长度 ≤ 生成多项式位数）。</li></ul></li></ul><h5 id="海明码" tabindex="-1"><a class="header-anchor" href="#海明码"><span>海明码</span></a></h5><ul><li><strong>核心原理</strong>：通过插入 <strong>校验位</strong>（r 位），利用 <strong>奇偶校验</strong> 实现 <strong>纠错</strong>。</li><li>常考点： <ul><li>校验位位置：满足 <strong>2^r ≥ k + r + 1</strong>（k 为数据位，r 为校验位）。</li><li><strong>校验位计算</strong>：按位异或对应数据位。</li><li><strong>纠错过程</strong>：通过校验位组合定位错误位置。</li><li><strong>能力</strong>：可纠正 <strong>1 位错误</strong>，检测 <strong>2 位错误</strong>。</li></ul></li></ul><h5 id="奇数校验" tabindex="-1"><a class="header-anchor" href="#奇数校验"><span>奇数校验</span></a></h5><ul><li><p><strong>核心原理</strong>：使 <strong>数据位 + 校验位</strong> 的 1 的总数为 <strong>奇数</strong>。</p></li><li><p>常考点：</p><ul><li><p>校验位生成：根据数据位中 1 的个数确定（奇校验补 1，偶校验补 0）。</p></li><li><p><strong>局限性</strong>：仅能检测 <strong>奇数位错误</strong>，无法纠错。</p></li><li><p>应用场景：简单通信（如串口传输）。</p><hr></li></ul></li></ul><h4 id="原码补码反码移码" tabindex="-1"><a class="header-anchor" href="#原码补码反码移码"><span>原码补码反码移码</span></a></h4><h5 id="之间的相互转换" tabindex="-1"><a class="header-anchor" href="#之间的相互转换"><span>之间的相互转换</span></a></h5><ol><li><strong>原码</strong><ul><li><strong>定义</strong>：符号位（0 正 1 负）+ 数值绝对值的二进制表示。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1000 0110</code></li></ul></li><li><strong>转换规则</strong>：直接按符号位 + 数值转换。</li></ul></li><li><strong>反码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数符号位不变，其余位取反。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1001</code></li></ul></li><li><strong>转换规则</strong>：原码 → 反码（负数取反）。</li></ul></li><li><strong>补码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数为反码末位加 1。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1010</code></li></ul></li><li><strong>转换规则</strong>：反码 → 补码（末位 + 1）。</li></ul></li><li><strong>移码</strong><ul><li><strong>定义</strong>：补码符号位取反（常用于浮点数阶码）。</li><li>示例（8 位）： <ul><li>+6 → <code>1000 0110</code></li><li>-6 → <code>0111 1010</code></li></ul></li><li><strong>转换规则</strong>：补码 → 移码（符号位取反）。</li></ul></li></ol><h5 id="表示范围" tabindex="-1"><a class="header-anchor" href="#表示范围"><span>表示范围</span></a></h5><table><thead><tr><th>码制</th><th>整数范围</th><th>特殊值说明</th></tr></thead><tbody><tr><td>原码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1000 0000</code>）</td></tr><tr><td>反码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1111 1111</code>）</td></tr><tr><td>补码</td><td>-128 ~ +127</td><td>唯一 0（<code>0000 0000</code>），-128 表示为 <code>1000 0000</code></td></tr><tr><td>移码</td><td>-128 ~ +127</td><td>符号位取反，便于比较大小 唯一 0</td></tr></tbody></table><h5 id="真值计算" tabindex="-1"><a class="header-anchor" href="#真值计算"><span>真值计算</span></a></h5><ol><li><p><strong>原码转真值</strong></p><ul><li><code>1001 0101</code> → 符号位 1（负），数值 <code>001 0101</code> → -37。</li></ul></li><li><p><strong>补码转真值</strong></p><ul><li><code>1111 0101</code> → 符号位 1（负），取反得 <code>0000 1010</code>，加 1 得 <code>0000 1011</code> → -11。</li></ul></li><li><p><strong>移码转真值</strong></p><ul><li><code>0111 0101</code> → 符号位取反得补码 <code>1111 0101</code> → 真值 - 11。</li></ul><hr></li></ol><h4 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数"><span>浮点数</span></a></h4><p>浮点数在计算机中用以近似表示任意某个实数，一个浮点数 a 可如下表示: a = M*bE。</p><p><strong>尾数部分 M 的位数越多，数的精度越高。</strong></p><p><strong>指数部分 E 的位数越多，能表示的数值越大。</strong></p><p>因此在总长度固定的情况下，增加 E 的位数、减少 M 的位数可以扩大可表示的数的范围同时降低精度。</p><h5 id="定点表示和浮点表示" tabindex="-1"><a class="header-anchor" href="#定点表示和浮点表示"><span>定点表示和浮点表示</span></a></h5><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>定点表示</strong></td><td>小数点位置固定（如整数、纯小数），直接存储数值。</td><td>- 精度固定，范围小。 - 适合处理整数或固定精度小数。</td></tr><tr><td><strong>浮点表示</strong></td><td>采用科学计数法形式：<strong>尾数 × 基数 ^ 阶码</strong>（如 <code>±1.xxxxx×2^±yyy</code>）。</td><td>- 动态范围大，精度可变。 - 适合处理大范围数值（如科学计算）。</td></tr></tbody></table><h5 id="规格化" tabindex="-1"><a class="header-anchor" href="#规格化"><span>规格化</span></a></h5><p><strong>目的</strong>：使浮点数的表示唯一且有效位数最大化。 <strong>条件</strong>：</p><ul><li>原码规格化：尾数最高位必须为 1（避免前导零）。 <ul><li>例：<code>1.0101×2^3</code>（有效），<code>0.1010×2^4</code>（无效，需调整为 <code>1.010×2^3</code>）。</li></ul></li><li>补码规格化： <ul><li>正数：最高位为 1。</li><li>负数：最高位为 0（补码负数的绝对值最大，如 <code>1.0101</code> 表示 - 0.9375）。</li></ul></li></ul><p><strong>意义</strong>：消除冗余表示，提高精度。</p><h5 id="如何计算浮点数的表示范围" tabindex="-1"><a class="header-anchor" href="#如何计算浮点数的表示范围"><span>如何计算浮点数的表示范围</span></a></h5><hr><h4 id="与-或-异或-同或" tabindex="-1"><a class="header-anchor" href="#与-或-异或-同或"><span>与 或 异或 同或</span></a></h4><table><thead><tr><th><strong>输入 A</strong></th><th><strong>输入 B</strong></th><th><strong>与（AND）</strong></th><th><strong>或（OR）</strong></th><th><strong>异或（XOR）</strong></th><th><strong>同或（XNOR）</strong></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p><strong>关键规则说明</strong></p><ol><li><p><strong>与（AND）</strong>：只有 <strong>两个都为 1</strong> 时，结果才为 1。 → <strong>口诀</strong>：“有 0 则 0，全 1 才 1”。</p></li><li><p><strong>或（OR）</strong>：只要 <strong>有一个为 1</strong>，结果就为 1。 → <strong>口诀</strong>：“有 1 则 1，全 0 才 0”。</p></li><li><p><strong>异或（XOR）</strong>：两个值 <strong>不同</strong> 时结果为 1，相同则为 0。 → <strong>口诀</strong>：“不同为 1，相同为 0”。</p></li><li><p><strong>同或（XNOR）</strong>：两个值 <strong>相同</strong> 时结果为 1，不同则为 0。 → <strong>口诀</strong>：“相同为 1，不同为 0”（等同于异或结果取反）。</p><hr></li></ol><h4 id="冗余技术" tabindex="-1"><a class="header-anchor" href="#冗余技术"><span>冗余技术</span></a></h4><p>冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。通常冗余技术分为 4 类:</p><p>1.结构冗余，按其工作方法可以分为静态、动态和混合冗余;</p><p>2.信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息;</p><p>3.时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响;</p><p>4.冗余附件技术，是指为实现上述冗余技术所需的资源和技术。</p><hr><h3 id="存储系统" tabindex="-1"><a class="header-anchor" href="#存储系统"><span>存储系统</span></a></h3><h4 id="主存、辅存、cache" tabindex="-1"><a class="header-anchor" href="#主存、辅存、cache"><span>主存、辅存、cache</span></a></h4><table><thead><tr><th><strong>存储类型</strong></th><th><strong>全称</strong></th><th><strong>速度</strong></th><th><strong>容量</strong></th><th><strong>作用</strong></th><th><strong>典型设备</strong></th></tr></thead><tbody><tr><td><strong>Cache</strong></td><td>高速缓存</td><td>极快（纳秒级）</td><td>极小（MB 级）</td><td>缓解 CPU 与主存的速度差异</td><td>CPU 内置缓存</td></tr><tr><td><strong>主存</strong></td><td>主存储器</td><td>快（微秒级）</td><td>中等（GB 级）</td><td>CPU 直接访问的临时存储</td><td>内存条</td></tr><tr><td><strong>辅存</strong></td><td>辅助存储器</td><td>慢（毫秒级）</td><td>大（TB 级）</td><td>长期存储程序和数据</td><td>硬盘、SSD</td></tr></tbody></table><p><strong>主存主要采用动态随机存储器 DRAM</strong></p><p><strong>Cache 采用静态随机存储器 SRAM</strong></p><p><strong>EEPROM 是电擦除可编程的只读存储器</strong></p><p><strong>Cache 与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的。</strong></p><ol><li><p><strong>存储层次结构</strong></p><ul><li><strong>常考</strong>：Cache - 主存 - 辅存构成三级存储体系，速度递减、容量递增。</li></ul></li><li><p><strong>命中率优化</strong></p><ul><li><strong>示例</strong>：Cache 命中率越高，CPU 等待时间越少，性能越好。</li></ul></li><li><p><strong>虚拟内存技术</strong></p><ul><li><strong>常考</strong>：主存不足时，部分数据暂存到辅存（虚拟内存），但会导致速度下降。</li></ul></li></ol><h4 id="全相联、直接相连、组相连映射对比详解" tabindex="-1"><a class="header-anchor" href="#全相联、直接相连、组相连映射对比详解"><span>全相联、直接相连、组相连映射对比详解</span></a></h4><p><strong>一、核心概念**</strong></p><ol><li><p><strong>直接相连映射（Direct Mapping）</strong></p><ul><li>主存块只能映射到 <strong>Cache 的唯一固定位置</strong>。</li><li>例如：主存块 0 → Cache 块 0，主存块 1 → Cache 块 1，依此类推。</li></ul></li><li><p><strong>组相连映射（Set Associative Mapping）</strong></p><ul><li>主存块映射到 Cache 的 <strong>某个组</strong>（如每组 4 块），组内块可自由选择。</li><li>例如：主存块 0 → Cache 组 0 的任意块（块 0-3）。</li></ul></li><li><p><strong>全相联映射（Fully Associative Mapping）</strong></p><ul><li>主存块可映射到 Cache 的 <strong>任意位置</strong>，无固定限制。</li></ul><p><strong>二、工作原理对比</strong></p><table><thead><tr><th><strong>映射方式</strong></th><th><strong>地址划分</strong></th><th><strong>查找逻辑</strong></th><th><strong>替换策略</strong></th></tr></thead><tbody><tr><td><strong>直接相连</strong></td><td>主存地址 = 块号 + 块内偏移</td><td>根据块号直接定位 Cache 块</td><td>固定替换（如覆盖）</td></tr><tr><td><strong>组相连</strong></td><td>主存地址 = 组号 + 块号 + 块内偏移</td><td>先定位组，再查找组内块</td><td>LRU、FIFO 等</td></tr><tr><td><strong>全相联</strong></td><td>主存地址 = 标签 + 块内偏移</td><td>遍历所有 Cache 块，对比标签</td><td>LRU、FIFO 等</td></tr></tbody></table><p><strong>三、特点对比表</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>直接相连</strong></th><th><strong>组相连</strong></th><th><strong>全相联</strong></th></tr></thead><tbody><tr><td><strong>映射规则</strong></td><td>固定位置</td><td>组内自由</td><td>完全自由</td></tr><tr><td><strong>冲突率</strong></td><td><strong>高</strong>（易地址冲突）</td><td><strong>中</strong></td><td><strong>低</strong></td></tr><tr><td><strong>查找速度</strong></td><td><strong>快</strong>（直接计算地址）</td><td><strong>中</strong>（组内搜索）</td><td><strong>慢</strong>（全 Cache 搜索）</td></tr><tr><td><strong>硬件复杂度</strong></td><td><strong>低</strong></td><td><strong>中</strong></td><td><strong>高</strong>（需全比较电路）</td></tr><tr><td><strong>典型应用</strong></td><td>片外 Cache、简单系统</td><td>一级 Cache、通用系统</td><td>小容量 Cache、高性能场景</td></tr></tbody></table></li></ol><h4 id="存储容量、存储块的计算方式" tabindex="-1"><a class="header-anchor" href="#存储容量、存储块的计算方式"><span>存储容量、存储块的计算方式</span></a></h4><h4 id="一、存储容量计算" tabindex="-1"><a class="header-anchor" href="#一、存储容量计算"><span><strong>一、存储容量计算</strong></span></a></h4><p><strong>存储容量</strong> 指存储器能存储的二进制信息总量，公式为： <strong>存储容量 = 存储单元数 × 每个单元的位数</strong></p><ul><li>若某存储器有 <strong>1024 个存储单元</strong>，每个单元 <strong>8 位</strong>，则总容量为： <code>1024 × 8 = 8192位 = 1024字节（1KB）</code></li><li>单位换算： <code>1KB=1024B</code>，<code>1MB=1024KB</code>，<code>1GB=1024MB</code>，依此类推。</li></ul><h4 id="二、存储块计算方式" tabindex="-1"><a class="header-anchor" href="#二、存储块计算方式"><span><strong>二、存储块计算方式</strong></span></a></h4><p><strong>存储块</strong> 是主存与 Cache 之间数据交换的最小单位，计算需明确：</p><ol><li><p><strong>主存总容量</strong></p></li><li><p><strong>块大小</strong>（主存与 Cache 的块大小必须一致）</p><p><strong>公式</strong>： <strong>主存块数量 = 主存总容量 ÷ 块大小</strong><strong>Cache 块数量 = Cache 总容量 ÷ 块大小</strong></p></li></ol><p><strong>示例</strong>：</p><ul><li>主存容量 <strong>1MB</strong>，块大小 <strong>16 字节</strong>： <code>1MB ÷ 16B = 65536块</code></li><li>Cache 容量 <strong>64KB</strong>，块大小 <strong>16 字节</strong>： <code>64KB ÷ 16B = 4096块</code></li></ul><h4 id="计算机的存储体系" tabindex="-1"><a class="header-anchor" href="#计算机的存储体系"><span>计算机的存储体系</span></a></h4><p>计算机中不同容量、不同速度、不同访问形式、不同用途的各种存储器形成的是一种层次结构的存储系统。所有的存储器设备按照一定的层次逻辑关系通过软硬件连接起来，并进行有效的管理，就形成了存储体系。不同层次上的存储器发挥着不同的作用。</p><p>一般计算机系统中主要有两种存储体系:</p><p>Cache 存储体系由 Cache 和主存储器构成，主要目的是提高存储器速度，对系统程序员以上均透明; 虚拟存储体系由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明。</p><h4 id="存储体系中的存储器" tabindex="-1"><a class="header-anchor" href="#存储体系中的存储器"><span>存储体系中的存储器</span></a></h4><p>按访问方式可分为按 <strong>地址访问的存储器</strong> 和 <strong>按内容访问的存储器</strong>;</p><p>按寻址方式分类可分为 <strong>随机存储器</strong>、<strong>顺序存储器</strong> 和 <strong>直接存储器</strong>。</p><ul><li><p>随机存储器(Random AccessMemory，<strong>RAM</strong>)指可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间是相同的。</p></li><li><p>顺序存储器(Sequentially AddressedMemory，SAM)指访问数据所需要的时间与数据所在的存储位置相关，磁带是典型的顺序存储器。</p></li><li><p>直接存储器(Direct AddressedMemory，<strong>DAM</strong>)是介于随机存取和顺序存取之间的一种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而在一个磁道内，则是顺序寻址。</p></li></ul><p>按照内容访问可分为相联存储器</p><ul><li>相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，将该关键字与存储器中的每一单元进行比较，从而找出存储器中所有与关键字相同的数据字。</li></ul><h3 id="总线系统" tabindex="-1"><a class="header-anchor" href="#总线系统"><span>总线系统</span></a></h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h4><p>总线（Bus）是一组信号线组成的传输线束，它作为计算机各种功能部件之间传送信息的公共通信干线。根据计算机所传输的信息种类，总线可以分为数据总线、地址总线和控制总线。</p><ul><li><strong>数据总线（Data Bus）</strong>：用于在 CPU 与 RAM 之间来回传送需要处理或是需要储存的数据。它是双向的，意味着数据可以在两个方向上传输。</li><li><strong>地址总线（Address Bus）</strong>：用来指定在 RAM 之中储存的数据的地址。它是单向的，从 CPU 发出到内存或其他设备。</li><li><strong>控制总线（Control Bus）</strong>：将微处理器控制单元的信号传送到周边设备，如 USB Bus 和 1394 Bus 等。</li></ul><p><strong>总线的分类</strong></p><p>总线可以根据其所在位置、传输方式和工作模式进行分类：</p><ul><li><p><strong>按位置分</strong>：</p><ul><li>内部总线（片内总线）：存在于 CPU 芯片内部，用于寄存器之间和算术逻辑部件 ALU 与控制部件之间的数据传输。</li><li>系统总线（板级总线）：连接微机各插件板与系统板之间的总线，实现插件板一级的互联。</li><li>外部总线（通信总线）：连接计算机与其他外部设备或系统之间的总线。</li></ul></li><li><p><strong>按传输方式分</strong>：</p><ul><li>并行总线：多位数据同时通过多条线路传输，适合短距离高速数据传输。</li><li>串行总线：数据一位接一位地顺序传输，适用于长距离传输，成本较低且抗干扰能力强。</li></ul></li><li><p><strong>按工作模式分</strong>：</p><ul><li>单工：数据只能在一个方向上传输。</li><li>半双工：允许数据双向传输，但同一时间只能在一个方向上进行。</li><li>全双工：支持数据同时双向传输。</li></ul></li></ul><p><strong>总线性能指标</strong></p><p>了解总线的性能指标对于评估系统的效率至关重要。主要的性能指标包括：</p><ul><li><strong>带宽（Bandwidth）</strong>：指总线每秒可以传输的最大数据量，通常以位/秒（bps）或字节/秒（Bps）表示。</li><li><strong>总线速度（Bus Speed）</strong>：即总线的时钟频率，决定了每秒能进行多少次数据传输周期。</li><li><strong>总线协议（Bus Protocol）</strong>：定义了总线上的设备如何进行通信的具体规则。</li><li><strong>总线仲裁（Bus Arbitration）</strong>：当多个设备尝试同时访问总线时，决定哪个设备获得优先权的机制。</li></ul><p><strong>总线设计考虑因素</strong></p><p>在选择或设计总线时，需要综合考虑以下因素：</p><ul><li>数据传输速率的需求。</li><li>可靠性和稳定性，尤其是在高负载情况下。</li><li>成本效益分析，包括硬件成本和维护成本。</li><li>电磁兼容性（EMC），特别是在并行总线设计中尤为重要。</li></ul><h4 id="总线结构" tabindex="-1"><a class="header-anchor" href="#总线结构"><span>总线结构</span></a></h4><h5 id="单总线结构-single-bus-architecture" tabindex="-1"><a class="header-anchor" href="#单总线结构-single-bus-architecture"><span><strong>单总线结构（Single Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>所有设备共享一条单一总线（数据、地址、控制信号复用）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：简单、成本低、易于扩展。</li><li><strong>缺点</strong>：带宽瓶颈（多设备竞争）、延迟高。</li></ul></li><li><p><strong>应用场景</strong>：早期微型计算机（如 8 位 / 16 位系统）、嵌入式系统。</p></li></ul><h5 id="_2-双总线结构-dual-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_2-双总线结构-dual-bus-architecture"><span><strong>2. 双总线结构（Dual Bus Architecture）</strong></span></a></h5><ul><li><p>结构分为</p><p>系统总线（连接 CPU、内存）和 I/O 总线（连接外设）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：分离高速与低速设备，减少冲突。</li><li><strong>缺点</strong>：需通过桥接器（如北桥芯片）中转，增加延迟。</li></ul></li><li><p><strong>应用场景</strong>：传统 x86 架构计算机（如 PCI 总线与 ISA 总线并存）。</p></li></ul><h5 id="_3-多总线结构-multi-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_3-多总线结构-multi-bus-architecture"><span><strong>3. 多总线结构（Multi-Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>多级总线分层连接，如高速总线（如 PCIe）连接 CPU 与显卡，低速总线（如 USB）连接外设。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：优化带宽分配，支持高速设备（如 GPU、SSD）。</li><li><strong>缺点</strong>：复杂度高，需总线控制器协调。</li></ul></li><li><p><strong>应用场景</strong>：现代服务器、高性能计算机。</p></li></ul><h5 id="_4-层次化总线结构-hierarchical-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_4-层次化总线结构-hierarchical-bus-architecture"><span><strong>4. 层次化总线结构（Hierarchical Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>总线按层次划分，如：</p><ol><li><strong>片内总线</strong>（SoC 内部，如 AMBA AHB/AXI）；</li><li><strong>系统总线</strong>（主板级，如 PCIe）；</li><li><strong>外部总线</strong>（外设级，如 USB）。</li></ol></li><li><p>特点</p><ul><li><strong>优点</strong>：分层管理，提升整体性能。</li><li><strong>缺点</strong>：依赖协议兼容性（如 PCIe 与 USB 的转换）。</li></ul></li><li><p><strong>应用场景</strong>：智能手机 SoC（如骁龙芯片）、个人计算机。</p></li></ul><h5 id="_5-专用总线结构" tabindex="-1"><a class="header-anchor" href="#_5-专用总线结构"><span><strong>5. 专用总线结构</strong></span></a></h5><ul><li><p>示例</p><ul><li><strong>内存总线</strong>：专用连接 CPU 与内存（如 DDR4/DDR5）；</li><li><strong>存储总线</strong>：连接存储控制器与硬盘（如 SATA、NVMe）。</li></ul></li><li><p>特点</p><ul><li><strong>优点</strong>：针对特定设备优化，高带宽、低延迟。</li><li><strong>缺点</strong>：通用性差。</li></ul><p><strong>总线结构的性能对比</strong></p><table><thead><tr><th><strong>结构类型</strong></th><th><strong>带宽</strong></th><th><strong>延迟</strong></th><th><strong>扩展性</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td>单总线</td><td>低</td><td>高</td><td>有限</td><td>嵌入式系统、早期微机</td></tr><tr><td>双总线</td><td>中</td><td>中</td><td>中等</td><td>传统 PC（已淘汰）</td></tr><tr><td>多总线</td><td>高</td><td>低</td><td>强</td><td>服务器、游戏 PC</td></tr><tr><td>层次化总线</td><td>极高</td><td>极低</td><td>极强</td><td>智能手机 SoC、高性能计算</td></tr></tbody></table></li></ul><h4 id="总线带宽计算" tabindex="-1"><a class="header-anchor" href="#总线带宽计算"><span>总线带宽计算</span></a></h4><p><strong>总线带宽 = 总线宽度 × 时钟频率</strong></p><p>假设我们有一个 32 位宽的总线，并且它的时钟频率是 200MHz，那么根据上述公式，我们可以这样计算总线带宽：</p><p>总线带宽 = 32 bits×200 MHz = 6400 Mbits/s</p><p>但是，因为数据传输率通常以字节（Byte）而非比特（bit）来表示，我们需要将结果转换成字节形式。由于 1 字节等于 8 比特，所以：</p><p>总线带宽 = 64008 MB/s = 800 MB/s</p><p>或者，如果我们想要将其转换为 GB/s，则需要进一步除以 1024：</p><p>总线带宽 = 8001024 GB/s≈0.78 GB/s</p><h3 id="输入输出系统" tabindex="-1"><a class="header-anchor" href="#输入输出系统"><span>输入输出系统</span></a></h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h4><ol><li><p><strong>输入输出定义</strong></p><ul><li><strong>输入</strong>：数据从外部设备传入计算机（如键盘、扫描仪）。</li><li><strong>输出</strong>：数据从计算机传出到外部设备（如显示器、打印机）。</li></ul></li><li><p><strong>输入输出系统组成</strong></p><ul><li><strong>外设</strong>：输入 / 输出设备（如磁盘、网卡）。</li><li><strong>I/O 接口</strong>：连接 CPU 与外设的桥梁，含数据、状态、控制寄存器。</li><li><strong>总线</strong>：系统总线（地址、数据、控制）用于传输信号。</li></ul></li></ol><h4 id="数据传送方式" tabindex="-1"><a class="header-anchor" href="#数据传送方式"><span>数据传送方式</span></a></h4><ol><li><p><strong>无条件传送</strong></p><ul><li>CPU 直接读写外设，无需状态查询。</li><li><strong>适用场景</strong>：简单外设（如开关、LED）。</li></ul></li><li><p><strong>查询传送</strong></p><ul><li>CPU 循环检测外设状态，就绪后传输数据。</li><li><strong>优点</strong>：实现简单；<strong>缺点</strong>：CPU 利用率低。</li></ul></li><li><p><strong>中断方式</strong></p><ul><li>外设主动向 CPU 发送中断请求，CPU 暂停当前任务处理中断。</li><li><strong>优点</strong>：CPU 利用率高；<strong>缺点</strong>：需处理中断上下文切换。</li></ul></li><li><p><strong>DMA（直接内存访问）</strong></p><ul><li>外设直接访问内存，无需 CPU 干预。</li><li><strong>优点</strong>：高速传输，适合大块数据（如磁盘读写）；<strong>缺点</strong>：硬件成本高。</li><li><strong>常考对比</strong>：DMA 与中断的区别（CPU 是否参与数据传输）。</li></ul></li></ol><h4 id="中断嵌套" tabindex="-1"><a class="header-anchor" href="#中断嵌套"><span>中断嵌套</span></a></h4><p>当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为中断嵌套。</p><p><strong>实现中断嵌套用后进先出的栈来保护断点和现场最有效。</strong></p><h3 id="指令系统和计算机体系结构" tabindex="-1"><a class="header-anchor" href="#指令系统和计算机体系结构"><span>指令系统和计算机体系结构</span></a></h3><h4 id="程序的局部性" tabindex="-1"><a class="header-anchor" href="#程序的局部性"><span>程序的局部性</span></a></h4><p><strong>一、核心概念</strong></p><p>程序的局部性原理是指 <strong>程序在执行时倾向于访问 **** 近期使用过的数据或指令</strong>，以及 <strong>邻近的数据或指令</strong>。这一特性是计算机系统设计（如缓存、虚拟内存）的基础，也是程序优化的重要依据。</p><p><strong>二、局部性分类</strong></p><ol><li><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据或指令被访问，那么在 <strong>不久的将来</strong> 很可能再次被访问。</li><li>示例 <ul><li>循环中的变量（如 <code>for (int i=0; i&lt;1000; i++)</code> 中的 <code>i</code>）。</li><li>函数调用中的局部变量（多次被使用）。</li></ul></li></ul></li><li><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><p><strong>定义</strong>：如果一个数据或指令被访问，那么与其 <strong>相邻的内存区域</strong> 的数据或指令也可能很快被访问。</p></li><li><p>示例</p><ul><li>连续存储的数组元素（如 <code>arr[0], arr[1], arr[2]</code>）。</li><li>代码中的顺序执行（如连续的指令块）。</li></ul></li></ul></li></ol><h5 id="精简指令系统和复杂指令系统" tabindex="-1"><a class="header-anchor" href="#精简指令系统和复杂指令系统"><span>精简指令系统和复杂指令系统</span></a></h5><ol><li><p><strong>RISC（精简指令系统）</strong></p><ul><li><strong>设计理念</strong>：简化指令集，通过减少指令种类和复杂度提升执行效率。</li><li><strong>典型代表</strong>：ARM、MIPS、RISC-V。</li></ul></li><li><p><strong>CISC（复杂指令系统）</strong></p><ul><li><p><strong>设计理念</strong>：提供丰富复杂的指令，通过单条指令完成复杂操作以减少代码量。</p></li><li><p><strong>典型代表</strong>：x86（如 Intel/AMD 处理器）。</p></li></ul></li></ol><table><thead><tr><th><strong>对比项</strong></th><th style="text-align:center;"><strong>RISC</strong></th><th><strong>CISC</strong></th></tr></thead><tbody><tr><td><strong>指令数量</strong></td><td style="text-align:center;">少（约 100 条以内）</td><td>多（可达数百条）</td></tr><tr><td><strong>指令长度</strong></td><td style="text-align:center;">固定（便于流水线处理）</td><td>可变（复杂指令长度不同）</td></tr><tr><td><strong>执行周期</strong></td><td style="text-align:center;">单周期执行</td><td>多周期执行</td></tr><tr><td><strong>内存访问</strong></td><td style="text-align:center;">仅 LOAD/STORE 指令访问内存</td><td>指令可直接操作内存</td></tr><tr><td><strong>流水线效率</strong></td><td style="text-align:center;">高（指令简单，并行性强）</td><td>低（指令复杂，易阻塞流水线）</td></tr><tr><td><strong>硬件复杂度</strong></td><td style="text-align:center;">低（无需微程序控制）</td><td>高（需微程序解析复杂指令）</td></tr><tr><td><strong>编译器依赖</strong></td><td style="text-align:center;">高（依赖编译器优化）</td><td>低（指令功能强，编程灵活）</td></tr></tbody></table><h4 id="流水线概念以及常见计算" tabindex="-1"><a class="header-anchor" href="#流水线概念以及常见计算"><span>流水线概念以及常见计算</span></a></h4><p><strong>一、吞吐率定义</strong></p><ul><li><strong>概念</strong>：单位时间内完成的指令数量（或任务数），衡量流水线的处理效率。</li><li><strong>公式</strong>： <strong>吞吐率（TP）= 指令数（n） / 总执行时间（T）</strong> 单位：指令数 / 时间单位（如条 / 秒、条 /ns）。</li></ul><p><strong>二、流水线吞吐率计算</strong></p><ol><li><p><strong>最大吞吐率（理想情况）</strong></p><ul><li>当流水线完全填满后，每周期完成一条指令。<strong>最长执行时间的倒数</strong></li><li><strong>公式</strong>： <strong>最大吞吐率（TP_max）= 1 / 最长阶段时间（Δt_max）</strong></li><li><strong>示例</strong>：最长阶段时间为 3ns → TP_max ≈ 0.33 条 /ns。</li></ul></li><li><p><strong>实际吞吐率（考虑指令数）</strong></p><ul><li><strong>公式</strong>： <strong>TP = n / [ (k + n -1) × Δt_max ]</strong> （k 为阶段数，n 为指令数）</li><li><strong>示例</strong>：k = 5，n = 100，Δt_max = 3ns → TP = 100 / 312 ≈ 0.32 条 /ns。</li></ul></li></ol><h4 id="vliw-超长指令字" tabindex="-1"><a class="header-anchor" href="#vliw-超长指令字"><span>VLIW（超长指令字）</span></a></h4><p>一种非常长的指令组合，把许多条指令连在一起增加运算速度。</p><h4 id="寻址方式" tabindex="-1"><a class="header-anchor" href="#寻址方式"><span>寻址方式</span></a></h4><p>采用不同寻址方式的目的是为了扩大寻址空间提高编程灵活性</p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>立即寻址</strong></td><td>操作数直接包含在指令中</td><td><code>ADD R0, #5</code>（R0 += 5）</td><td>无需内存访问，速度快，但操作数范围受限（受指令长度限制）。</td></tr><tr><td><strong>直接寻址</strong></td><td>指令中包含内存地址</td><td><code>LOAD R1, [0x1000]</code>（R1 = 内存 0x1000）</td><td>地址固定，适合访问静态数据，但地址空间有限（需完整地址位）。</td></tr><tr><td><strong>寄存器寻址</strong></td><td>操作数存于寄存器中</td><td><code>ADD R0, R1</code>（R0 += R1）</td><td>速度最快，RISC 架构核心方式（如 ARM、RISC-V）。</td></tr><tr><td><strong>寄存器间接寻址</strong></td><td>寄存器存储内存地址</td><td><code>LOAD R2, [R3]</code>（R2 = 内存 [R3]）</td><td>灵活访问动态数据，适合数组、指针操作。</td></tr><tr><td><strong>基址寻址</strong></td><td>基址寄存器 + 偏移量确定地址</td><td><code>LOAD R4, [R5+0x20]</code>（R4 = 内存 [R5+32]）</td><td>简化数组、结构体访问，支持内存分段管理。</td></tr><tr><td><strong>变址寻址</strong></td><td>变址寄存器 + 偏移量确定地址</td><td><code>LOAD R6, [0x1000+R7]</code>（R6 = 内存 [2560 + R7]）</td><td>适合循环遍历数组，偏移量固定，寄存器动态调整。</td></tr><tr><td><strong>相对寻址</strong></td><td>当前指令地址 + 偏移量确定地址</td><td><code>JMP 0x10</code>（跳转到当前地址 + 16）</td><td>常用于分支指令，节省地址空间（只需偏移量）。</td></tr></tbody></table><p><strong>典型应用场景</strong></p><ol><li><strong>立即寻址</strong>：初始化常量、简单运算。</li><li><strong>寄存器间接寻址</strong>：动态数据访问（如链表、堆内存）。</li><li><strong>基址 + 变址寻址</strong>：二维数组、结构体成员访问。</li><li><strong>相对寻址</strong>：程序跳转（如函数调用、条件分支）。</li></ol><h4 id="寻址范围计算" tabindex="-1"><a class="header-anchor" href="#寻址范围计算"><span>寻址范围计算</span></a></h4><p>范围 = 内存容量/字节长度</p><h4 id="flynn-分类法" tabindex="-1"><a class="header-anchor" href="#flynn-分类法"><span>flynn 分类法</span></a></h4><p><strong>Flynn 分类法定义</strong></p><ul><li><p><strong>提出背景</strong>：由 Michael J. Flynn 于 1966 年提出，用于 <strong>根据指令流（Instruction Stream）和数据流（Data Stream）的并行性</strong> 对计算机体系结构进行分类。</p></li><li><p>核心维度：</p><ol><li><strong>指令流并行性</strong>：是否同时执行多条指令。</li><li><strong>数据流并行性</strong>：是否同时处理多个数据项。</li></ol><h4 id="flynn-分类法四大类型" tabindex="-1"><a class="header-anchor" href="#flynn-分类法四大类型"><span><strong>Flynn 分类法四大类型</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>全称</strong></th><th><strong>指令流</strong></th><th><strong>数据流</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>SISD</strong></td><td>单指令流单数据流</td><td>单指令</td><td>单数据</td><td>传统串行计算机，无并行处理能力。</td><td>早期个人计算机（如 8086）</td></tr><tr><td><strong>SIMD</strong></td><td>单指令流多数据流</td><td>单指令</td><td>多数据</td><td>一条指令操作多个数据（数据级并行）。</td><td>GPU、向量处理器（如 Intel AVX）</td></tr><tr><td><strong>MISD</strong></td><td>多指令流单数据流</td><td>多指令</td><td>单数据</td><td>理论上存在，实际应用极少（可能用于容错处理）。</td><td>研究原型（如某些纠错系统）</td></tr><tr><td><strong>MIMD</strong></td><td>多指令流多数据流</td><td>多指令</td><td>多数据</td><td>多条指令独立操作多个数据（任务级并行）。</td><td>多核 CPU、分布式计算集群</td></tr></tbody></table></li></ul><h3 id="系统性能评测和可靠性基础" tabindex="-1"><a class="header-anchor" href="#系统性能评测和可靠性基础"><span>系统性能评测和可靠性基础</span></a></h3><h4 id="系统可靠度计算" tabindex="-1"><a class="header-anchor" href="#系统可靠度计算"><span>系统可靠度计算</span></a></h4><p>可靠度表示为 R</p><p><strong>串联</strong>: R 相乘</p><p><strong>示例</strong>：R1 = 0.9, <em>R</em> 2 = 0.95, <em>R</em> 3 = 0.98。</p><p><em>R</em> 串联 = 0.9×0.95×0.98 = 0.8379(83.79%)</p><p><strong>并联:</strong></p><p>两个并联为 1-(1-R)²</p><p>R = 0.9</p><p>R 并联 = 1−(0.1×0.1)= 0.99(99%)</p><p><img src="'+h+`" alt="image-20250405110413577"></p><p>可靠度为（1-（1-R）³）（1-（1-R）²）</p><h2 id="程序语言" tabindex="-1"><a class="header-anchor" href="#程序语言"><span>程序语言</span></a></h2><h3 id="程序设计语言基础概念" tabindex="-1"><a class="header-anchor" href="#程序设计语言基础概念"><span>程序设计语言基础概念</span></a></h3><h4 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念"><span>核心概念</span></a></h4><ol><li><p><strong>低级语言 vs 高级语言</strong></p><ul><li><strong>低级语言</strong>：机器语言（二进制指令）、汇编语言（符号指令），执行效率高但开发效率低。</li><li><strong>高级语言</strong>：Java、C、Python 等，接近自然语言，开发效率高但需翻译（编译 / 解释）。</li></ul></li><li><p><strong>编译程序 vs 解释程序</strong></p><ul><li><strong>编译程序</strong>：一次性生成目标程序（如.exe 文件），执行效率高，不可调试。</li><li><strong>解释程序</strong>：边翻译边执行，开发灵活但效率低（如 Python、JavaScript）。</li></ul></li><li><p><strong>语言三要素</strong></p><ul><li><p><strong>语法</strong>：结构规则（如括号匹配、分号结尾）。</p></li><li><p><strong>语义</strong>：逻辑含义（如变量类型是否匹配）。</p></li><li><p><strong>语用</strong>：符号与使用者的关系（如注释、代码规范）。</p></li></ul></li></ol><h4 id="语言处理程序基础" tabindex="-1"><a class="header-anchor" href="#语言处理程序基础"><span>语言处理程序基础</span></a></h4><ul><li><strong>词法分析</strong>：识别单词符号（如关键字、标识符）。</li><li><strong>语法分析</strong>：检查语法结构（如表达式是否合法）。</li><li><strong>语义分析</strong>：类型检查（如整数与字符串相加错误）。</li><li><strong>中间代码生成</strong>：转换为与机器无关的代码（如逆波兰式、四元式）。</li><li><strong>代码优化</strong>：提升执行效率（如循环展开、冗余删除）。</li><li><strong>目标代码生成</strong>：输出机器语言或汇编代码。</li></ul><h4 id="程序设计语言基本成分" tabindex="-1"><a class="header-anchor" href="#程序设计语言基本成分"><span>程序设计语言基本成分</span></a></h4><ol><li><p><strong>数据成分</strong></p><ul><li><strong>常量 / 变量</strong>：全局量（静态存储） vs 局部量（动态存储）。</li><li><strong>数据类型</strong>：基本类型（int、char）、构造类型（数组、结构体）、抽象类型（类）。</li></ul></li><li><p><strong>控制成分</strong></p><ul><li><strong>条件语句</strong>：<code>if-else</code>、<code>switch-case</code>。</li><li><strong>循环语句</strong>：<code>for</code>、<code>while</code>、<code>do-while</code>。</li><li><strong>函数调用</strong>: <ul><li><strong>值调用</strong>：形参修改不影响实参。</li><li><strong>引用调用</strong>：形参修改直接影响实参（如 C++ 的指针）。</li></ul></li></ul></li><li><p><strong>运算成分</strong></p><ul><li><p><strong>运算符优先级</strong>：如 <code>*</code> 高于 <code>+</code>。</p></li><li><p><strong>逻辑运算</strong>：<code>&amp;&amp;</code>（短路与）、<code>||</code>（短路或）、<code>!</code>。</p></li></ul></li></ol><h4 id="核心传递方式对比-软考高频" tabindex="-1"><a class="header-anchor" href="#核心传递方式对比-软考高频"><span><strong>核心传递方式对比（软考高频）</strong></span></a></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>定义</strong></th><th><strong>语言示例</strong></th><th><strong>是否修改实参</strong></th><th><strong>常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>值调用</strong></td><td>传递参数副本，函数内修改不影响实参。</td><td>C 的普通参数、Java 基本类型</td><td>❌ 否</td><td>交换函数无效（如 <code>swap(int a, int b)</code> 无法交换实参）。</td></tr><tr><td><strong>引用调用</strong></td><td>传递实参地址（或别名），函数内修改直接影响实参。</td><td>C++ 引用（<code>&amp;</code>）、C# <code>ref</code>/<code>out</code></td><td>✅ 是</td><td>Java 对象引用是 “值传递的引用”：可修改对象属性，但无法改变引用指向（如无法交换两个对象）。</td></tr><tr><td><strong>指针传递</strong></td><td>传递指针变量（地址的副本），通过解引用修改实参。</td><td>C 的指针（<code>int*</code>）</td><td>✅ 是</td><td>区分 “传递指针” 与 “传递指针指向的值”：<code>func(int* p)</code> 可改 <code>*p</code>，但无法改 <code>p</code> 本身（如交换指针无效）。</td></tr><tr><td><strong>传名调用</strong></td><td>参数在调用处替换为表达式，可能多次求值（已过时，软考仅考概念）。</td><td>Algol、早期 Pascal</td><td>✅ 可能</td><td>副作用：表达式含自增（如 <code>a++</code>）时，多次求值导致结果不可控。</td></tr></tbody></table><p><strong>典型语言实现与常考细节</strong></p><ol><li><strong>C 语言</strong><ul><li><strong>值调用</strong>：默认方式，如 <code>void f(int x) { x=5; }</code>，调用后实参不变。</li><li><strong>指针传递</strong>：需显式传递地址，如 <code>void f(int* x) { *x=5; }</code>，调用 <code>f(&amp;a)</code> 修改 <code>a</code>。</li><li><strong>常考题</strong>：交换函数必须用指针，否则无效。</li></ul></li><li><strong>C++</strong><ul><li><strong>引用调用</strong>：<code>void f(int&amp; x) { x=5; }</code>，实参直接被修改。</li><li><strong>区别指针</strong>：引用必须初始化，且语法更简洁（无需 <code>*</code>）。</li></ul></li><li><strong>Java</strong><ul><li><strong>基本类型</strong>：值调用，如 <code>void f(int x)</code> 无法修改实参。</li><li><strong>对象类型</strong>：传递对象引用的副本（值调用的引用），可修改对象属性（如 <code>obj.name=&quot;new&quot;</code>），但无法改变引用指向（如无法通过函数让 <code>obj</code> 指向新对象）。</li><li><strong>常考题</strong>：判断 “Java 的对象传递是引用调用” 是否正确（错误，本质是值传递的引用）。</li></ul></li><li><strong>C#</strong><ul><li><strong><code>ref</code></strong>：引用调用，实参需初始化，如 <code>void f(ref int x) { x=5; }</code>。</li><li><strong><code>out</code></strong>：强制函数内赋值，用于 “输出参数”，如 <code>void f(out int x) { x=5; }</code>。</li></ul></li><li><strong>Python</strong><ul><li><strong>可变对象（列表、字典）</strong>：值调用传递对象引用，可修改内容（如 <code>lst.append(3)</code>），但无法重新赋值（如 <code>lst = [1,2]</code> 不影响实参）。</li><li><strong>不可变对象（整数、字符串）</strong>：值调用，修改无效。</li></ul></li></ol><h4 id="语言分类以及特点" tabindex="-1"><a class="header-anchor" href="#语言分类以及特点"><span>语言分类以及特点</span></a></h4><table><thead><tr><th><strong>分类</strong></th><th><strong>代表语言</strong></th><th><strong>核心特点</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><strong>命令式语言</strong></td><td>C、Java、C#、C++</td><td>强调算法步骤，支持变量和控制流（顺序、分支、循环），分面向过程和面向对象。</td><td>C：系统开发、嵌入式；Java/C#：企业级应用、Android 开发；C++：游戏引擎、桌面软件。</td></tr><tr><td><strong>函数式语言</strong></td><td>Haskell、Lisp、Scala</td><td>纯函数、不可变性、惰性求值，强调数学计算逻辑。</td><td>Haskell：金融计算；Lisp：早期 AI；Scala：大数据处理（Spark）。</td></tr><tr><td><strong>逻辑式语言</strong></td><td>Prolog</td><td>基于一阶逻辑，声明性编程，自动推理。</td><td>专家系统、自然语言处理、数据库查询优化。</td></tr><tr><td><strong>脚本语言</strong></td><td>Python、JavaScript、PHP</td><td>动态类型、语法简洁、解释执行，开发效率高。</td><td>Python：数据分析、AI；JavaScript：Web 全栈；PHP：中小型 Web 应用。</td></tr><tr><td><strong>科学计算语言</strong></td><td>Fortran、MATLAB</td><td>高效数值计算，支持矩阵运算和可视化。</td><td>Fortran：工程模拟；MATLAB：信号处理、控制系统设计。</td></tr><tr><td><strong>现代语言</strong></td><td>Go、Swift、Rust</td><td>高性能、安全性、简洁语法，支持并发或特定场景优化。</td><td>Go：云服务（Docker）；Swift：iOS 开发；Rust：区块链、内存安全服务端。</td></tr><tr><td><strong>其他重要语言</strong></td><td>SQL</td><td>非过程化，面向数据操作，声明式查询。</td><td>数据库管理、数据检索与分析。</td></tr></tbody></table><h4 id="错误类型分类" tabindex="-1"><a class="header-anchor" href="#错误类型分类"><span>错误类型分类</span></a></h4><table><thead><tr><th><strong>错误类型</strong></th><th><strong>定义</strong></th><th><strong>典型示例</strong></th><th><strong>语言示例</strong></th><th><strong>软考常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>语法错误</strong></td><td>违反编程语言的语法规则，无法通过编译。</td><td>缺少分号、括号不匹配、关键字拼写错误</td><td>C、Java、Python 编译阶段报错</td><td>注意中文符号（如 “；” 代替 “;”）导致的隐藏错误。</td></tr><tr><td><strong>类型错误</strong></td><td>操作符与操作数类型不匹配，编译阶段检查。</td><td>字符串与整数相加、数组越界</td><td>C 的 <code>int + char</code>、Java 的 <code>String s = 123</code></td><td>注意自动类型转换（如 C 的 <code>char</code> 转 <code>int</code>）可能掩盖类型错误。</td></tr><tr><td><strong>语义错误</strong></td><td>语法正确但逻辑含义错误，导致程序行为不符合预期。</td><td>条件判断错误、算法逻辑错误</td><td>错误的循环终止条件、错误的公式计算</td><td>软考常考 “逻辑错误” 与 “运行时错误” 的区分：逻辑错误可能在运行时才暴露。</td></tr><tr><td><strong>运行时错误</strong></td><td>程序运行期间发生的错误，通常导致程序崩溃或异常。</td><td>除零错误、空指针解引用、数组越界</td><td>C 的 <code>NULL指针解引用</code>、Java 的 <code>NullPointerException</code></td><td>注意 Java 的 “受检异常” 与 “非受检异常” 区别（如 <code>IOException</code> 需显式处理）。</td></tr><tr><td><strong>链接错误</strong></td><td>编译通过但链接阶段找不到符号（如未定义的函数或变量）。</td><td>函数声明与实现不匹配、库文件缺失</td><td>C 的 <code>undefined reference to &#39;func&#39;</code></td><td>软考可能结合编译流程考查链接错误的原因（如函数名大小写不一致）。</td></tr><tr><td><strong>逻辑错误</strong></td><td>算法设计错误，导致结果不正确但程序不崩溃。</td><td>排序算法错误、错误的业务逻辑</td><td>冒泡排序中的循环次数错误</td><td>逻辑错误是软考重点考查对象，需通过测试用例发现（如错误的闰年判断条件）。</td></tr></tbody></table><h4 id="典型错误类型解析与常考细节" tabindex="-1"><a class="header-anchor" href="#典型错误类型解析与常考细节"><span><strong>典型错误类型解析与常考细节</strong></span></a></h4><ol><li><p><strong>语法错误</strong></p><ul><li><p><strong>特点</strong>：编译阶段直接报错，必须修复才能运行。</p></li><li><p>示例</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 缺少分号（语法错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：混淆 “语法错误” 与 “语义错误”，例如 <code>if (a = 0)</code> 是语法正确但语义错误（应为 <code>a == 0</code>）。</p></li></ul></li><li><p><strong>运行时错误</strong></p><ul><li><p>分类</p><ul><li><strong>异常</strong>：可捕获处理（如 Java 的 <code>try-catch</code>）。</li><li><strong>崩溃</strong>：不可恢复（如 C 的除零错误直接终止程序）。</li></ul></li><li><p>示例</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数组越界（运行时错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考常考</strong>：Java 的 <code>ArrayIndexOutOfBoundsException</code> 属于运行时错误，而 C 的数组越界可能导致未定义行为。</p></li></ul></li><li><p><strong>逻辑错误</strong></p><ul><li><p><strong>隐蔽性</strong>：程序正常运行但结果错误，需通过测试发现。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">def</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> is_leap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">year</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> year </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">%</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 错误，未处理整百年（软考经典逻辑错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考重点</strong>：算法设计题中常见，如错误的循环条件导致结果偏差。</p></li></ul></li><li><p><strong>类型错误</strong></p><ul><li><p><strong>静态类型语言</strong>（如 C、Java）：编译阶段检查。</p></li><li><p><strong>动态类型语言</strong>（如 Python）：运行时检查。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 运行时类型错误（Python）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：Java 的自动拆箱 / 装箱可能掩盖类型错误（如 <code>Integer i = null; int j = i;</code> 导致 <code>NullPointerException</code>）。</p></li></ul></li></ol><h3 id="编译、解释系统" tabindex="-1"><a class="header-anchor" href="#编译、解释系统"><span>编译、解释系统</span></a></h3><h4 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h4><p><strong>编译是将高级程序设计语言编写的源程序转化为目标机器可执行的机器语言程序的过程</strong>。</p><ul><li><strong>词法分析</strong>：编译的第一个阶段，使用有限自动机实现。从左到右扫描源程序字符流，依据词法规则将其识别为一个个单词，如关键字、标识符、常量、运算符等。</li><li><strong>语法分析</strong>：基于词法分析得到的单词序列，依据语法规则，使用多种方法如 <strong>自顶向下</strong>（递归下降分析法和预测分析法）<strong>和自底向上</strong> 等（移进-归约分析法），构建语法树，检查源程序的语法结构是否正确。</li><li><strong>语义分析</strong>：在语法分析基础上，对语法树进行遍历，依据语义规则检查源程序语义的正确性，如类型检查、变量声明与使用一致性检查等，并进行必要的语义处理，如生成中间代码。</li><li><strong>中间代码生成</strong>：是编译程序的重要阶段，将源程序转换为一种中间表示形式，<strong>方便进行与目标机器无关的优化和生成目标代码</strong>，常采用规定的表示形式有 <strong>三地址码、四元式、后缀式、语法树</strong> 等。</li><li><strong>代码优化</strong>：对中间代码进行等价变换，依据优化原则和技术，如常量折叠、公共子表达式删除等，提高目标代码的执行效率。</li><li><strong>目标代码生成</strong>：根据目标机器的指令集和体系结构，将优化后的中间代码转换为目标机器可执行的机器语言代码，涉及寄存器分配、指令选择等工作。</li></ul><p>常见的中间代码形式。</p><h4 id="编译语言和解释语言" tabindex="-1"><a class="header-anchor" href="#编译语言和解释语言"><span>编译语言和解释语言</span></a></h4><p><strong>编译语言</strong></p><ul><li><strong>简介</strong>：编写的源代码通过编译器一次性翻译成目标机器的机器码，生成可执行文件，执行时直接运行可执行文件。</li><li><strong>举例</strong>：C、C++、Java（Java 有编译过程，生成字节码，在虚拟机上运行，也可看作特殊的编译语言）等。</li></ul><p><strong>解释语言</strong></p><ul><li><p><strong>简介</strong>：源代码由解释器逐行解释并执行，不生成目标机器码，边解释边执行。</p></li><li><p><strong>举例</strong>：Python、JavaScript、Ruby 等。</p><p><strong>对比</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>解释型语言</strong></th><th><strong>编译型语言</strong></th><th><strong>软考常考点</strong></th></tr></thead><tbody><tr><td><strong>翻译方式</strong></td><td>逐行翻译并立即执行</td><td>一次性整体翻译为目标代码</td><td>翻译方式的差异（逐行 vs 整体）</td></tr><tr><td><strong>运行过程</strong></td><td>源代码 → 解释器 → 执行</td><td>源代码 → 编译器 → 可执行文件 → 执行</td><td>运行阶段的步骤（是否生成中间文件）</td></tr><tr><td><strong>语法检查</strong></td><td>运行时检查（错误即时反馈）</td><td>编译时检查（生成错误报告）</td><td>错误检测的时机（运行时 vs 编译时）</td></tr><tr><td><strong>开发效率</strong></td><td>高（修改后立即生效）</td><td>低（需重新编译）</td><td>开发效率与调试便利性</td></tr><tr><td><strong>执行速度</strong></td><td>慢（逐行解释）</td><td>快（直接执行机器码）</td><td>执行效率对比（软考高频考点）</td></tr><tr><td><strong>跨平台性</strong></td><td>好（只需解释器）</td><td>差（需编译不同平台版本）</td><td>跨平台能力的优劣</td></tr><tr><td><strong>典型语言</strong></td><td>Python、PHP、JavaScript、BASIC</td><td>C、C++、Java（编译为字节码后由 JVM 解释）</td><td>语言分类（如 Java 的特殊性：编译 + 解释）</td></tr><tr><td><strong>代码安全性</strong></td><td>伪码易被反编译</td><td>机器码难逆向</td><td>安全性对比（需注意 Java 的字节码也可能被反编译）</td></tr><tr><td><strong>中间代码</strong></td><td>可能生成中间码（如字节码）但不保存</td><td>生成目标代码（如机器码、汇编）并保存</td><td>是否生成独立的中间文件</td></tr></tbody></table></li></ul><h3 id="文法分析" tabindex="-1"><a class="header-anchor" href="#文法分析"><span>文法分析</span></a></h3><h4 id="_1-文法的定义与分类" tabindex="-1"><a class="header-anchor" href="#_1-文法的定义与分类"><span>1. 文法的定义与分类</span></a></h4><ul><li><strong>文法</strong>：形式化描述语言的规则集合，由四元组 <em>G</em> =(<em>V</em> <em>N</em>, <em>V</em> <em>T</em>, <em>P</em>, <em>S</em>) 表示： <ul><li><em>V</em> <em>N</em>：非终结符集（如 <em>S</em>, <em>A</em>, <em>B</em>）。</li><li><em>V</em> <em>T</em>：终结符集（如 <em>a</em>, <em>b</em>,+）。</li><li><em>P</em>：产生式规则（如 <em>S</em> → <em>a</em> <em>S</em> <em>b</em>）。</li><li><em>S</em>：开始符号。</li></ul></li><li><strong>文法类型（乔姆斯基分类）</strong>： <ul><li><strong>0 型（无限制文法）</strong>：无约束条件，等价于图灵机。</li><li><strong>1 型（上下文有关文法）</strong>：产生式形如 <em>α</em> → <em>β</em>，其中 ∣ <em>α</em> ∣≤∣ <em>β</em> ∣。</li><li><strong>2 型（上下文无关文法）</strong>：产生式形如 <em>A</em> → <em>β</em>，非终结符可替换为任意符号串。</li><li><strong>3 型（正规文法）</strong>：产生式形如 <em>A</em> → <em>a</em> <em>B</em> 或 <em>A</em> → <em>a</em>，对应有限自动机。</li></ul></li></ul><h4 id="_2-推导与归约" tabindex="-1"><a class="header-anchor" href="#_2-推导与归约"><span>2. 推导与归约</span></a></h4><ul><li><strong>推导</strong>：从开始符号出发，通过产生式规则生成句子的过程（如 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> ⇒ <em>aabb</em>）。</li><li><strong>最左（右）推导</strong>：每次替换最左（右）非终结符。</li><li><strong>归约</strong>：推导的逆过程，从句子反向构造语法树。</li></ul><h4 id="_3-语法树与短语" tabindex="-1"><a class="header-anchor" href="#_3-语法树与短语"><span>3. 语法树与短语</span></a></h4><ul><li><strong>语法树</strong>：可视化推导过程的树形结构。</li><li><strong>短语</strong>：某个非终结符可推导出的符号串（如在 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> 中，<em>a</em> <em>S</em> 是相对于 <em>S</em> 的短语）。</li><li><strong>句柄</strong>：最左直接短语，用于自底向上分析（如 LR 分析）。</li></ul><h4 id="_4-语法分析方法" tabindex="-1"><a class="header-anchor" href="#_4-语法分析方法"><span>4. 语法分析方法</span></a></h4><ul><li>自顶向下分析：LL (1)、递归下降分析。 <ul><li><strong>LL(1)</strong>：第一个 L 表示从左到右扫描，第二个 L 表示最左推导，1 表示向前看一个符号。</li><li><strong>条件</strong>：无左递归、无回溯、First 和 Follow 集不相交。</li></ul></li><li>自底向上分析：LR(0)、SLR(1)、LR(1)、LALR(1)。 <ul><li><strong>LR 分析</strong>：L 表示从左到右扫描，R 表示最右推导的逆过程。</li></ul></li></ul><h4 id="软考常考题目解析" tabindex="-1"><a class="header-anchor" href="#软考常考题目解析"><span>软考常考题目解析</span></a></h4><h6 id="_1-文法分类题" tabindex="-1"><a class="header-anchor" href="#_1-文法分类题"><span>1. <strong>文法分类题</strong></span></a></h6><p><strong>题目</strong>：判断以下文法类型：<em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em><strong>分析</strong>：</p><ul><li>产生式形式为 <em>A</em> → <em>β</em>，符合上下文无关文法（2 型）。</li><li>无法转换为正规文法（3 型），因存在递归嵌套。 <strong>答案</strong>：上下文无关文法。</li></ul><h5 id="_2-first-和-follow-集计算" tabindex="-1"><a class="header-anchor" href="#_2-first-和-follow-集计算"><span>2. <strong>First 和 Follow 集计算</strong></span></a></h5><p><strong>题目</strong>：文法 <em>G</em> =(<em>S</em>, <em>A</em>, <em>a</em>, <em>b</em>, <em>P</em>, <em>S</em>)，其中 <em>P</em> 为：<em>S</em> → <em>a</em> <em>A</em> <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em> 求 First (S)、First (A)、Follow (S)、Follow (A)。 <strong>解答</strong>：</p><ul><li><p><strong>First(S)</strong>：由 <em>S</em> → <em>a</em> <em>A</em>，First(S) = {a}。</p></li><li><p><strong>First(A)</strong>：由 <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，First(A) = {b, ε}。</p></li><li><p>Follow(S)</p><p>：</p><ul><li>S 是开始符号，初始 Follow (S) = {#}。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号。</li><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号，而 A 可推导出 ε，因此 Follow (S) = Follow (S) ∪ Follow (A)。</li><li>最终 Follow (S) = {#, b}。</li></ul></li><li><p>Follow(A)</p><p>：</p><ul><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号（即 {#, b}）。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号，但 S 的 Follow 集包含 {#, b}，因此 Follow (A) = {#, b}。</li></ul></li></ul><h5 id="_3-ll-1-文法判定" tabindex="-1"><a class="header-anchor" href="#_3-ll-1-文法判定"><span>3. <strong>LL (1) 文法判定</strong></span></a></h5><p><strong>题目</strong>：判断文法 <em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em> 是否为 LL (1)。 <strong>分析</strong>：</p><ul><li><p><strong>First(S)</strong>：{a}（两个产生式的 First 集相同，无冲突）。</p></li><li><p><strong>Follow(S)</strong>：{b, #}（由推导 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em>，S 后可能有 b 或结束符 #）。</p></li><li><p>条件</p><p>：所有产生式的 First 集不相交，且 First 集与 Follow 集无交集。</p><ul><li>此处两个产生式的 First 集均为 {a}，无冲突，且 First (S) 与 Follow (S) 无交集。 <strong>结论</strong>：是 LL (1) 文法。</li></ul></li></ul><h5 id="_4-lr-分析表构造" tabindex="-1"><a class="header-anchor" href="#_4-lr-分析表构造"><span>4. <strong>LR 分析表构造</strong></span></a></h5><p><strong>题目</strong>：对文法 <em>S</em> → <em>a</em> <em>A</em>, <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，构造 LR (0) 分析表。 <strong>步骤</strong>：</p><ol><li><p><strong>拓广文法</strong>：添加 <em>S</em>′→ <em>S</em>。</p></li><li><p>构造项目集</p><p>：</p><ul><li><em>I</em> 0: <em>S</em>′→⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 1: <em>S</em>′→ <em>S</em> ⋅（接受状态）</li><li><em>I</em> 2: <em>S</em> → <em>a</em> ⋅ <em>A</em>, <em>A</em> →⋅ <em>b</em> <em>S</em> ∣⋅ <em>ϵ</em></li><li><em>I</em> 3: <em>A</em> → <em>b</em> ⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 4: <em>A</em> → <em>ϵ</em> ⋅（归约状态）</li></ul></li><li><p><strong>转移函数</strong>：根据符号跳转（如 <em>I</em> 0 输入 a 转移到 <em>I</em> 2）。</p></li><li><p>分析表</p><p>：</p><ul><li><em>I</em> 0：action [a] = s2（移进）。</li><li><em>I</em> 2：action [b] = s3（移进），action [ε] = r2（归约）。</li><li><em>I</em> 4：goto [A] = I_1（归约后转到 S 的状态）。 <strong>答案</strong>：分析表需完整列出所有状态和符号的 action/goto 项。</li></ul></li></ol><h3 id="有限自动机" tabindex="-1"><a class="header-anchor" href="#有限自动机"><span>有限自动机</span></a></h3><h4 id="核心知识点" tabindex="-1"><a class="header-anchor" href="#核心知识点"><span><strong>核心知识点</strong></span></a></h4><ol><li><strong>定义与五元组</strong> 有限自动机是一个五元组：<code>M = (Q, Σ, δ, q₀, F)</code>，其中： <ul><li><strong>Q</strong>：有限状态集；</li><li><strong>Σ</strong>：输入字母表；</li><li><strong>δ</strong>：转移函数（DFA 为单值映射，NFA 为多值映射或含 ε 转移）；</li><li><strong>q₀</strong>：初始状态；</li><li><strong>F</strong>：终止状态集。</li></ul></li><li><strong>类型</strong><ul><li><strong>确定有限自动机（DFA）</strong>：每个状态对每个输入有唯一转移。</li><li><strong>非确定有限自动机（NFA）</strong>：允许 ε 转移和多值转移，可通过 ε- 闭包简化为 DFA。</li></ul></li><li><strong>语言识别</strong> 输入字符串被接受的条件是：从初始状态出发，按转移规则遍历字符后到达终止状态。</li><li><strong>正则表达式与自动机的转换</strong><ul><li><strong>正则式 →NFA</strong>：通过 Thompson 算法构造。</li><li><strong>NFA→DFA</strong>：通过子集构造法（如 ε- 闭包计算）。</li><li><strong>DFA 最小化</strong>：通过等价类划分（如 Hopcroft 算法）。</li></ul></li></ol><h4 id="二、软考常考点" tabindex="-1"><a class="header-anchor" href="#二、软考常考点"><span><strong>二、软考常考点</strong></span></a></h4><ol><li><p><strong>DFA 与 NFA 的区别</strong></p><ul><li>重点：DFA 转移唯一，NFA 允许多转移和 ε 动作。</li><li>题型示例：判断给定自动机是 DFA 还是 NFA。</li></ul></li><li><p><strong>状态转移图分析</strong></p><ul><li>常考：根据状态转移图，选择自动机接受的字符串（如以特定模式结尾）。</li><li>解题技巧：模拟路径，关注终止状态条件。</li></ul></li><li><p><strong>正则式与自动机的转换</strong></p><ul><li>软考高频考点：将正则式转换为 NFA，或根据自动机图写出对应的正则式。</li></ul></li><li><p><strong>ε- 闭包与子集构造法</strong></p><ul><li>常考步骤：计算 NFA 的 ε- 闭包，将其转换为等价 DFA。</li></ul></li><li><p><strong>DFA 最小化</strong></p><ul><li>步骤：划分状态等价类，合并不可区分状态。</li></ul></li></ol><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h2><h3 id="操作系统定义分类及其功能" tabindex="-1"><a class="header-anchor" href="#操作系统定义分类及其功能"><span>操作系统定义分类及其功能</span></a></h3><h3 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理"><span>进程管理</span></a></h3><h3 id="文件管理" tabindex="-1"><a class="header-anchor" href="#文件管理"><span>文件管理</span></a></h3><h3 id="存储管理" tabindex="-1"><a class="header-anchor" href="#存储管理"><span>存储管理</span></a></h3><h3 id="设备管理" tabindex="-1"><a class="header-anchor" href="#设备管理"><span>设备管理</span></a></h3><h3 id="作业管理" tabindex="-1"><a class="header-anchor" href="#作业管理"><span>作业管理</span></a></h3><h2 id="软件工程基础知识" tabindex="-1"><a class="header-anchor" href="#软件工程基础知识"><span>软件工程基础知识</span></a></h2><h3 id="软件工程概述" tabindex="-1"><a class="header-anchor" href="#软件工程概述"><span>软件工程概述</span></a></h3><p>软件工程基本要素：方法，工具，过程</p><h4 id="软件生存周期" tabindex="-1"><a class="header-anchor" href="#软件生存周期"><span>软件生存周期</span></a></h4><h5 id="可行性分析与项目开发计划" tabindex="-1"><a class="header-anchor" href="#可行性分析与项目开发计划"><span>可行性分析与项目开发计划</span></a></h5><p>这个阶段主要确定软件的开发目标及其可行性   参加人员有用户，项目负责人和系统分析师   该阶段产生的主要文档有可行性分析报告和项目   开发计划，从而确定系统的逻辑模型</p><h5 id="需求分析" tabindex="-1"><a class="header-anchor" href="#需求分析"><span>需求分析</span></a></h5><p>这个阶段确定软件的系统的功能，性能，数据和界面等要求   参加人员有用户，项目负责人和系统分析师。   该阶段产生的主要文档软件需求说明书</p><h5 id="概要设计" tabindex="-1"><a class="header-anchor" href="#概要设计"><span>概要设计</span></a></h5><p>在概要设计阶段，开发人员要把确定的各项功能   需求转换需要的体系结构。概要设计就是设计软件的结构   概要设计概要的参加人员有系统分析师和软件设计师   该阶段主要产生文档有概要设计说明书</p><h5 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计"><span>详细设计</span></a></h5><p>详细设计阶段的主要任务是对每个模块完成的功能进行具体描述，要把功能描述转变为精确的，结构化的过程描述。   详细设计阶段的参加人员有软件设计师和程序员。   该阶段主要产生文档有详细设计文档。</p><h5 id="编码" tabindex="-1"><a class="header-anchor" href="#编码"><span>编码</span></a></h5><p>编码阶段就是把每个模块的控制结构转换成计算机课接受的程序代码。即写成某种特定程序设计语言表示的源程序清单</p><h5 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h5><p>测试是保证软件质量的重要手段，其主要方式是在设计测试用例的基础上检查软件的各个组成部分。   测试阶段的参加人员通常是另一部门的软件设计师或系统分析师。   该阶段主要产生文档有软件测试计划，测试用例和软件测试报告。</p><h3 id="软件工具与开发环境" tabindex="-1"><a class="header-anchor" href="#软件工具与开发环境"><span>软件工具与开发环境</span></a></h3><p>有效的项目管理集中在 4P 上：人员，产品，过程，项目。</p><p>软件项目估算方法：成本估算方法   自顶向下估算：又称类比估算法，确定一个总金额，在向下分摊到每一个功能点。   自底向上估算：又称底层功能点开始估算成本，向上累加。   差别估算法：与以前的项目相比，找出不同点重新估算，相同点则直接估算。   专家估算：聘请专家以其经验对项目整体费用进行估算。 COCOMO 模型：常见的软件规模估算方法。常用的代码行分析方法作为一种度量估计单位，以代码行数估算每个程序员工作量。累加得软件成本。   模型按其详细程度可以可以分为三级：基本 COCOMO 模型，中间 COCOMO 模型，详细 COCOMO 模型。其中基本 COCOMO 模型是一个静态单变量模型，它用一个以估算出来的原代码行数为自变量的经验函数计算软件开发工作量。中间 COCOMO 模型在基础 COCOMO 模型的基础上，再用涉及产品、硬件、人员、项目等方面影响因素调整工作量的估算。详细 COCOMO 模型包括中间 COCOMO 模型所有特性，但更进一步考虑了软件工程的每一个步骤的影响。 COCOMO II 模型：COCOMO 模型的升级，也是以软件规模作为成本的主要因素，考虑多个成本驱动因子。该方法包括三个阶段性模型，即应用组装模型，早期设计阶段模型，体系结构阶段模型 Putnam 估算模型：一种动态多变量模型，假设在软件开发的整个生存周期中工作量有特定的分布。</p><h4 id="进度管理" tabindex="-1"><a class="header-anchor" href="#进度管理"><span>进度管理</span></a></h4><p>基本原则：划分，相互依赖，时间分配，工作量确认，确认责任，明确输出结果，确定里程碑。   Gantt 图：又称横道图，横轴表示时间，纵轴表示活动，以时间顺序表示活动，能 反应活动间的并行关系，但无法反应活动间的依赖关系，因此也难以清晰的确定关键任务和关键路径。  PERT 图：类似前趋图，是有向图，反应活动间的依赖关系，有向边上标注活动的运行时间，但无法反应活动间的并行关系。  PERT 图关键路径：   最早开始时间 ES：取所有前驱活动最早完成时间 EF 的最大值。   最早完成时间 EF：ES+DU（活动本身时间）。   关键路径（项目总工期）：项目中耗时最长的线路。   最晚完成时间 LF：取后续活动最晚开始时间的最小值。   最晚开始时间 LS：LF-DU   松弛时间：LS-ES 或者 LF-EF （即活动最多可以晚几天开始） 例： 关键路径为图中最长的路径即 D-F-H 权值为 48 所以第一空选 C FG 的松弛时间为 关键路径 - 包含 FG 的最长路径 （DFH）-（DFG）=48-28=20 所以第二空为 B</p><h4 id="软件项目的组织" tabindex="-1"><a class="header-anchor" href="#软件项目的组织"><span>软件项目的组织</span></a></h4><p>程序设计小组的组织方式：   主程序员制小组：主程序员全权负责，后援工程师有必要时能替代主程序员，适合大规模项目。   民主制小组：也即无主程序员小组，成员之间地位平等，任何决策都是全员参与投票，适合于项目规模小，开发人员少，采用新技术和确定性较小的项目。   层次式小组：两个层次，一名组长领导若干个高级程序员，每个高级程序员领导若干个程序员。</p><h3 id="软件开发项目管理" tabindex="-1"><a class="header-anchor" href="#软件开发项目管理"><span>软件开发项目管理</span></a></h3><h3 id="软件质量管理" tabindex="-1"><a class="header-anchor" href="#软件质量管理"><span>软件质量管理</span></a></h3><p>通常将质量理解为用户满意程度，为了使用户满意，有两个必要条件：设计的规格说明书符合用户标准，称为设计质量。程序按照设计规模书所规定的情况正确执行，称为程序质量。   设计质量评审，程序质量评审。</p><table><thead><tr><th>质量特性</th><th>质量子特性</th></tr></thead><tbody><tr><td>功能性</td><td>适合性 准确性 互用性 依从性 安全性</td></tr><tr><td>可靠性</td><td>成熟性 容错性 易恢复性</td></tr><tr><td>易使用性</td><td>易理解性 易学性 易操作性</td></tr><tr><td>效率</td><td>时间特性 资源特性</td></tr><tr><td>可维护性</td><td>易分析性 易改变性 稳定性 易测试性</td></tr><tr><td>可移植性</td><td>适应性 易安装性 一致性 易替换性</td></tr></tbody></table><p>易分析性：与为诊断缺陷或失效原因，或为判定待修改部分所需那里有关的软件属性。   易改变性：与进行修改、排错、或适应环境变换所需努力有关的软件属性。   稳定性：与修改造成未预料效果风险有关的软件属性。   易测试性：为确认经修改软件所需努力有关的软件属性。</p><h4 id="软件容错技术" tabindex="-1"><a class="header-anchor" href="#软件容错技术"><span>软件容错技术</span></a></h4><p>软件容错技术：   容错就是软件遇到错误的处理能力，实现容错的手段主要是冗余，包括下面四种冗余技术：  <strong>结构冗余</strong>：分为静态（通过表决和比较，少数服从多数）、动态（多重模块待机备份，故障是切换备份机）、混合冗余（二者综合）。  <strong>信息冗余</strong>：为检错和纠错在数据中加上一段额外的信息，例如检验码原理。  <strong>时间冗余</strong>：遇到错误是重复执行，例如回滚，重复执行还有错，则转入错误处理逻辑。  <strong>冗余附加技术</strong>：冗余附加技术是指为实现数据结构，信息和时间冗余技术所需的资源和技术，包括程序，指令，数据，存放和调动它们的空间和通道等</p><h4 id="风险管理" tabindex="-1"><a class="header-anchor" href="#风险管理"><span>风险管理</span></a></h4><p>风险管理两个特性：不确定性（可能发生也可能不发生）、损失（发生会产生恶性后果）。  <strong>项目风险</strong>威胁到项目计划，如果项目风险发生，有可能拖延项目的进度和增加项目的成本，指预算。进度、人员、资源。利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素。  <strong>技术风险</strong>威胁到要开发软件的质量和交付时间，如果技术风险发生，开发工作就变得很困难或者不可能，只设计、实现、接口、验证和维护等方面的潜在问题。此外，规格说明的歧义性，技术的不确定性，技术陈旧以及“前沿”技术也是技术风险因数。   商业风险威胁到要开发软件的生存能力，包括下面五种：</p><ol><li>市场风险：开发了一个没有人真正需要的优良产品或系统。</li><li>策略风险：开发的产品不在符合公司的整体商业策略。</li><li>销售风险：开发了一个销售部门不知道该如何销售的产品。</li><li>管理风险：由于重点的转移或人员变动而失去了高级管理层的支持。</li><li>预算风险：没有得到预算或人员的保证。</li></ol><p>风险管理过程如下：</p><ol><li>风险识别：识别出项目中已知和可预测的风险，确定风险的来源，产生的条件，描述风险的特征以及哪些项目可以产生风险。形成一个风险列表。</li><li>风险预测：又称为风险估计，从两个方面预测风险，即风险可能发生的概率和风险产生的后果，因此有风险曝光度=风险发生的可能性*风险发生带来的损失。</li><li>风险评估：定义风险参照水准，将识别出来的风险评估分类。</li><li>风险控制：辅助项目组建立处理风险的策略，包括风险避免，风险监控，RMMM 计划（风险缓解，监控和管理计划）</li></ol><h4 id="软件度量" tabindex="-1"><a class="header-anchor" href="#软件度量"><span>软件度量</span></a></h4><p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的属性，如可靠度等，只能间接测量。  McCabe 算法：又称为环路复杂度，假设有向图中有向边数为 M，节点数为 N，则此有向图的环路复杂度为 M-N+2。</p><h3 id="软件过程管理" tabindex="-1"><a class="header-anchor" href="#软件过程管理"><span>软件过程管理</span></a></h3><h4 id="能力成熟度模型-cmm" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型-cmm"><span>能力成熟度模型 CMM</span></a></h4><p>能力成熟度模型 CMM：对软件组织化阶段的描述，随着软件组织地定义、实施，测量、控制和改进其软件过程，软件组织地能力经过这些阶段逐步提高。</p><ol><li>初始级（Initial）：软件过程的特点是杂乱无章，又是甚至很混乱，几乎没有明确定义的步骤，项目的完成全依赖个人的努力和英雄式核心人物的作用。</li><li>可重复级（Repeatable）：建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</li><li>已定义级（Defined）：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件来发组织地标准软件过程，所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li>已管理级（Managed）：制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织地成员所理解和控制。</li><li>优化级（Optimized）：加强了定量分析，通过来之过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</li></ol><h4 id="能力成熟度模型-cmmi" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型-cmmi"><span>能力成熟度模型 CMMI</span></a></h4><p>能力成熟度模型 CMMI：将已有的几个 CMM 模型结合在一起，使之构造成为“集成模型”。支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需求，能提高过程的质量和工作效率。   阶段式模型：类似于 CMM，它关注组织地成熟度，五个成熟度模型如下：</p><ol><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程为以度量和控制。</li><li>优化的：集中于过程改进。</li></ol><h4 id="维护" tabindex="-1"><a class="header-anchor" href="#维护"><span>维护</span></a></h4><p>软件维护是软件设计生存周期中时间最长的阶段。已交付的软件投入正式使用后，便进入软件维护阶段，它可以持续几年甚至十几年。</p><h4 id="软件过程模型" tabindex="-1"><a class="header-anchor" href="#软件过程模型"><span>软件过程模型</span></a></h4><h5 id="统一过程模型-up" tabindex="-1"><a class="header-anchor" href="#统一过程模型-up"><span>统一过程模型（UP）</span></a></h5><p>统一过程模型：是一种“用例和风险驱动，以架构为中心，迭代并且增量”的开发过程。 开发的四个阶段</p><ol><li>起始阶段：项目的初始活动，如确认需求和风险评估等。</li><li>精化阶段：需求分析和架构设计等。</li><li>构建阶段：系统的构建，产生实现模型等。</li><li>移交阶段：软件提交方面的工作，产生软件增量，进行 β 测试，交付系统等。 UP 的每一次迭代都是一次完整的软件开发过程，包括整个软件开发生命周期，有五个核心工作流（需求-分析-设计-实现-测试）。</li></ol><h5 id="瀑布模型" tabindex="-1"><a class="header-anchor" href="#瀑布模型"><span>瀑布模型</span></a></h5><p>结构化方法中的模型，是结构化的开发，开发流程如瀑布一样，一步一步走下去，直到项目完成开发   只适用于需求明确或者二次开发（需求稳定）的项目</p><h5 id="v-模型" tabindex="-1"><a class="header-anchor" href="#v-模型"><span>V 模型</span></a></h5><p>是瀑布模型的一个变种。特点是增加了多轮测试，并且这些测试贯穿于软件开发的各个阶段</p><h5 id="原型" tabindex="-1"><a class="header-anchor" href="#原型"><span>原型</span></a></h5><p>快速原型开发，与瀑布模型相反，原型针对需求不明确的情况</p><h5 id="螺旋模型" tabindex="-1"><a class="header-anchor" href="#螺旋模型"><span>螺旋模型</span></a></h5><p>是多种模型的混合，针对需求不明确的项目，与原型相似，但增加了风险分析（制定计划—风险分析—实施工程—用户评估）</p><h5 id="增量模型" tabindex="-1"><a class="header-anchor" href="#增量模型"><span>增量模型</span></a></h5><p>首先开发核心功能模块，而后与用户确认，之后再开发次核心功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发，优先级高的服务最先交付。 增量模型的每一次增量版本都可作为独立操作的作品</p><h5 id="喷泉模型" tabindex="-1"><a class="header-anchor" href="#喷泉模型"><span>喷泉模型</span></a></h5><p>是一种以用户需求为动力，以对象作为驱动的模型。适用于面向对象的开发方法是开发过程具有迭代性和无间隙性</p><h5 id="基于构建的开发模型" tabindex="-1"><a class="header-anchor" href="#基于构建的开发模型"><span>基于构建的开发模型</span></a></h5><p>利于预先包装的构件来构造应用系统，构件是可以组织内部开发的构件，也可以是商品化成品软件构件。   提点是增强了复用性，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高复用性，节省时间和成本。</p><h5 id="敏捷开发" tabindex="-1"><a class="header-anchor" href="#敏捷开发"><span>敏捷开发</span></a></h5><p>敏捷开发的总体目标是通过“尽可能早，持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷开发使用户能够在开发周期的后期增加或者改变需求。</p><h5 id="自适应开发-asd" tabindex="-1"><a class="header-anchor" href="#自适应开发-asd"><span>自适应开发（ASD）</span></a></h5><p>强调开发方法的适应性</p><h5 id="水晶方法-crystal" tabindex="-1"><a class="header-anchor" href="#水晶方法-crystal"><span>水晶方法（Crystal）</span></a></h5><p>水晶法认为每一个不同项目都需要一套不同的策略，约定和方法论。</p><p>水晶法认为每一个不同项目都需要一套不同的策略，约定和方法论</p><h5 id="特性驱动开发" tabindex="-1"><a class="header-anchor" href="#特性驱动开发"><span>特性驱动开发</span></a></h5><p>是一套针对中小型软件开发项目的开发模式，是一个模型驱动的快速迭代开发过程，它强调的是简化，使用，易被开发团队接受，适用于需求经常变动的项目。</p><p>是一套针对中小型软件开发项目的开发模式，是一个模型驱动的快速迭代开发过程，它强调的是简化，使用，易被开发团队接受，适用于需求经常变动的项目</p><p>并列争求法（Scrum）</p><p>并列争求法是一种迭代的增量化过程，其中，把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级来实现产品。</p><h5 id="极限编程-xp" tabindex="-1"><a class="header-anchor" href="#极限编程-xp"><span>极限编程（XP）</span></a></h5><p>XP 是一种轻量级（敏捷），高效，低风险，柔性，可预测，科学的软件开发方式。   四大价值观：沟通，简单性，反馈和勇气。   五个原则：快速反馈，简单性假设，逐步修改，提倡更改和优质工作。  12 个最佳实践：计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结队编程，集体代码所有制，持续集成，每周工作 40 小时，现场客户和编码标准</p><h5 id="结对编程" tabindex="-1"><a class="header-anchor" href="#结对编程"><span>结对编程</span></a></h5><p>一个程序员开发，另一个审查代码，能够有效的提高代码的质量。</p><h2 id="系统开发与运行" tabindex="-1"><a class="header-anchor" href="#系统开发与运行"><span>系统开发与运行</span></a></h2><h3 id="系统分析概述" tabindex="-1"><a class="header-anchor" href="#系统分析概述"><span>系统分析概述</span></a></h3><p>系统分析是一种问题的求解技术，它将一个系统分解成各个组成部分，目的是研究各个部分如何工作，交互，以实现其系统目标。   目的和任务：系统分析的主要任务是对现行系统进一步详细调查，将调查中所得到的文档资料集中，对组织内部整体管理状况和信息处理过程进行分析，为系统开发提供所需资料，并提交系统方案说明书。   系统分析的主要步骤</p><ol><li>认识、理解当前的现实环境，获得当前系统的“物理模型”。</li><li>从当前系统的“物理模型”抽象出当前系统的“逻辑模型”。</li><li>对当前系统的“逻辑模型”进行分析和优化，建立目标系统的“逻辑模型”。</li><li>对目标系统的逻辑模型具体化（物理化），建立目标系统的物理模型。</li></ol><p>系统开发的目的是将现有系统的物理模型转换为目标系统的物理模型。</p><h4 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h4><p>系统设计基本原理：   抽象（重点说明本质问题，忽略非本质方面）   模块化（可组合、分解和更换的单元）   信息隐蔽（将每个程序的成分隐蔽或封装在一个单一的设计模块中）   模块独立（每个模块完成一个相对独立的特定子功能，且与其他模块之间的联系简单）</p><p>模块的设计要求独立性高，就必须高内聚，低耦合，内聚是指一个模块内部功能之间的相关性，耦合是指多个模块之间的联系。</p><h4 id="内聚" tabindex="-1"><a class="header-anchor" href="#内聚"><span>内聚</span></a></h4><p>内聚程度从低到高如下表所示：</p><table><thead><tr><th>内聚分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>偶然内聚</td><td>一个模块内各处理元素之间没有任何联系</td><td>无直接关系</td></tr><tr><td>逻辑内聚</td><td>模块内执行若干个逻辑上相似的功能，通过参数确定改模块完成哪一个功能</td><td>逻辑相似，参数决定</td></tr><tr><td>时间内聚</td><td>把需要同时执行的动作组合在一起形成模块</td><td>同时执行</td></tr><tr><td>过程内聚</td><td>一个模块完成多个任务，这些任务必须按指定的过程执行</td><td>指定的过程顺序</td></tr><tr><td>通信内聚</td><td>模块内所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据</td><td>相同的数据结构、形同的输入输出</td></tr><tr><td>顺序内聚</td><td>一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一个功能元素的输出就是后一个功能元素的输入</td><td>顺序执行、输入为输出</td></tr><tr><td>功能内聚</td><td>最强的内聚，模块内所有元素共同作用完成一个功能，缺一不可</td><td>共同作用，缺一不可</td></tr></tbody></table><h4 id="耦合" tabindex="-1"><a class="header-anchor" href="#耦合"><span>耦合</span></a></h4><p>耦合程度从低到高如下表所示：</p><table><thead><tr><th>耦合分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>无直接耦合</td><td>两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，不传递任何信息</td><td>无直接关系</td></tr><tr><td>数据耦合</td><td>两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递</td><td>传递数据值调用</td></tr><tr><td>标记耦合</td><td>两个模块之间传递的是数据结构</td><td>传递数据结构</td></tr><tr><td>控制耦合</td><td>一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值，有选择的执行模块内的某一功能</td><td>控制变量，选择执行某一功能</td></tr><tr><td>外部耦合</td><td>模块间通过软件之外的环境联合（如 I/O 将模块耦合到特定的设备，格式，通信协议）时</td><td>软件外部环境</td></tr><tr><td>公共耦合</td><td>通过一个公共数据环境相互作用的那些模块间的耦合</td><td>公共数据结构</td></tr><tr><td>内容耦合</td><td>当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个内部模块时</td><td>模块内部关联</td></tr></tbody></table><h4 id="系统设计-1" tabindex="-1"><a class="header-anchor" href="#系统设计-1"><span>系统设计</span></a></h4><p>系统设计的主要目的是系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理的使用各种资源，得出新系统的详细设计方案。 步骤：概要设计和详细设计   概要设计基本任务：设计软件系统总体结构，数据结构及数据库设计，编写概要设计文档，评审。   详细设计基本任务：模块内详细算法设计、模块内数据结构设计，数据库物理设计、其他设计（代码，输入输出格式，用户界面），编写详细设计文档，评审。</p><h4 id="软件需求" tabindex="-1"><a class="header-anchor" href="#软件需求"><span>软件需求</span></a></h4><p>按需求内容分类：   业务需求:由客户提出的宏观的一个功能需求。   用户需求：设计员去调查需求中涉及的每个用户的具体需求。   系统需求：经过整合，形成最终的系统需求，包括功能，性能，设计约束三个方面的需求。</p><p>从客户角度分类：   基本需求：需求明确规定的功能。   期望需求：除了基本需求外，客户认为理所应当包含在内的其他功能。   兴奋需求：客户未要求其他功能需求，会浪费项目开发时间和成本。</p><p>软件需求分类：   功能需求：软件必须完成的基本动作。   性能需求：说明软件或人与软件交互的静态或动态数值需求。如系统响应速度，处理速度等。   设计约束：受其他硬件标准限制等方面影响。   属性：可用性、安全性、可维护性，可移植性。   外部接口需求：用户接口，硬件接口，软件接口，通信接口。</p><h3 id="测试基础知识" tabindex="-1"><a class="header-anchor" href="#测试基础知识"><span>测试基础知识</span></a></h3><p>系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。 测试原则：   应尽早并不断的进行测试。   测试工作应该避免由开发软件的人或小组承担。   在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期的输出结果。   即包含有效、合理的测试用例，也包含不合理、失效的用例。   检验程序是否做了该做的事，且是否做了不该做的事。   严格按照测试计划执行。   妥善保存测试用例和测试计划。   测试用例可以重复使用或追加测试。</p><h4 id="测试阶段" tabindex="-1"><a class="header-anchor" href="#测试阶段"><span>测试阶段</span></a></h4><p>单元测试：对单个模块进行测试，由程序员自己测试模块内部的接口、信息、功能，测试依据是软件详细说明书。在单元测试中，驱动模块（上层）用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块，桩模块（底层）用来模拟被测模块所调用的子模块。   集成测试：将模块组合起来进行测试，分为一次性组装（简单，节约时间，发现错误少，只适合小项目）和增量式组装（能够发现更多错误，耗时长，又可分为：自顶向下，自底向上，混合式）。   确认测试：对已完成的软件进行功能上的测试，分为内部确认测试（无用户情况）、Alpha 测试（用户在开发环境下测试），Beat 测试（用户在实际使用时进行的测试）、验收测试（用户根据 SRS 对项目进行验收）。   系统测试：对软甲进行性能测试，主要分为三个方面，即负载测试（在极限情况下，系统各项性能指标）、强度测试（系统资源特别低的情况下），容量测试（并发测试，系统可以处理的同时在线的最大用户数）。其他还有可靠性等性能测试，系统测试一般使用黑盒测试方法。   回归测试：软件修改错误或者变更后，进行回归测试以验证之前正确的代码是否引入了错误。   动态测试：程序运行时测试，分为：    黑盒测试法：功能性测试，不了解软件代码结构，根据功能设计用例，测试软件功能。    白盒测试法：结构性测试，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。    灰盒测试法：即既有黑盒测试，也有白盒测试。</p><p>静态测试：程序静止时测试，即対代码进行人工审查，分为：    桌前检查：程序员检查自己编写的程序，在程序编译后，单元测试前。    代码审查：由若干个程序员和测试人员组成评审小组，通过召开程序评审会来进行审查。    代码走查：也是采用开会来对代码进行审查，但并非简单的审查代码，而是由测试人员提供用例，让程序员扮演计算机的角色，手动运行测试用例，检查代码逻辑。</p><h4 id="测试策略" tabindex="-1"><a class="header-anchor" href="#测试策略"><span>测试策略</span></a></h4><p>自底向上：从最底层模块开始测试，需要编写驱动程序，而后开始逐一合并模块，最终完成整个系统的测试。优点是较早的验证了底层模块。   自顶向下：先测试整个系统，需要编写桩程序，而后逐步向下直至最后测试最低层模块。优点是较早的验证了系统的主要控制和判断点。   三明治：既有自底向上也有自顶向下的测试方法，二者都包括。兼有二者的优点，缺点是测试工作量大。</p><h4 id="测试用例设计" tabindex="-1"><a class="header-anchor" href="#测试用例设计"><span>测试用例设计</span></a></h4><p>黑盒测试用例：将程序看做一个黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类：   等价类划分：把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。等价类测试用例的设计原则：设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类被覆盖为止。   边界值划分：将每类的边界值作为测试用例，边界值一般为范围的两断值以及在此范围之外的与此范围间隔最小的两个值，如年龄范围 0-150，边界值为 0,150，1,151 四个。</p><p>白盒测试用例：知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面六种：</p><p>1.语句覆盖：逻辑代码中所有的语句都要执行一遍，覆盖层级最低，因为执行了所有语句，不代表执行了所有条件判断。</p><ol start="2"><li><p>判定覆盖：逻辑代码中所有判断语句的条件的真假分支都要覆盖一次。</p></li><li><p>条件覆盖：对于代码中的一个条件，可能是组合的，如 a&gt;0&amp;&amp;b&lt;0，判断覆盖只针对此组合条件的真假分支做两个测试用例，而条件覆盖是对每个独立的条件都要做真假分支的测试用例，共可有 4 个测试用例，层级更高，注意区别，条件覆盖，针对每个条件都要真假覆盖，判定覆盖，只针对一个条件判断语句。</p></li><li><p>判定/条件覆盖：使判定中每个条件的所有可能取值（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即两种覆盖的综合。</p></li><li><p>条件组合覆盖：每个判定条件中条件的各个可能值的组合都至少出现一次。</p></li><li><p>路径覆盖：逻辑代码中所有可行路径都覆盖了，覆盖层级最高。</p></li></ol><h2 id="面向对象技术" tabindex="-1"><a class="header-anchor" href="#面向对象技术"><span>面向对象技术</span></a></h2><h3 id="面向对象基本概念" tabindex="-1"><a class="header-anchor" href="#面向对象基本概念"><span>面向对象基本概念</span></a></h3><p>面向对象分析：是为了确定问题域，理解问题。 包含五个活动：<code>认定对象</code>(按自然存在的实体确定对象)、<code>组织对象</code>(分析对象关系,抽象成类)、<code>对象间的互相作用</code>(描述各对象在应用系统中的关系)、<code>确定对象的操作</code>(操作,如创建增加删除等)、<code>定义对象的内部信息(属性)</code></p><p>面向对象设计：是设计分析模型和实现相应源代码，在目标代码环境中这种源代码可被执行。设计问题域的解决方案。 面向对象程序设计：用面向对象程序设计语言实现设计方案。详见案例分析。 面向对象测试：与普通测试步骤并无不同。可分为四个层次：</p><ol><li><code>算法层</code>(测试类中定义的每个方法，类似单元测试)</li><li><code>类层</code>(测试同一个类中所有方法与属性的互相作用，<code>特有的模块测试</code>)</li><li><code>模板层</code>(测试一组协同工作的类之间的互相作用，类似集成测试)</li><li><code>系统层</code>(类似系统测试)</li></ol><h3 id="uml-图" tabindex="-1"><a class="header-anchor" href="#uml-图"><span>UML 图</span></a></h3><p>UML 是统一建模语言，和程序设计语言并无关系。 UML 三个要素：UML 的基本<strong>构造快</strong>、支配这些构造块如何放置在一起的<strong>规则</strong>和运用与整个语言的一些<strong>公共机制</strong>。 UML 的基本构造快包括：<strong>事务</strong>（对模型中最具有代表性的成分的抽象）、<strong>关系</strong>（把事务结合在一起）、<strong>图</strong>（聚集了相关的事务）。 UML 中有四种事务：<strong>结构事务</strong>、<strong>行为事务</strong>、<strong>分组事务</strong>、<strong>注释事务</strong>。</p><p>结构事务：模型的静态部分，如<strong>类、接口、用例、构件等</strong>如下图示例： <img src="`+p+'" alt="img"></p><h4 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h4><p><img src="'+c+'" alt="img"></p><hr><h4 id="关系" tabindex="-1"><a class="header-anchor" href="#关系"><span>关系</span></a></h4><ol><li>依赖：一个事务的语义依赖于另一个事务的语义变化而变化</li><li>关联：是一种结构关系，描述一组链，链是对象之间的连接。分为<strong>组合（强关联）<strong>和</strong>聚合（弱关联）</strong></li><li>泛化：一般/特殊的关系，子类和父类之间的关系。</li><li>实现：一个类元指定了另一个类元保证执行的契约。 <img src="'+f+'" alt="img"></li></ol><hr><h4 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h4><p><code>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</code><img src="'+x+'" alt="img"></p><hr><h4 id="对象图" tabindex="-1"><a class="header-anchor" href="#对象图"><span>对象图</span></a></h4><p><code>对象图：静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</code><img src="'+y+'" alt="img"></p><hr><h4 id="用例图" tabindex="-1"><a class="header-anchor" href="#用例图"><span>用例图</span></a></h4><p><code>用例图：静态图，展现了一组用例、参与者以及他们之间的关系。</code> 用例图中的参与者是人、硬件或其它系统可以扮演的角色；用例是参与者完成的一系列操作。 用力之间的关系包括：</p><ol><li>包含(include)</li><li>扩展(extend)</li><li>泛化 <img src="'+m+'" alt="img"></li></ol><hr><h4 id="序列图" tabindex="-1"><a class="header-anchor" href="#序列图"><span>序列图</span></a></h4><p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。 有<strong>同步消息</strong>（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示）、 <strong>异步消息</strong>（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示）、 <strong>返回消息</strong>（由从右到左的虚线箭头表示）三种。 <img src="'+u+'" alt="img"></p><hr><h4 id="通信图" tabindex="-1"><a class="header-anchor" href="#通信图"><span>通信图</span></a></h4><p>通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过 <strong>不强调时间顺序，只强调事件之间的通信</strong>，而且也没有固定的画法规则，<strong>和顺序图统称为交互图</strong>。 <img src="'+b+'" alt="img"></p><hr><h4 id="状态图" tabindex="-1"><a class="header-anchor" href="#状态图"><span>状态图</span></a></h4><p>状态图：<strong>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态</strong>。 转换可以<strong>通过事件触发器出发</strong>，事件触发后相应的监护条件会进行检查。</p><p>状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件， 实心圆点为起点和终点。下图描述的就是一个图书的状态变化： <img src="'+k+'" alt="img"></p><hr><h4 id="活动图" tabindex="-1"><a class="header-anchor" href="#活动图"><span>活动图</span></a></h4><p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另二个活动的流程。 <code>活动的分叉和汇合线是一条水平粗线。</code> 每个分岔的分支数代表了可同时运行的线程数。 活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。 <img src="'+C+'" alt="img"></p><h4 id="uml-图总结" tabindex="-1"><a class="header-anchor" href="#uml-图总结"><span>UML 图总结</span></a></h4><table><thead><tr><th>图名称</th><th>用途</th><th>类型</th></tr></thead><tbody><tr><td><strong>类图</strong></td><td>静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>对象图</strong></td><td>静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</td><td>静态图</td></tr><tr><td><strong>用例图</strong></td><td>静态图，展现了一组用例、参与者以及他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>序列图</strong></td><td>即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</td><td>动态图</td></tr><tr><td><strong>通信图</strong></td><td>不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图</td><td>动态图</td></tr><tr><td><strong>状态图</strong></td><td>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态。</td><td>动态图</td></tr><tr><td><strong>活动图</strong></td><td>展现了在系统内从一个活动到另二个活动的流程。</td><td>动态图</td></tr></tbody></table><h3 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h3><h4 id="创建型设计模式" tabindex="-1"><a class="header-anchor" href="#创建型设计模式"><span>创建型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：单抽元件厂</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Singleton 单例模式</strong></td><td>确保一个类仅有一个实例，并提供全局访问点</td><td>唯一实例</td></tr><tr><td><strong>Abstract Factory 抽象工厂模式</strong></td><td>提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类</td><td>抽象接口</td></tr><tr><td><strong>Prototype 原型模式</strong></td><td>通过复制现有原型对象来创建新对象，避免重复初始化操作</td><td>原型实例化，拷贝</td></tr><tr><td><strong>Builder 构建器模式</strong></td><td>将复杂对象的构造与其表示分离，使同样的构建过程可以创建不同对象</td><td>类和构造分离</td></tr><tr><td><strong>Factory Method 工厂方法模式</strong></td><td>定义一个创建对象的接口，但让子类决定实例化哪个类</td><td>子类决定实例化</td></tr></tbody></table><h4 id="结构型设计模式" tabindex="-1"><a class="header-anchor" href="#结构型设计模式"><span>结构型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：外侨组员带配饰</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Facade 外观模式</strong></td><td>为复杂子系统提供一个统一的高层接口，简化调用过程</td><td>对外统一接口</td></tr><tr><td><strong>Bridge 桥接模式</strong></td><td>将抽象部分与其实现部分分离，使它们可以独立变化</td><td>抽象和实现分离</td></tr><tr><td><strong>Composite 组合模式</strong></td><td>将对象组合成树形结构以表示”整体-部分”的层次关系</td><td>整体-部分，树形结构</td></tr><tr><td><strong>Flyweight 享元模式</strong></td><td>通过共享技术来高效地支持大量细粒度对象的重用</td><td>细粒度，共享</td></tr><tr><td><strong>Proxy 代理模式</strong></td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>代理控制</td></tr><tr><td><strong>Adapter 适配器模式</strong></td><td>将一个类的接口转换为另一个接口，使原本不兼容的类可以协同工作</td><td>转换，兼容接口</td></tr><tr><td><strong>Decorator 装饰模式</strong></td><td>动态地给对象添加额外的职责，相比继承更加灵活</td><td>附加职责</td></tr></tbody></table><h4 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式"><span>行为型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：观摩对(迭)策，责令解放，戒忘台</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Observer 观察者模式</strong></td><td>定义对象间的一对多依赖关系，当一个对象状态改变时自动通知所有依赖对象</td><td>通知、自动更新</td></tr><tr><td><strong>Template Method 模板方法模式</strong></td><td>定义算法框架，允许子类在不改变结构的情况下重写特定步骤</td><td>子类可重写算法步骤</td></tr><tr><td><strong>Iterator 迭代器模式</strong></td><td>提供一种方法顺序访问聚合对象的元素，而不暴露其内部表示</td><td>顺序访问，不暴露内部</td></tr><tr><td><strong>Strategy 策略模式</strong></td><td>定义一系列算法，将每个算法封装在独立的类中，并使它们可以相互替换</td><td>算法替换</td></tr><tr><td><strong>Chain of Responsibility 责任链模式</strong></td><td>将请求沿着处理链传递，直到有对象处理它</td><td>传递请求、职责链接</td></tr><tr><td><strong>Command 命令模式</strong></td><td>将请求封装为对象，支持可撤销操作和请求队列</td><td>日志记录、可撤销</td></tr><tr><td><strong>Interpreter 解释器模式</strong></td><td>定义语言的文法表示，并提供解释器来处理该语法</td><td>解释器，虚拟机</td></tr><tr><td><strong>Visitor 访问者模式</strong></td><td>将作用于对象结构的操作与对象本身分离，便于新增操作</td><td>数据和操作分离</td></tr><tr><td><strong>Mediator 中介者模式</strong></td><td>定义一个中介对象来封装一组对象间的交互，降低耦合度</td><td>不直接引用</td></tr><tr><td><strong>Memento 备忘录模式</strong></td><td>在不破坏封装性的前提下，捕获并保存对象的内部状态以便恢复</td><td>保存，恢复</td></tr><tr><td><strong>State 状态模式</strong></td><td>允许对象在其内部状态改变时改变它的行为</td><td>状态变成类</td></tr></tbody></table><h3 id="面向对象设计原则" tabindex="-1"><a class="header-anchor" href="#面向对象设计原则"><span>面向对象设计原则</span></a></h3><ol><li>单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭</li><li>里氏替换原则：所有引用基类的地方必须能透明的使用其子类的对象</li><li>依赖倒转原则：高层模块不应该依赖低层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>接口隔离原则：客户端不应该依赖那些它不需要的接口</li><li>合成复用原则：优先使用对象组合，而不是继承来达到复用的目的</li><li>迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</li></ol><h2 id="网络与信息安全和病毒防护" tabindex="-1"><a class="header-anchor" href="#网络与信息安全和病毒防护"><span>网络与信息安全和病毒防护</span></a></h2><h3 id="iso-osi-网络体系结构" tabindex="-1"><a class="header-anchor" href="#iso-osi-网络体系结构"><span>ISO/OSI 网络体系结构</span></a></h3><table><thead><tr><th><strong>层次</strong></th><th><strong>功能描述</strong></th><th><strong>典型协议 / 技术</strong></th><th><strong>数据单元</strong></th><th><strong>对应设备</strong></th></tr></thead><tbody><tr><td><strong>7. 应用层</strong></td><td>直接为用户应用程序提供服务（如文件传输、电子邮件、远程登录等）。</td><td>HTTP、FTP、SMTP、POP3、DNS、Telnet、SSH</td><td>消息（Message）</td><td>主机（终端设备）</td></tr><tr><td><strong>6. 表示层</strong></td><td>负责数据格式转换（如加密、压缩、解码），确保不同系统间数据格式兼容。</td><td>SSL/TLS、JPEG、MPEG、ASCII、UTF-8</td><td>数据（Data）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>5. 会话层</strong></td><td>管理主机间的通信会话（建立、维护、终止），如会话同步和错误恢复。</td><td>NFS、RPC、ZIP（会话管理）</td><td>会话数据单元</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>4. 传输层</strong></td><td>实现端到端的可靠（TCP）或不可靠（UDP）数据传输，处理流量控制和错误恢复。</td><td>TCP、UDP、SPX（Novell）</td><td>段（Segment）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>3. 网络层</strong></td><td>负责网络间的逻辑寻址和路由选择，将数据从一个网络传输到另一个网络。</td><td>IP、ICMP、IGMP、OSPF、BGP</td><td>数据包（Packet）</td><td>路由器（Router）</td></tr><tr><td><strong>2. 数据链路层</strong></td><td>将物理层的比特流封装为帧，实现相邻节点间的可靠传输（错误检测、流量控制）。</td><td>Ethernet、PPP、HDLC、VLAN、802.11（Wi-Fi）</td><td>帧（Frame）</td><td>交换机（Switch）、网桥（Bridge）、网卡（NIC）</td></tr><tr><td><strong>1. 物理层</strong></td><td>定义物理设备的电气、机械特性，传输原始比特流（0/1 信号）。</td><td>IEEE 802.3（以太网）、RJ-45、光纤、同轴电缆</td><td>比特（Bit）</td><td>集线器（Hub）、中继器（Repeater）、网卡（NIC）</td></tr></tbody></table><h3 id="网络协议" tabindex="-1"><a class="header-anchor" href="#网络协议"><span>网络协议</span></a></h3><h4 id="局域网协议" tabindex="-1"><a class="header-anchor" href="#局域网协议"><span>局域网协议</span></a></h4><p>IEEE802.3 :标准以太网 速度为 10Mbps，传输介质是同轴电缆。 IEEE802.3u: 快速以太网 速度为 100Mbps 传输介质是双绞线。 IEEE802.3z:千兆以太网 速度为 1000Mnps 传输介质是光纤或双绞线。</p><h4 id="网络层协议" tabindex="-1"><a class="header-anchor" href="#网络层协议"><span>网络层协议</span></a></h4><p>IP 协议：最重要最核心的协议（无连接，不可靠） ICMP 协议：因特网控制信息协议，检测网络通信顺畅 ARP 协议和 RARP 协议：地址解析协议和反地址解析协议 ARP   IP 地址 -&gt; 物理地址 RARP   物理地址 -&gt;IP 地址</p><h4 id="传输层协议" tabindex="-1"><a class="header-anchor" href="#传输层协议"><span>传输层协议</span></a></h4><p>UDP 协议：不可靠链接， 一般用于视频，音频传输 TCP 协议：可靠连接 （三次握手协议）</p><h4 id="应用层协议" tabindex="-1"><a class="header-anchor" href="#应用层协议"><span>应用层协议</span></a></h4><p>基于 TCP 的 FTP，HTTP 都是可靠传输，基于 UDP 的 DHCP，DNS 都是不可靠传输。 FTP：文件传输协议（可靠）控制端口为 21 传输端口为 20 HTTP（默认端口 80）：超文本传输协议 （可靠）使用 SSL 加密后为 HTTPS（默认端口 443） SMTP（发送）和 POP3（收取）：邮件传输协议（可靠） 邮件报文采用 ASCLL 格式表示 Telent：远程连接协议（可靠） TFTP：小文件传输协议（不可靠） SNMP：简单网络管理协议（不可靠） DHCP：动态分配 IP 地址协议（不可靠）客户机/服务器模型 默认租期为 8 天 DNS：域名解析协议（不可靠）将域名解析成 IP 地址</p><h3 id="网络安全" tabindex="-1"><a class="header-anchor" href="#网络安全"><span>网络安全</span></a></h3><p>网络安全的五大要素:保密性，完整性，可用性，可控性，不可抵赖性。</p><h4 id="防火墙" tabindex="-1"><a class="header-anchor" href="#防火墙"><span>防火墙</span></a></h4><p>防火墙是内部网络和外部因特网之间增加的一道安全防护措施，它认为内部网络是安全的，外部网络是不安全的。分为网络级防火墙和应用级防火墙，两级之间的安全手段如下所示：   网络级防火墙（包过滤防火墙）层次低，但是效率高，因为其使用包过滤和状态监测手段，一般只检验网络包外在（起始地址，状态），属性是否异常，若异常，则过滤掉，不与内网通信，因此对用户和应用是透明的。如果遇到伪装的危险数据包就没办法过滤掉。   应用及防火墙（代理服务器防火墙）：层次高，效率低，因为应用级防火墙会将网络包拆开，具体检查里面的数据是否有问题，会消耗大量的时间，造成效率低下，但是安全强度高，包括双宿主主机，屏蔽主机网关被屏蔽子网等方法。   被屏蔽子网方法，是在内网和外网之间增加了一个屏蔽子网，相当于多了一层网络，称为 DMZ（非军事区），这样内网和外网通信必须多经过一道防火墙，屏蔽子网中一般存放的是邮件服务器，WEB 服务器这些内外网数据交互的服务器，可以屏蔽掉一些来自内部的攻击，但是完全来自系统内部服务器的攻击还是无法屏蔽掉。</p><h4 id="计算机病毒和木马" tabindex="-1"><a class="header-anchor" href="#计算机病毒和木马"><span>计算机病毒和木马</span></a></h4><p>病毒：编制或在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令和或程序代码。病毒具有：传染性，隐蔽性，潜伏性，破坏性，针对性，衍生性，寄生性，未知性。   木马：是一种后门程序，常被黑客用作控制远程计算机的工具，隐藏在被控制电脑上的一个小程序监视电脑一切操作并盗取数据。</p><p>病毒和木马的种类   系统引导型病毒   文件外壳型病毒   目录型病毒   蠕虫病毒（感染 EXE 文件 可执行文件）：熊猫烧香，罗密欧与朱丽叶，恶魔，尼姆达，冲击波   木马：QQ 消息尾巴木马，特洛伊木马，冰河。   宏病毒（感染 word，Excel 等文件）：美丽沙，台湾一号。  CIH 病毒：史上唯一破坏硬件的病毒。   红色代码（蠕虫病毒+木马）</p><h5 id="网络攻击" tabindex="-1"><a class="header-anchor" href="#网络攻击"><span>网络攻击</span></a></h5><p>重放攻击（ARP）：所截获某次合法的通信数据拷贝，出于非法的目的而被重新发送。   拒绝服务（DOS）：对信息或其他资源的合法访问被无条件阻止。   旁路控制：攻击者利用系统的安全缺陷或安全性上的脆弱之处获得非授权的权利或特权。   授权侵犯：被授权以某一目的使用某一系统或资源的某个人，却将此权限用于其他非授权的目的，也称作“内部攻击”。   特洛伊木马：软件中含有一个察觉不出或者无害的程序段，当它被执行时，会破坏用户的安全。   窃听：用各种可能合法或非法的手段窃取系统中的信息资源或敏感信息。   业务流分析：通过对系统的长时间监听，利用统计分析方法对诸如通信频度，通信的信息流向，通信总量的变化等参数进行研究，从而发现有价值的信息和规律。   信息泄露：信息被泄露或透露给某个未授权的实体。   破坏信息完整性：数据被非授权的用户进行增删，修改或破坏而受到损失。</p><h4 id="加密技术" tabindex="-1"><a class="header-anchor" href="#加密技术"><span>加密技术</span></a></h4><p>基本概念：   明文：实际传输的真正数据。   密文：经过加密后的数据。   加密：将明文转换为密文的过程。   解密：将密文转换为明文的过程。   加密算法：一般是公开的。包括两大规则：代换（转换为完全不同的数据），置换（打乱明文顺序，进行重新置换）   秘钥：加密和解密过程中使用的密码等，是隐藏的。</p><p>对称加密技术：对数据加密和解密的秘钥是相同的，也称为共享秘钥加密技术。属于不公开秘钥加密算法。其缺点是加密安全性不高（因为只有一个秘钥）且秘钥分发困难。但是其加密快，适合大数据的加密。   常见的对称加密算法如下：  DES:替换+移位，56 位秘钥，64 位数据块，速度快，秘钥易产生。  3DES（三重 DES 或称 TDEA）：两个 56 位秘钥 K1,K2          加密：K1 加密-&gt;K2 解密-&gt;K1 加密          加密：K1 解密-&gt;K2 加密-&gt;K1 解密  AES:AES 算法是基于排序和置换运算。是美国联邦政府采用的一种区块加密标准。  RC-5：RSA 数据安全公司的很多产品都使用了 RC-5。  IDEA 算法：128 位秘钥，64 位数据块，比 DES 加密性好，对计算机功能要求相对低。   非对称加密技术：又称公开秘钥加密技术，非对称加密技术的保密性好，它消除了最终用户交换秘钥的需要，但加密解密花费的时间长，速度慢，不适合对文件加密，而只适合对少量数据进行加密。   公钥体系中，公钥是用于加密和认证，私钥用于解密和签名。   常见的非对称加密算法如下：  RSA：512 位或 1024 位秘钥，计算量极大，难破解。  Elgamal：其基础是 Diffie-HEllman 秘钥交换算法。  ECC：椭圆曲线算法。   其他非对称算法：背包算法，Rabin，D-H。</p><h3 id="常见网络诊断命令" tabindex="-1"><a class="header-anchor" href="#常见网络诊断命令"><span>常见网络诊断命令</span></a></h3><p>ping：用于检查网络是否连通； tracert( linux: traceroute)：用于确定 IP 数据包访问目标所采取的路径，若网络不通，能定位到具体哪个结点不通； ipconfig（linux: ifconfig）：显示 TCP/IP 网络配置值，如：IP 地址，MAC 地址，网关地址等；  ipconfig/release:DHCP 客户端手工释放 IP 地址  ipconfig/flushdns:清楚本地 DNS 缓存内容  ipconfig/displaydns:显示本地 DNS 内容  ipconfig/registerdns:DNS 客户端手工向服务器进行注册  ipconfig/renew:DHCP 客服端手工向服务器刷新请求（重新申请 IP 地址） nslookup：查询 DNS 记录； Netstat：用于显示网络连接、路由表和网络接口信息。</p><h2 id="多媒体基础知识" tabindex="-1"><a class="header-anchor" href="#多媒体基础知识"><span>多媒体基础知识</span></a></h2><h3 id="图形和图像" tabindex="-1"><a class="header-anchor" href="#图形和图像"><span>图形和图像</span></a></h3><h3 id="声音以及数字化" tabindex="-1"><a class="header-anchor" href="#声音以及数字化"><span>声音以及数字化</span></a></h3><h3 id="动画与视频" tabindex="-1"><a class="header-anchor" href="#动画与视频"><span>动画与视频</span></a></h3><h3 id="多媒体网络" tabindex="-1"><a class="header-anchor" href="#多媒体网络"><span>多媒体网络</span></a></h3><h3 id="多媒体计算机" tabindex="-1"><a class="header-anchor" href="#多媒体计算机"><span>多媒体计算机</span></a></h3><h2 id="数据库技术" tabindex="-1"><a class="header-anchor" href="#数据库技术"><span>数据库技术</span></a></h2><h3 id="数据库基础知识" tabindex="-1"><a class="header-anchor" href="#数据库基础知识"><span>数据库基础知识</span></a></h3><h3 id="e-r-模型" tabindex="-1"><a class="header-anchor" href="#e-r-模型"><span>E-R 模型</span></a></h3><h3 id="e-r-模型和关系模型" tabindex="-1"><a class="header-anchor" href="#e-r-模型和关系模型"><span>E-R 模型和关系模型</span></a></h3><h3 id="sql-语言" tabindex="-1"><a class="header-anchor" href="#sql-语言"><span>SQL 语言</span></a></h3><h3 id="关系代数" tabindex="-1"><a class="header-anchor" href="#关系代数"><span>关系代数</span></a></h3><h3 id="关系代数和关系模型" tabindex="-1"><a class="header-anchor" href="#关系代数和关系模型"><span>关系代数和关系模型</span></a></h3><h3 id="关系数据库的规范化" tabindex="-1"><a class="header-anchor" href="#关系数据库的规范化"><span>关系数据库的规范化</span></a></h3><h3 id="控制功能" tabindex="-1"><a class="header-anchor" href="#控制功能"><span>控制功能</span></a></h3><h2 id="标准化和知识产权" tabindex="-1"><a class="header-anchor" href="#标准化和知识产权"><span>标准化和知识产权</span></a></h2><p><strong>标准化组织对比表</strong></p><table><thead><tr><th>组织名称</th><th>性质</th><th>代表标准 / 领域</th><th>备注</th></tr></thead><tbody><tr><td><strong>ISO</strong></td><td>国际标准化组织</td><td>ISO 9000（质量）、ISO 27001（信息安全）</td><td>全球通用，促进国际间技术协调</td></tr><tr><td><strong>IEEE</strong></td><td>美国电气电子工程师协会</td><td>IEEE 802（局域网）、IEEE 754（浮点数）</td><td>侧重电气、电子及计算机工程领域标准</td></tr><tr><td><strong>CMMI</strong></td><td>过程改进模型</td><td>CMMI-DEV（软件开发成熟度）</td><td>评估企业软件开发过程成熟度</td></tr><tr><td><strong>GB</strong></td><td>中国国家标准</td><td>GB（强制性）、GB/T（推荐性）</td><td>国内通用，如 GB 18030（汉字编码）</td></tr><tr><td><strong>行业标准</strong></td><td>特定行业规范</td><td>YD（通信）、GA（公安）、SJ（电子）</td><td>在行业内强制或推荐使用</td></tr></tbody></table><h3 id="二-标准分类表" tabindex="-1"><a class="header-anchor" href="#二-标准分类表"><span>（二）标准分类表</span></a></h3><h4 id="按适用范围分类" tabindex="-1"><a class="header-anchor" href="#按适用范围分类"><span>按适用范围分类</span></a></h4><table><thead><tr><th>分类</th><th>定义</th><th>示例</th></tr></thead><tbody><tr><td>国际标准</td><td>国际组织发布，全球适用</td><td>ISO、IEC 标准</td></tr><tr><td>国家标准</td><td>国家主管机构发布，全国适用</td><td>GB（中国）、ANSI（美国）</td></tr><tr><td>行业标准</td><td>行业协会发布，特定行业内适用</td><td>YD（通信）、IEEE 标准</td></tr><tr><td>企业标准</td><td>企业自行制定，内部适用</td><td>某公司技术规范</td></tr></tbody></table><h4 id="按性质分类" tabindex="-1"><a class="header-anchor" href="#按性质分类"><span>按性质分类</span></a></h4><table><thead><tr><th>分类</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>强制性标准</td><td>法律强制遵守，违规禁止生产 / 销售</td><td>GB（不带 / T 后缀）</td></tr><tr><td>推荐性标准</td><td>自愿采用，以 “/T” 标识</td><td>GB/T、ISO/IEC 指南</td></tr></tbody></table><h3 id="二、知识产权核心考点" tabindex="-1"><a class="header-anchor" href="#二、知识产权核心考点"><span>二、知识产权核心考点</span></a></h3><h4 id="一-知识产权保护期限表" tabindex="-1"><a class="header-anchor" href="#一-知识产权保护期限表"><span>（一）知识产权保护期限表</span></a></h4><table><thead><tr><th>客体类型</th><th>权利类型</th><th>保护期限</th><th>特殊说明</th></tr></thead><tbody><tr><td><strong>软件著作权</strong></td><td>署名权、修改权</td><td>永久</td><td>公民作品归个人，职务作品归单位</td></tr><tr><td></td><td>发表权、使用权</td><td>公民：终生 + 死后 50 年；单位：首次发表后 50 年</td><td>合作开发以最后死亡作者为准</td></tr><tr><td><strong>专利权</strong></td><td>发明专利权</td><td>20 年（自申请日起）</td><td>需每年缴纳年费</td></tr><tr><td></td><td>实用新型 / 外观设计</td><td>10 年（自申请日起）</td><td></td></tr><tr><td><strong>商标权</strong></td><td>注册商标权</td><td>10 年（可无限续展，续展期 6 个月）</td><td>未续展则注销</td></tr><tr><td><strong>商业秘密</strong></td><td>技术 / 经营信息</td><td>未公开则永久有效</td><td>公开后丧失保护</td></tr></tbody></table><h4 id="二-知识产权归属判定表" tabindex="-1"><a class="header-anchor" href="#二-知识产权归属判定表"><span>（二）知识产权归属判定表</span></a></h4><table><thead><tr><th>场景</th><th>归属原则</th><th>示例说明</th></tr></thead><tbody><tr><td><strong>职务作品</strong></td><td>单位享有著作权（除署名权）</td><td>员工在本职工作中开发的软件</td></tr><tr><td><strong>委托开发</strong></td><td>有合同按合同，无合同归受托人</td><td>甲委托乙开发软件，未约定则乙拥有</td></tr><tr><td><strong>合作开发</strong></td><td>共同享有，可分割成果可单独申请</td><td>甲乙合作开发，成果可拆分则各自申请</td></tr><tr><td><strong>商标 / 专利申请</strong></td><td>先申请原则，同时申请协商或抽签</td><td>甲乙同日申请，协商不成则抽签</td></tr></tbody></table><h3 id="三、常考例题汇总" tabindex="-1"><a class="header-anchor" href="#三、常考例题汇总"><span>三、常考例题汇总</span></a></h3><h4 id="一-标准化知识例题" tabindex="-1"><a class="header-anchor" href="#一-标准化知识例题"><span>（一）标准化知识例题</span></a></h4><ol><li><strong>题目</strong>：以下属于推荐性国家标准的是（ ） A. GB 18030 B. YD/T 1234 C. GB/T 2312 D. ISO 9001 <strong>答案</strong>：C <strong>解析</strong>：GB/T 是推荐性国家标准标识，GB 为强制性，YD/T 是通信行业推荐标准，ISO 是国际标准。</li><li><strong>题目</strong>：IEEE 802.11 属于（ ） A. 国际标准 B. 行业标准 C. 企业标准 D. 地方标准 <strong>答案</strong>：B <strong>解析</strong>：IEEE 是美国电气电子工程师协会制定的行业标准，专注于局域网技术。</li></ol><h4 id="二-知识产权知识例题" tabindex="-1"><a class="header-anchor" href="#二-知识产权知识例题"><span>（二）知识产权知识例题</span></a></h4><ol><li><strong>题目</strong>：某公司员工在业余时间开发的软件，著作权归（ ） A. 公司 B. 员工个人 C. 公司与员工共有 D. 无归属 <strong>答案</strong>：B <strong>解析</strong>：非职务作品（业余时间、未用公司资源）著作权归个人所有。</li><li><strong>题目</strong>：发明专利的保护期限是（ ） A. 10 年 B. 15 年 C. 20 年 D. 50 年 <strong>答案</strong>：C <strong>解析</strong>：发明专利权保护期自申请日起 20 年，实用新型和外观设计为 10 年。</li><li><strong>题目</strong>：甲委托乙开发软件，未约定著作权归属，该软件著作权归（ ） A. 甲 B. 乙 C. 甲乙共有 D. 国家所有 <strong>答案</strong>：B <strong>解析</strong>：委托开发未约定时，著作权归受托人（乙）所有。</li><li><strong>题目</strong>：以下属于侵犯软件著作权的行为是（ ） A. 购买正版后安装到公司 3 台电脑 B. 修改正版软件后自用 C. 备份正版软件到硬盘 D. 转让正版软件许可给他人 <strong>答案</strong>：D <strong>解析</strong>：转让软件许可需著作权人授权，个人安装、备份属于合理使用，修改后自用若未传播不侵权（具体视软件许可协议）。</li></ol><h2 id="专业英语" tabindex="-1"><a class="header-anchor" href="#专业英语"><span>专业英语</span></a></h2><table><thead><tr><th>英文</th><th style="text-align:left;">中文</th></tr></thead><tbody><tr><td>Abstract</td><td style="text-align:left;">摘要；抽象的</td></tr><tr><td>Abstraction</td><td style="text-align:left;">抽象</td></tr><tr><td>Access</td><td style="text-align:left;">访问</td></tr><tr><td>Accessibility</td><td style="text-align:left;">无障碍；辅助功能 (win/mac)</td></tr><tr><td>Activate, Activation</td><td style="text-align:left;">激活</td></tr><tr><td>Active</td><td style="text-align:left;">使用中的；现用的；有效的；激活的</td></tr><tr><td>Adapter, Adaptor</td><td style="text-align:left;">适配卡，适配器</td></tr><tr><td>Add</td><td style="text-align:left;">添加</td></tr><tr><td>Address</td><td style="text-align:left;">位址，地址</td></tr><tr><td>Advanced</td><td style="text-align:left;">高级的</td></tr><tr><td>Aggregation</td><td style="text-align:left;">聚合</td></tr><tr><td>AI (Artificial intelligence)</td><td style="text-align:left;">人工智能</td></tr><tr><td>Algorithm</td><td style="text-align:left;">算法</td></tr><tr><td>Allocate</td><td style="text-align:left;">分配</td></tr><tr><td>Allocator</td><td style="text-align:left;">分配器</td></tr><tr><td>Annotation</td><td style="text-align:left;">注释 (win)；注解 (mac)</td></tr><tr><td>App bundle</td><td style="text-align:left;">应用程序包 (win)；App 捆绑包 (mac)</td></tr><tr><td>Application</td><td style="text-align:left;">应用；应用程序</td></tr><tr><td>Apply</td><td style="text-align:left;">应用</td></tr><tr><td>Architecture</td><td style="text-align:left;">架构；结构</td></tr><tr><td>Argument</td><td style="text-align:left;">参数（也称为实际参数，实参）</td></tr><tr><td>Arity</td><td style="text-align:left;">参数数量</td></tr><tr><td>Artifact</td><td style="text-align:left;">项目 (win)；成品 (mac)</td></tr><tr><td>Array</td><td style="text-align:left;">数组</td></tr><tr><td>Assembly language</td><td style="text-align:left;">汇编语言</td></tr><tr><td>Assert, Assertion</td><td style="text-align:left;">断言 (win)；声明 (win/mac)；论断 (mac)</td></tr><tr><td>Assign, Assignment</td><td style="text-align:left;">分配；（编程）赋值</td></tr><tr><td>Assignment operator</td><td style="text-align:left;">赋值运算符</td></tr><tr><td>Asynchronize</td><td style="text-align:left;">异步</td></tr><tr><td>Asynchronous</td><td style="text-align:left;">异步的</td></tr><tr><td>Atomic</td><td style="text-align:left;">原子的</td></tr><tr><td>Attribute</td><td style="text-align:left;">属性</td></tr><tr><td>Audio</td><td style="text-align:left;">音频</td></tr><tr><td>Authenticate, Authentication</td><td style="text-align:left;">验证，认证</td></tr><tr><td>Authorize, Authorization</td><td style="text-align:left;">授权</td></tr><tr><td>Autoboxing</td><td style="text-align:left;">自动装箱</td></tr><tr><td>Background processes</td><td style="text-align:left;">后台进程</td></tr><tr><td>Bandwidth</td><td style="text-align:left;">带宽</td></tr><tr><td>Base class</td><td style="text-align:left;">基类</td></tr><tr><td>Batch</td><td style="text-align:left;">批（处理）</td></tr><tr><td>Binary function</td><td style="text-align:left;">二元函数</td></tr><tr><td>Binary operator</td><td style="text-align:left;">二元运算符</td></tr><tr><td>Binary search</td><td style="text-align:left;">二分查找</td></tr><tr><td>Binary tree</td><td style="text-align:left;">二叉树</td></tr><tr><td>Bind</td><td style="text-align:left;">绑定</td></tr><tr><td>Bit</td><td style="text-align:left;">位</td></tr><tr><td>Bitrate</td><td style="text-align:left;">码率</td></tr><tr><td>Block</td><td style="text-align:left;">屏蔽；阻止</td></tr><tr><td>Block</td><td style="text-align:left;">（代码）块</td></tr><tr><td>Blocker</td><td style="text-align:left;">阻止程序 (win)；拦截器 (mac)</td></tr><tr><td>Boolean</td><td style="text-align:left;">布尔</td></tr><tr><td>Bounce</td><td style="text-align:left;">退回；弹跳</td></tr><tr><td>Breakpoint</td><td style="text-align:left;">断点</td></tr><tr><td>Build (verb)</td><td style="text-align:left;">构建</td></tr><tr><td>Build (noun)</td><td style="text-align:left;">构件；版本（号）</td></tr><tr><td>Build-in</td><td style="text-align:left;">内置 (win)；内建 (mac)</td></tr><tr><td>Bundle (noun)</td><td style="text-align:left;">捆绑包</td></tr><tr><td>Bundle (verb)</td><td style="text-align:left;">整合</td></tr><tr><td>Bus</td><td style="text-align:left;">总线</td></tr><tr><td>Burn</td><td style="text-align:left;">刻录</td></tr><tr><td>Byte</td><td style="text-align:left;">字节</td></tr><tr><td>Cache</td><td style="text-align:left;">高速缓存，缓存</td></tr><tr><td>Call</td><td style="text-align:left;">调用</td></tr><tr><td>Callback</td><td style="text-align:left;">回调</td></tr><tr><td>Certificate</td><td style="text-align:left;">证书</td></tr><tr><td>Character</td><td style="text-align:left;">字符</td></tr><tr><td>Check</td><td style="text-align:left;">查看</td></tr><tr><td>Check box, Checkbox</td><td style="text-align:left;">复选框</td></tr><tr><td>Class</td><td style="text-align:left;">类</td></tr><tr><td>Point &amp; Click (noun)</td><td style="text-align:left;">点按</td></tr><tr><td>Click (vs. Tap)</td><td style="text-align:left;">点击 (win)；点按 (mac)</td></tr><tr><td>Tap (vs. Click)</td><td style="text-align:left;">触碰 (win)；轻点 (mac)</td></tr><tr><td>Client-side</td><td style="text-align:left;">客户端</td></tr><tr><td>Clipboard</td><td style="text-align:left;">剪贴板</td></tr><tr><td>Clone</td><td style="text-align:left;">克隆</td></tr><tr><td>Cloud computing</td><td style="text-align:left;">云计算</td></tr><tr><td>Cohesion</td><td style="text-align:left;">内聚</td></tr><tr><td>Collaborate, Collaboration</td><td style="text-align:left;">协作</td></tr><tr><td>Combo box</td><td style="text-align:left;">组合框</td></tr><tr><td>Come with</td><td style="text-align:left;">随附</td></tr><tr><td>Command</td><td style="text-align:left;">命令</td></tr><tr><td>Command line</td><td style="text-align:left;">命令行</td></tr><tr><td>Comment</td><td style="text-align:left;">评论</td></tr><tr><td>注解，注释</td><td style="text-align:left;"></td></tr><tr><td>Commit</td><td style="text-align:left;">提交</td></tr><tr><td>Communication</td><td style="text-align:left;">通信</td></tr><tr><td>Community</td><td style="text-align:left;">社区</td></tr><tr><td>Compatibility</td><td style="text-align:left;">兼容性</td></tr><tr><td>Compatible</td><td style="text-align:left;">兼容的</td></tr><tr><td>Compile, Compilation</td><td style="text-align:left;">编译</td></tr><tr><td>Compile time, Compile-time</td><td style="text-align:left;">编译期，编译时</td></tr><tr><td>Compiler</td><td style="text-align:left;">编译器</td></tr><tr><td>Component</td><td style="text-align:left;">组件</td></tr><tr><td>Composition</td><td style="text-align:left;">组合</td></tr><tr><td>Compress</td><td style="text-align:left;">压缩</td></tr><tr><td>Concurrency</td><td style="text-align:left;">并发性，并发</td></tr><tr><td>Concurrent</td><td style="text-align:left;">并发的；同时的</td></tr><tr><td>Configuration</td><td style="text-align:left;">配置</td></tr><tr><td>Connect, Connection</td><td style="text-align:left;">连接</td></tr><tr><td>Constant</td><td style="text-align:left;">常量</td></tr><tr><td>Constraint</td><td style="text-align:left;">约束；限制</td></tr><tr><td>Constructor</td><td style="text-align:left;">构造函数</td></tr><tr><td>Container</td><td style="text-align:left;">容器</td></tr><tr><td>Context</td><td style="text-align:left;">背景（关系）；环境；上下文；内容</td></tr><tr><td>Continuous delivery</td><td style="text-align:left;">持续交付</td></tr><tr><td>Continuous deployment</td><td style="text-align:left;">持续部署</td></tr><tr><td>Continuous integration</td><td style="text-align:left;">持续集成</td></tr><tr><td>Control</td><td style="text-align:left;">控件</td></tr><tr><td>Copy</td><td style="text-align:left;">复制 (win)；拷贝 (mac)</td></tr><tr><td>Coroutine</td><td style="text-align:left;">协程，协同程序</td></tr><tr><td>Coupling</td><td style="text-align:left;">耦合</td></tr><tr><td>Crash</td><td style="text-align:left;">崩溃 (win/mac)；故障 (win)</td></tr><tr><td>Create</td><td style="text-align:left;">创建</td></tr><tr><td>Cursor</td><td style="text-align:left;">光标</td></tr><tr><td>Custom</td><td style="text-align:left;">自定义</td></tr><tr><td>Data</td><td style="text-align:left;">数据</td></tr><tr><td>Data link layer</td><td style="text-align:left;">数据链路层</td></tr><tr><td>Data structure</td><td style="text-align:left;">数据结构</td></tr><tr><td>Database</td><td style="text-align:left;">数据库</td></tr><tr><td>Database schema</td><td style="text-align:left;">数据库架构，数据库模式</td></tr><tr><td>Deadlock</td><td style="text-align:left;">死锁</td></tr><tr><td>Debug</td><td style="text-align:left;">调试</td></tr><tr><td>Debugger</td><td style="text-align:left;">调试器</td></tr><tr><td>Declare, Declaration</td><td style="text-align:left;">声明</td></tr><tr><td>Default</td><td style="text-align:left;">默认</td></tr><tr><td>Definition</td><td style="text-align:left;">定义；清晰度</td></tr><tr><td>Delegate, Delegation</td><td style="text-align:left;">委托</td></tr><tr><td>Dependency</td><td style="text-align:left;">依赖</td></tr><tr><td>Derived class</td><td style="text-align:left;">派生类</td></tr><tr><td>Design pattern</td><td style="text-align:left;">设计模式</td></tr><tr><td>Destructor</td><td style="text-align:left;">析构函数</td></tr><tr><td>Detect, Detection</td><td style="text-align:left;">检测</td></tr><tr><td>Device</td><td style="text-align:left;">设备</td></tr><tr><td>Dialog</td><td style="text-align:left;">对话框</td></tr><tr><td>Digital</td><td style="text-align:left;">数字的；数字化</td></tr><tr><td>Digital signature</td><td style="text-align:left;">数字签名</td></tr><tr><td>Digital certificate</td><td style="text-align:left;">数字证书</td></tr><tr><td>Directory</td><td style="text-align:left;">目录</td></tr><tr><td>Disk</td><td style="text-align:left;">盘</td></tr><tr><td>Disk image</td><td style="text-align:left;">磁盘映像</td></tr><tr><td>Dispatch</td><td style="text-align:left;">分派；调度</td></tr><tr><td>Distributed</td><td style="text-align:left;">分布式</td></tr><tr><td>Distribute, Distribution</td><td style="text-align:left;">分发；分配；分布</td></tr><tr><td>Distribution</td><td style="text-align:left;">发行（版本）</td></tr><tr><td>Document</td><td style="text-align:left;">文档；文稿</td></tr><tr><td>Domain</td><td style="text-align:left;">域</td></tr><tr><td>Driver</td><td style="text-align:left;">驱动程序</td></tr><tr><td>Drop-down, Dropdown (noun)</td><td style="text-align:left;">下拉菜单</td></tr><tr><td>Drop-down, Dropdown (verb)</td><td style="text-align:left;">下拉</td></tr><tr><td>Drop-down menu</td><td style="text-align:left;">下拉菜单 (win/mac)</td></tr><tr><td>Drop-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Dynamic binding</td><td style="text-align:left;">动态绑定</td></tr><tr><td>Element</td><td style="text-align:left;">元素；元件</td></tr><tr><td>Email, E-mail</td><td style="text-align:left;">电子邮件</td></tr><tr><td>Enable</td><td style="text-align:left;">启用</td></tr><tr><td>Encapsulation</td><td style="text-align:left;">封装</td></tr><tr><td>Entity</td><td style="text-align:left;">实体</td></tr><tr><td>Enumeration</td><td style="text-align:left;">枚举</td></tr><tr><td>Equal</td><td style="text-align:left;">相等的</td></tr><tr><td>Equality</td><td style="text-align:left;">相等性，相等</td></tr><tr><td>Escape code</td><td style="text-align:left;">转义码</td></tr><tr><td>Event</td><td style="text-align:left;">事件</td></tr><tr><td>Exception</td><td style="text-align:left;">异常</td></tr><tr><td>Explicit</td><td style="text-align:left;">显式</td></tr><tr><td>Export</td><td style="text-align:left;">导出</td></tr><tr><td>Expression</td><td style="text-align:left;">表达式</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展（程序、功能）</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展名</td></tr><tr><td>Feature</td><td style="text-align:left;">特色，特点</td></tr><tr><td>Feature (vs. Function)</td><td style="text-align:left;">（特殊的）功能</td></tr><tr><td>Feedback</td><td style="text-align:left;">反馈</td></tr><tr><td>Field</td><td style="text-align:left;">字段，栏位；域</td></tr><tr><td>File</td><td style="text-align:left;">文件</td></tr><tr><td>Filter</td><td style="text-align:left;">过滤器</td></tr><tr><td>Find</td><td style="text-align:left;">查找</td></tr><tr><td>Firmware</td><td style="text-align:left;">固件</td></tr><tr><td>Flag</td><td style="text-align:left;">标记</td></tr><tr><td>Flash memory</td><td style="text-align:left;">闪存</td></tr><tr><td>Flush</td><td style="text-align:left;">刷新</td></tr><tr><td>对齐，齐平</td><td style="text-align:left;"></td></tr><tr><td>Folder</td><td style="text-align:left;">文件夹</td></tr><tr><td>Font</td><td style="text-align:left;">字体</td></tr><tr><td>Form</td><td style="text-align:left;">表单</td></tr><tr><td>Format (noun)</td><td style="text-align:left;">格式</td></tr><tr><td>Format (verb)</td><td style="text-align:left;">格式化</td></tr><tr><td>Forward</td><td style="text-align:left;">转发，转送，转寄</td></tr><tr><td>Fragment</td><td style="text-align:left;">片段</td></tr><tr><td>Frame</td><td style="text-align:left;">帧；框架</td></tr><tr><td>Frame rate FPS (frames per second)</td><td style="text-align:left;">帧率</td></tr><tr><td>Framework</td><td style="text-align:left;">框架</td></tr><tr><td>Frozen</td><td style="text-align:left;">冻结，锁定</td></tr><tr><td>Full screen, Fullscreen</td><td style="text-align:left;">全屏</td></tr><tr><td>Function</td><td style="text-align:left;">函数</td></tr><tr><td>Function (vs. Feature)</td><td style="text-align:left;">（一般的）功能</td></tr><tr><td>Functionality</td><td style="text-align:left;">功能</td></tr><tr><td>Game</td><td style="text-align:left;">游戏</td></tr><tr><td>Gateway</td><td style="text-align:left;">网关</td></tr><tr><td>General</td><td style="text-align:left;">通用的</td></tr><tr><td>Generate</td><td style="text-align:left;">生成</td></tr><tr><td>Generic</td><td style="text-align:left;">通用的</td></tr><tr><td>Generics</td><td style="text-align:left;">泛型</td></tr><tr><td>Global</td><td style="text-align:left;">全局的</td></tr><tr><td>Group box</td><td style="text-align:left;">分组框，群组框</td></tr><tr><td>Graph</td><td style="text-align:left;">图</td></tr><tr><td>Handle</td><td style="text-align:left;">句柄</td></tr><tr><td>Handler</td><td style="text-align:left;">处理程序，处理器</td></tr><tr><td>Hardware</td><td style="text-align:left;">硬件</td></tr><tr><td>Hash</td><td style="text-align:left;">哈希</td></tr><tr><td>Header file</td><td style="text-align:left;">头文件</td></tr><tr><td>Heap</td><td style="text-align:left;">堆</td></tr><tr><td>Help</td><td style="text-align:left;">帮助</td></tr><tr><td>Hierarchy</td><td style="text-align:left;">层次结构</td></tr><tr><td>High Definition</td><td style="text-align:left;">高清晰度，高清</td></tr><tr><td>Host file</td><td style="text-align:left;">主机文件</td></tr><tr><td>Home folder</td><td style="text-align:left;">主文件夹 (win)；个人文件夹 (mac)</td></tr><tr><td>Home page</td><td style="text-align:left;">主页</td></tr><tr><td>Icon</td><td style="text-align:left;">图标</td></tr><tr><td>IDE</td><td style="text-align:left;">集成开发环境</td></tr><tr><td>Identifier</td><td style="text-align:left;">标识符</td></tr><tr><td>Idle</td><td style="text-align:left;">闲置</td></tr><tr><td>Image</td><td style="text-align:left;">影像；图像，图片；映像</td></tr><tr><td>Immutable</td><td style="text-align:left;">不可变的；不可更改的</td></tr><tr><td>Implement</td><td style="text-align:left;">实现</td></tr><tr><td>Implementation</td><td style="text-align:left;">实现</td></tr><tr><td>Implicit</td><td style="text-align:left;">隐式</td></tr><tr><td>Import</td><td style="text-align:left;">导入</td></tr><tr><td>Indent</td><td style="text-align:left;">缩进</td></tr><tr><td>Info</td><td style="text-align:left;">简介</td></tr><tr><td>Information</td><td style="text-align:left;">信息</td></tr><tr><td>Inheritance</td><td style="text-align:left;">继承</td></tr><tr><td>Initialization</td><td style="text-align:left;">初始化</td></tr><tr><td>Inline</td><td style="text-align:left;">内联</td></tr><tr><td>Instance</td><td style="text-align:left;">实例</td></tr><tr><td>Integrate</td><td style="text-align:left;">集成</td></tr><tr><td>Integrated</td><td style="text-align:left;">集成的</td></tr><tr><td>Integrity</td><td style="text-align:left;">完整性</td></tr><tr><td>Interact, Interaction</td><td style="text-align:left;">交互</td></tr><tr><td>Interface</td><td style="text-align:left;">接口</td></tr><tr><td>Internal Storage</td><td style="text-align:left;">内存 (仅手机等便携装置，民间称谓)</td></tr><tr><td>Internationalization (I18N)</td><td style="text-align:left;">国际化</td></tr><tr><td>Internet</td><td style="text-align:left;">互联网</td></tr><tr><td>Interpreter</td><td style="text-align:left;">解释器</td></tr><tr><td>Invoke</td><td style="text-align:left;">调用</td></tr><tr><td>Iterate</td><td style="text-align:left;">迭代； 重复、循环（访问）</td></tr><tr><td>Iteration</td><td style="text-align:left;">迭代</td></tr><tr><td>Iterator</td><td style="text-align:left;">迭代器</td></tr><tr><td>Kernel</td><td style="text-align:left;">内核</td></tr><tr><td>Key</td><td style="text-align:left;">密钥</td></tr><tr><td>Keybind</td><td style="text-align:left;">快捷键</td></tr><tr><td>Lag</td><td style="text-align:left;">延迟</td></tr><tr><td>Layout</td><td style="text-align:left;">布局，配置</td></tr><tr><td>Lazy loading</td><td style="text-align:left;">延迟加载；懒加载</td></tr><tr><td>Library</td><td style="text-align:left;">程序库，函数库</td></tr><tr><td>Link</td><td style="text-align:left;">链接</td></tr><tr><td>Link time</td><td style="text-align:left;">链接期</td></tr><tr><td>Linked list</td><td style="text-align:left;">链表</td></tr><tr><td>Linker</td><td style="text-align:left;">链接器</td></tr><tr><td>List</td><td style="text-align:left;">列表</td></tr><tr><td>Listener</td><td style="text-align:left;">监听器</td></tr><tr><td>Literals</td><td style="text-align:left;">字面值，字面量</td></tr><tr><td>Literal constant</td><td style="text-align:left;">字面常量</td></tr><tr><td>Load</td><td style="text-align:left;">加载</td></tr><tr><td>Load time</td><td style="text-align:left;">加载期</td></tr><tr><td>Loader</td><td style="text-align:left;">加载器</td></tr><tr><td>Local</td><td style="text-align:left;">局部的，本地的；本地（主机）</td></tr><tr><td>Localization (L10N)</td><td style="text-align:left;">本地化</td></tr><tr><td>Local variable</td><td style="text-align:left;">局部变量</td></tr><tr><td>Lock</td><td style="text-align:left;">锁定</td></tr><tr><td>Log</td><td style="text-align:left;">日志</td></tr><tr><td>Log in, Login</td><td style="text-align:left;">登录</td></tr><tr><td>Log out, Logout</td><td style="text-align:left;">退出；注销</td></tr><tr><td>Loop</td><td style="text-align:left;">循环</td></tr><tr><td>Map, Mapping</td><td style="text-align:left;">映射</td></tr><tr><td>Match</td><td style="text-align:left;">匹配</td></tr><tr><td>Memory</td><td style="text-align:left;">内存</td></tr><tr><td>Menu</td><td style="text-align:left;">菜单</td></tr><tr><td>Message</td><td style="text-align:left;">消息；信息</td></tr><tr><td>Metadata</td><td style="text-align:left;">元数据</td></tr><tr><td>Middleware</td><td style="text-align:left;">中间件，中间软件</td></tr><tr><td>Mobile</td><td style="text-align:left;">移动</td></tr><tr><td>Moderate, Moderation</td><td style="text-align:left;">审核</td></tr><tr><td>Modifier</td><td style="text-align:left;">修饰符</td></tr><tr><td>Module</td><td style="text-align:left;">模块</td></tr><tr><td>Monomorphism</td><td style="text-align:left;">单态</td></tr><tr><td>Motherboard</td><td style="text-align:left;">主板</td></tr><tr><td>Mouse</td><td style="text-align:left;">鼠标</td></tr><tr><td>Mouse pointer</td><td style="text-align:left;">鼠标指针</td></tr><tr><td>Multitasking</td><td style="text-align:left;">多任务（处理）</td></tr><tr><td>Mutable</td><td style="text-align:left;">可变的</td></tr><tr><td>Mutex</td><td style="text-align:left;">互斥</td></tr><tr><td>Native</td><td style="text-align:left;">原生</td></tr><tr><td>Navigate, Navigation</td><td style="text-align:left;">导航</td></tr><tr><td>Navigator</td><td style="text-align:left;">导航器</td></tr><tr><td>Nested</td><td style="text-align:left;">嵌套的</td></tr><tr><td>Network</td><td style="text-align:left;">网络</td></tr><tr><td>New</td><td style="text-align:left;">新建</td></tr><tr><td>Notarization</td><td style="text-align:left;">公证</td></tr><tr><td>Object</td><td style="text-align:left;">对象</td></tr><tr><td>Object code</td><td style="text-align:left;">目标代码</td></tr><tr><td>Object file</td><td style="text-align:left;">目标文件</td></tr><tr><td>Object-oriented</td><td style="text-align:left;">面向对象</td></tr><tr><td>Online</td><td style="text-align:left;">在线</td></tr><tr><td>Operand</td><td style="text-align:left;">操作数，运算元</td></tr><tr><td>Operating system</td><td style="text-align:left;">操作系统</td></tr><tr><td>Operator</td><td style="text-align:left;">操作符，运算符</td></tr><tr><td>Optimize, Optimization</td><td style="text-align:left;">优化</td></tr><tr><td>Overflow</td><td style="text-align:left;">溢出（上溢出）</td></tr><tr><td>Overlay</td><td style="text-align:left;">叠加面板</td></tr><tr><td>Overload</td><td style="text-align:left;">重载</td></tr><tr><td>Override</td><td style="text-align:left;">覆盖，重写</td></tr><tr><td>Pack</td><td style="text-align:left;">打包，压缩</td></tr><tr><td>Package (noun)</td><td style="text-align:left;">（程序、软件）包</td></tr><tr><td>Package (verb)</td><td style="text-align:left;">打包，封装</td></tr><tr><td>Pane</td><td style="text-align:left;">窗格 (win) 面板 (mac)</td></tr><tr><td>Parallelism</td><td style="text-align:left;">并行性，并行</td></tr><tr><td>Parameter</td><td style="text-align:left;">参数（也称为形式参数，形参）</td></tr><tr><td>Parse</td><td style="text-align:left;">解析</td></tr><tr><td>Partition</td><td style="text-align:left;">分割；（硬盘）分区</td></tr><tr><td>Paste</td><td style="text-align:left;">粘贴</td></tr><tr><td>Patch</td><td style="text-align:left;">补丁 (win) 修补程序 (mac)</td></tr><tr><td>Pattern</td><td style="text-align:left;">模式；样式</td></tr><tr><td>Performance</td><td style="text-align:left;">性能</td></tr><tr><td>Persistence</td><td style="text-align:left;">持久性</td></tr><tr><td>Photo</td><td style="text-align:left;">照片</td></tr><tr><td>Physical layer</td><td style="text-align:left;">物理层</td></tr><tr><td>Picklist</td><td style="text-align:left;">选择列表</td></tr><tr><td>Placeholder</td><td style="text-align:left;">占位符</td></tr><tr><td>Pluggability</td><td style="text-align:left;">可插入性</td></tr><tr><td>Plugin</td><td style="text-align:left;">插件</td></tr><tr><td>Pointer</td><td style="text-align:left;">指针</td></tr><tr><td>Polymorphism</td><td style="text-align:left;">多态</td></tr><tr><td>Port</td><td style="text-align:left;">端口</td></tr><tr><td>Power bank</td><td style="text-align:left;">移动电源，充电宝</td></tr><tr><td>Presentation layer</td><td style="text-align:left;">表示层</td></tr><tr><td>Preset</td><td style="text-align:left;">预设</td></tr><tr><td>Print</td><td style="text-align:left;">打印</td></tr><tr><td>Printer</td><td style="text-align:left;">打印机</td></tr><tr><td>Procedure</td><td style="text-align:left;">过程</td></tr><tr><td>Process</td><td style="text-align:left;">进程</td></tr><tr><td>Profile</td><td style="text-align:left;">配置文件 (win) 描述文件 (mac)</td></tr><tr><td>Profile</td><td style="text-align:left;">评测</td></tr><tr><td>Profile (or Personal profile)</td><td style="text-align:left;">个人资料</td></tr><tr><td>Profiler</td><td style="text-align:left;">（性能）分析器</td></tr><tr><td>Program</td><td style="text-align:left;">程序</td></tr><tr><td>Project</td><td style="text-align:left;">项目</td></tr><tr><td>Protocol</td><td style="text-align:left;">协议</td></tr><tr><td>Provision, Provisioning</td><td style="text-align:left;">预配</td></tr><tr><td>Proxy (or Proxy server)</td><td style="text-align:left;">代理服务器</td></tr><tr><td>Pseudo code</td><td style="text-align:left;">伪代码</td></tr><tr><td>Pull-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Quality</td><td style="text-align:left;">质量</td></tr><tr><td>Queue</td><td style="text-align:left;">队列</td></tr><tr><td>Quit unexpectedly</td><td style="text-align:left;">意外退出</td></tr><tr><td>Radian</td><td style="text-align:left;">弧度</td></tr><tr><td>Radio button</td><td style="text-align:left;">单选按钮</td></tr><tr><td>RAM (Random Access Memory)</td><td style="text-align:left;">随机存取存储器</td></tr><tr><td>Read</td><td style="text-align:left;">读</td></tr><tr><td>Read-only</td><td style="text-align:left;">只读</td></tr><tr><td>Recovery</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Recursion</td><td style="text-align:left;">递归</td></tr><tr><td>Redirect, Redirection</td><td style="text-align:left;">重定向</td></tr><tr><td>Reference</td><td style="text-align:left;">参考</td></tr><tr><td>Register</td><td style="text-align:left;">寄存器；注册</td></tr><tr><td>Release</td><td style="text-align:left;">（发行、发布）版本</td></tr><tr><td>Remote</td><td style="text-align:left;">远程</td></tr><tr><td>Render</td><td style="text-align:left;">渲染</td></tr><tr><td>Resolution</td><td style="text-align:left;">分辨率</td></tr><tr><td>Response</td><td style="text-align:left;">响应</td></tr><tr><td>Response body</td><td style="text-align:left;">响应正文</td></tr><tr><td>Response header</td><td style="text-align:left;">响应头</td></tr><tr><td>Restore</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Return</td><td style="text-align:left;">返回；恢复</td></tr><tr><td>Revoke, Revocation</td><td style="text-align:left;">撤销</td></tr><tr><td>Rollback</td><td style="text-align:left;">回滚，回退</td></tr><tr><td>Routine</td><td style="text-align:left;">程序</td></tr><tr><td>Run</td><td style="text-align:left;">运行</td></tr><tr><td>Runtime, Run-time</td><td style="text-align:left;">运行期，运行时；运行环境</td></tr><tr><td>Runtime environment (RTE), Runtime system</td><td style="text-align:left;">运行环境；运行系统</td></tr><tr><td>Save</td><td style="text-align:left;">保存</td></tr><tr><td>Sampling</td><td style="text-align:left;">取样</td></tr><tr><td>Scalar</td><td style="text-align:left;">标量</td></tr><tr><td>Schedule</td><td style="text-align:left;">调度</td></tr><tr><td>Scheduler</td><td style="text-align:left;">调度器，调度程序</td></tr><tr><td>Scope</td><td style="text-align:left;">（作用、有效）范围，域</td></tr><tr><td>Scroll bar</td><td style="text-align:left;">滚动条</td></tr><tr><td>Script</td><td style="text-align:left;">脚本</td></tr><tr><td>SDK (Software Development Kit)</td><td style="text-align:left;">软件开发工具包 (win) 软件开发套件 (mac)</td></tr><tr><td>Search engine</td><td style="text-align:left;">搜索引擎</td></tr><tr><td>Security</td><td style="text-align:left;">安全性</td></tr><tr><td>Segment</td><td style="text-align:left;">段</td></tr><tr><td>Server</td><td style="text-align:left;">服务器</td></tr><tr><td>Server-side</td><td style="text-align:left;">服务器端</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session layer</td><td style="text-align:left;">会话层</td></tr><tr><td>Set up</td><td style="text-align:left;">设置</td></tr><tr><td>Settings</td><td style="text-align:left;">设置</td></tr><tr><td>Shortcut</td><td style="text-align:left;">快捷</td></tr><tr><td>Shortcut key</td><td style="text-align:left;">快捷键</td></tr><tr><td>Sign in, sign-in</td><td style="text-align:left;">登录</td></tr><tr><td>Sign out, sign-out</td><td style="text-align:left;">退出，注销</td></tr><tr><td>Silicon</td><td style="text-align:left;">硅</td></tr><tr><td>Simulation</td><td style="text-align:left;">模拟</td></tr><tr><td>Signature</td><td style="text-align:left;">签名</td></tr><tr><td>Slider</td><td style="text-align:left;">滑块</td></tr><tr><td>Smart</td><td style="text-align:left;">智能</td></tr><tr><td>Smartphone</td><td style="text-align:left;">智能手机</td></tr><tr><td>SMS (Short Message Service)</td><td style="text-align:left;">短信</td></tr><tr><td>Snip</td><td style="text-align:left;">截图</td></tr><tr><td>Source code</td><td style="text-align:left;">源代码，源码</td></tr><tr><td>Stack</td><td style="text-align:left;">栈</td></tr><tr><td>Star rating</td><td style="text-align:left;">星级评分</td></tr><tr><td>Statement</td><td style="text-align:left;">语句</td></tr><tr><td>Status bar</td><td style="text-align:left;">状态栏</td></tr><tr><td>Stepper</td><td style="text-align:left;">步进器</td></tr><tr><td>Stream</td><td style="text-align:left;">（数据）流</td></tr><tr><td>String</td><td style="text-align:left;">字符串</td></tr><tr><td>String interpolation</td><td style="text-align:left;">字符串插值</td></tr><tr><td>Stuttering</td><td style="text-align:left;">-</td></tr><tr><td>Subclass</td><td style="text-align:left;">子类</td></tr><tr><td>Subroutine</td><td style="text-align:left;">子例程</td></tr><tr><td>Superclass</td><td style="text-align:left;">超类</td></tr><tr><td>Support</td><td style="text-align:left;">支持</td></tr><tr><td>Suspend</td><td style="text-align:left;">暂停（权限）</td></tr><tr><td>Synchronize</td><td style="text-align:left;">同步</td></tr><tr><td>Synchronous</td><td style="text-align:left;">同步的</td></tr><tr><td>Tab</td><td style="text-align:left;">标签（页）</td></tr><tr><td>Tag</td><td style="text-align:left;">标签</td></tr><tr><td>Task</td><td style="text-align:left;">任务</td></tr><tr><td>Template</td><td style="text-align:left;">模板</td></tr><tr><td>Text</td><td style="text-align:left;">文本</td></tr><tr><td>Text box</td><td style="text-align:left;">文本框</td></tr><tr><td>Thread</td><td style="text-align:left;">线程</td></tr><tr><td>Top-up</td><td style="text-align:left;">充值</td></tr><tr><td>Token</td><td style="text-align:left;">标记 (win) 令牌 (mac)</td></tr><tr><td>权杖；代币</td><td style="text-align:left;"></td></tr><tr><td>Traverse</td><td style="text-align:left;">遍历</td></tr><tr><td>Tray (or System tray)</td><td style="text-align:left;">系统托盘</td></tr><tr><td>Tree</td><td style="text-align:left;">树</td></tr><tr><td>Tuple</td><td style="text-align:left;">元组</td></tr><tr><td>Tutorial</td><td style="text-align:left;">教程</td></tr><tr><td>Type</td><td style="text-align:left;">类型</td></tr><tr><td>Universal</td><td style="text-align:left;">通用的</td></tr><tr><td>Variable</td><td style="text-align:left;">变量</td></tr><tr><td>Video</td><td style="text-align:left;">视频</td></tr><tr><td>View</td><td style="text-align:left;">查看；显示；视图</td></tr><tr><td>Voice</td><td style="text-align:left;">语音</td></tr><tr><td>Volume</td><td style="text-align:left;">卷 (win)；宗卷 (mac)</td></tr><tr><td>Window</td><td style="text-align:left;">窗口</td></tr><tr><td>Widget</td><td style="text-align:left;">窗口部件；小部件</td></tr><tr><td>Wildcard</td><td style="text-align:left;">通配符</td></tr><tr><td>Workspaces</td><td style="text-align:left;">工作区</td></tr><tr><td>Write</td><td style="text-align:left;">写</td></tr></tbody></table>',458)]))}const v=d(A,[["render",S]]),B=JSON.parse('{"path":"/article/ruankao/","title":"软考知识点","lang":"zh-CN","frontmatter":{"title":"软考知识点","createTime":"2025/03/18 17:13:30","permalink":"/article/ruankao/","description":"上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分...","head":[["meta",{"property":"og:url","content":"https://www.52uni.cn/article/ruankao/"}],["meta",{"property":"og:site_name","content":"UNI知识库"}],["meta",{"property":"og:title","content":"软考知识点"}],["meta",{"property":"og:description","content":"上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"软考知识点\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":91.03,"words":27308},"git":{},"autoDesc":true,"filePathRelative":"preview/softdesign.md","categoryList":[{"id":"5ebeb6","sort":10001,"name":"preview"}]}');export{v as comp,B as data};
