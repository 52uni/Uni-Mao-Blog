import{_ as s,c as d,e as r,o as n}from"./app-CnMC5VGS.js";const e="/assets/image-20250316174337495-CO564BMc.png",l="/assets/image-20250404215904436-CXm_c510.png",i="/assets/image-20250316174428287-Cv9C5KZq.png",a="/assets/image-20250316174449320-DXoe8KSh.png",o="/assets/image-20250316174549313-D7x92kug.png",g="/assets/image-20250316174625466-BSTq1sdl.png",h="/assets/image-20250405110413577-DyhoXqts.png",p="/assets/59-y9hSpkC8.png",c="/assets/60-CiLiK6D9.png",u="/assets/61-gU8K_lwm.png",b="/assets/62-CNJUt_sp.png",f="/assets/63-C2hs4Npk.png",y="/assets/64-D81HV21A.png",m="/assets/65-C8UEHjrl.png",x="/assets/66-N5Nz1Mkt.png",k="/assets/67-D4gOsU_7.png",v="/assets/68-B_v9o9Ig.png",C={};function E(A,t){return n(),d("div",null,t[0]||(t[0]=[r('<h1 id="上午题知识点" tabindex="-1"><a class="header-anchor" href="#上午题知识点"><span>上午题知识点</span></a></h1><h2 id="计算机组成原理" tabindex="-1"><a class="header-anchor" href="#计算机组成原理"><span>计算机组成原理</span></a></h2><h3 id="计算机基本工作原理" tabindex="-1"><a class="header-anchor" href="#计算机基本工作原理"><span>计算机基本工作原理</span></a></h3><h4 id="冯诺依曼体系结构" tabindex="-1"><a class="header-anchor" href="#冯诺依曼体系结构"><span>冯诺依曼体系结构</span></a></h4><p><strong>一、核心思想</strong></p><p><strong>存储程序 + 程序控制</strong> 计算机的 <strong>程序和数据统一存储在内存中</strong>，CPU 按顺序读取指令并执行。</p><p><strong>二、五大组成部分</strong></p><table><thead><tr><th><strong>部件</strong></th><th><strong>功能</strong></th><th><strong>类比</strong></th></tr></thead><tbody><tr><td><strong>运算器</strong></td><td>算术运算（如加减乘除）和逻辑运算（如与或非）</td><td>计算器</td></tr><tr><td><strong>控制器</strong></td><td>指挥各部件协调工作（取指令、译码、执行）</td><td>指挥官</td></tr><tr><td><strong>存储器</strong></td><td>存放程序和数据（内存、硬盘等）</td><td>仓库</td></tr><tr><td><strong>输入设备</strong></td><td>将外部信息（如键盘、鼠标）输入到计算机</td><td>眼睛 / 耳朵</td></tr><tr><td><strong>输出设备</strong></td><td>将处理结果输出（如显示器、打印机）</td><td>嘴巴 / 手</td></tr></tbody></table><p><strong>三、工作流程</strong></p><ol><li><p><strong>输入</strong>：用户通过输入设备（如键盘）输入程序或数据。</p></li><li><p><strong>存储</strong>：程序和数据存入存储器（如内存）。</p></li><li><p><strong>执行</strong></p><ul><li><strong>取指令</strong>：控制器从内存读取指令到 CPU。</li><li><strong>译码</strong>：分析指令功能（如加法、跳转）。</li><li><strong>执行</strong>：运算器完成操作，结果存入内存或寄存器。</li></ul></li><li><p><strong>输出</strong>：结果通过输出设备（如屏幕）显示。</p><hr></li></ol><h4 id="计算机工作基本原理" tabindex="-1"><a class="header-anchor" href="#计算机工作基本原理"><span>计算机工作基本原理</span></a></h4><p><img src="'+e+'" alt="image-20250316174337495"></p><p><img src="'+l+'" alt="image-20250404215904436"></p><p><img src="'+i+'" alt="image-20250316174428287"></p><p><img src="'+a+'" alt="image-20250316174449320"></p><p><img src="'+o+'" alt=""></p><p><img src="'+g+'" alt="image-20250316174625466"></p><hr><h4 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器"><span>寄存器</span></a></h4><h5 id="一、寄存器是什么" tabindex="-1"><a class="header-anchor" href="#一、寄存器是什么"><span><strong>一、寄存器是什么？</strong></span></a></h5><p><strong>定义</strong>：寄存器是 CPU 内部的 <strong>高速存储单元</strong>，用于 <strong>临时存放数据、指令或地址</strong>。 <strong>特点</strong>：</p><ul><li>访问速度极快（纳秒级，比内存快 100 倍以上）。</li><li>容量极小（通常每个 CPU 有几十个寄存器）。 <strong>比喻</strong>：类似你办公桌上的 <strong>临时小抽屉</strong>，存放你正在处理的文件（数据 / 指令），伸手就能拿到。</li></ul><h5 id="二、寄存器的分类与作用" tabindex="-1"><a class="header-anchor" href="#二、寄存器的分类与作用"><span><strong>二、寄存器的分类与作用</strong></span></a></h5><table><thead><tr><th><strong>寄存器类型</strong></th><th><strong>作用</strong></th><th><strong>典型例子</strong></th></tr></thead><tbody><tr><td><strong>通用寄存器</strong></td><td>存放临时数据、运算结果</td><td>AX（累加器）、BX（基址寄存器）</td></tr><tr><td><strong>程序计数器（PC）</strong></td><td>存储 <strong>下一条要执行的指令地址</strong></td><td>PC</td></tr><tr><td><strong>指令寄存器（IR）</strong></td><td>存放 <strong>当前正在执行的指令</strong></td><td>IR</td></tr><tr><td><strong>地址寄存器（MAR）</strong></td><td>存放 <strong>内存访问的地址</strong>（如读取数据或指令）</td><td>MAR</td></tr><tr><td><strong>状态寄存器（FLAGS）</strong></td><td>记录运算状态（如进位、溢出、零标志）</td><td>CF（进位标志）、ZF（零标志）</td></tr></tbody></table><hr><h4 id="校验码" tabindex="-1"><a class="header-anchor" href="#校验码"><span>校验码</span></a></h4><ul><li>CRC：<strong>模 2 运算</strong> 生成校验码，<strong>检错不纠错</strong>。</li><li>海明码：<strong>校验位定位错误</strong>，<strong>纠错能力强</strong>。</li><li>奇数校验：<strong>简单检错</strong>，但 <strong>可靠性低</strong>。</li></ul><h5 id="循环冗余校验-crc" tabindex="-1"><a class="header-anchor" href="#循环冗余校验-crc"><span>循环冗余校验（CRC）</span></a></h5><p><strong>循环冗余校验（CRC）</strong></p><ul><li><strong>核心原理</strong>：通过 <strong>多项式除法</strong>（模 2 运算）生成校验码，用于 <strong>检错</strong>。</li><li>常考点： <ul><li>生成多项式选择（如 CRC-16、CRC-32）。</li><li><strong>计算步骤</strong>：在数据后补 0，与生成多项式进行模 2 除法，余数即为校验码。</li><li><strong>检错能力</strong>：可检测 <strong>所有奇数位错误</strong> 和 <strong>突发错误</strong>（长度 ≤ 生成多项式位数）。</li></ul></li></ul><h5 id="海明码" tabindex="-1"><a class="header-anchor" href="#海明码"><span>海明码</span></a></h5><ul><li><strong>核心原理</strong>：通过插入 <strong>校验位</strong>（r 位），利用 <strong>奇偶校验</strong> 实现 <strong>纠错</strong>。</li><li>常考点： <ul><li>校验位位置：满足 <strong>2^r ≥ k + r + 1</strong>（k 为数据位，r 为校验位）。</li><li><strong>校验位计算</strong>：按位异或对应数据位。</li><li><strong>纠错过程</strong>：通过校验位组合定位错误位置。</li><li><strong>能力</strong>：可纠正 <strong>1 位错误</strong>，检测 <strong>2 位错误</strong>。</li></ul></li></ul><h5 id="奇数校验" tabindex="-1"><a class="header-anchor" href="#奇数校验"><span>奇数校验</span></a></h5><ul><li><p><strong>核心原理</strong>：使 <strong>数据位 + 校验位</strong> 的 1 的总数为 <strong>奇数</strong>。</p></li><li><p>常考点：</p><ul><li><p>校验位生成：根据数据位中 1 的个数确定（奇校验补 1，偶校验补 0）。</p></li><li><p><strong>局限性</strong>：仅能检测 <strong>奇数位错误</strong>，无法纠错。</p></li><li><p>应用场景：简单通信（如串口传输）。</p><hr></li></ul></li></ul><h4 id="原码补码反码移码" tabindex="-1"><a class="header-anchor" href="#原码补码反码移码"><span>原码补码反码移码</span></a></h4><h5 id="之间的相互转换" tabindex="-1"><a class="header-anchor" href="#之间的相互转换"><span>之间的相互转换</span></a></h5><ol><li><strong>原码</strong><ul><li><strong>定义</strong>：符号位（0 正 1 负）+ 数值绝对值的二进制表示。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1000 0110</code></li></ul></li><li><strong>转换规则</strong>：直接按符号位 + 数值转换。</li></ul></li><li><strong>反码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数符号位不变，其余位取反。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1001</code></li></ul></li><li><strong>转换规则</strong>：原码 → 反码（负数取反）。</li></ul></li><li><strong>补码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数为反码末位加 1。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1010</code></li></ul></li><li><strong>转换规则</strong>：反码 → 补码（末位 + 1）。</li></ul></li><li><strong>移码</strong><ul><li><strong>定义</strong>：补码符号位取反（常用于浮点数阶码）。</li><li>示例（8 位）： <ul><li>+6 → <code>1000 0110</code></li><li>-6 → <code>0111 1010</code></li></ul></li><li><strong>转换规则</strong>：补码 → 移码（符号位取反）。</li></ul></li></ol><h5 id="表示范围" tabindex="-1"><a class="header-anchor" href="#表示范围"><span>表示范围</span></a></h5><table><thead><tr><th>码制</th><th>整数范围</th><th>特殊值说明</th></tr></thead><tbody><tr><td>原码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1000 0000</code>）</td></tr><tr><td>反码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1111 1111</code>）</td></tr><tr><td>补码</td><td>-128 ~ +127</td><td>唯一 0（<code>0000 0000</code>），-128 表示为 <code>1000 0000</code></td></tr><tr><td>移码</td><td>-128 ~ +127</td><td>符号位取反，便于比较大小 唯一 0</td></tr></tbody></table><h5 id="真值计算" tabindex="-1"><a class="header-anchor" href="#真值计算"><span>真值计算</span></a></h5><ol><li><p><strong>原码转真值</strong></p><ul><li><code>1001 0101</code> → 符号位 1（负），数值 <code>001 0101</code> → -37。</li></ul></li><li><p><strong>补码转真值</strong></p><ul><li><code>1111 0101</code> → 符号位 1（负），取反得 <code>0000 1010</code>，加 1 得 <code>0000 1011</code> → -11。</li></ul></li><li><p><strong>移码转真值</strong></p><ul><li><code>0111 0101</code> → 符号位取反得补码 <code>1111 0101</code> → 真值 - 11。</li></ul><hr></li></ol><h4 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数"><span>浮点数</span></a></h4><p>浮点数在计算机中用以近似表示任意某个实数，一个浮点数 a 可如下表示: a = M*bE。</p><p><strong>尾数部分 M 的位数越多，数的精度越高。</strong></p><p><strong>指数部分 E 的位数越多，能表示的数值越大。</strong></p><p>因此在总长度固定的情况下，增加 E 的位数、减少 M 的位数可以扩大可表示的数的范围同时降低精度。</p><h5 id="定点表示和浮点表示" tabindex="-1"><a class="header-anchor" href="#定点表示和浮点表示"><span>定点表示和浮点表示</span></a></h5><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>定点表示</strong></td><td>小数点位置固定（如整数、纯小数），直接存储数值。</td><td>- 精度固定，范围小。 - 适合处理整数或固定精度小数。</td></tr><tr><td><strong>浮点表示</strong></td><td>采用科学计数法形式：<strong>尾数 × 基数 ^ 阶码</strong>（如 <code>±1.xxxxx×2^±yyy</code>）。</td><td>- 动态范围大，精度可变。 - 适合处理大范围数值（如科学计算）。</td></tr></tbody></table><h5 id="规格化" tabindex="-1"><a class="header-anchor" href="#规格化"><span>规格化</span></a></h5><p><strong>目的</strong>：使浮点数的表示唯一且有效位数最大化。 <strong>条件</strong>：</p><ul><li>原码规格化：尾数最高位必须为 1（避免前导零）。 <ul><li>例：<code>1.0101×2^3</code>（有效），<code>0.1010×2^4</code>（无效，需调整为 <code>1.010×2^3</code>）。</li></ul></li><li>补码规格化： <ul><li>正数：最高位为 1。</li><li>负数：最高位为 0（补码负数的绝对值最大，如 <code>1.0101</code> 表示 - 0.9375）。</li></ul></li></ul><p><strong>意义</strong>：消除冗余表示，提高精度。</p><h5 id="如何计算浮点数的表示范围" tabindex="-1"><a class="header-anchor" href="#如何计算浮点数的表示范围"><span>如何计算浮点数的表示范围</span></a></h5><hr><h4 id="与-或-异或-同或" tabindex="-1"><a class="header-anchor" href="#与-或-异或-同或"><span>与 或 异或 同或</span></a></h4><table><thead><tr><th><strong>输入 A</strong></th><th><strong>输入 B</strong></th><th><strong>与（AND）</strong></th><th><strong>或（OR）</strong></th><th><strong>异或（XOR）</strong></th><th><strong>同或（XNOR）</strong></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p><strong>关键规则说明</strong></p><ol><li><p><strong>与（AND）</strong>：只有 <strong>两个都为 1</strong> 时，结果才为 1。 → <strong>口诀</strong>：“有 0 则 0，全 1 才 1”。</p></li><li><p><strong>或（OR）</strong>：只要 <strong>有一个为 1</strong>，结果就为 1。 → <strong>口诀</strong>：“有 1 则 1，全 0 才 0”。</p></li><li><p><strong>异或（XOR）</strong>：两个值 <strong>不同</strong> 时结果为 1，相同则为 0。 → <strong>口诀</strong>：“不同为 1，相同为 0”。</p></li><li><p><strong>同或（XNOR）</strong>：两个值 <strong>相同</strong> 时结果为 1，不同则为 0。 → <strong>口诀</strong>：“相同为 1，不同为 0”（等同于异或结果取反）。</p><hr></li></ol><h4 id="冗余技术" tabindex="-1"><a class="header-anchor" href="#冗余技术"><span>冗余技术</span></a></h4><p>冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。通常冗余技术分为 4 类:</p><p>1.结构冗余，按其工作方法可以分为静态、动态和混合冗余;</p><p>2.信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息;</p><p>3.时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响;</p><p>4.冗余附件技术，是指为实现上述冗余技术所需的资源和技术。</p><hr><h3 id="存储系统" tabindex="-1"><a class="header-anchor" href="#存储系统"><span>存储系统</span></a></h3><h4 id="主存、辅存、cache" tabindex="-1"><a class="header-anchor" href="#主存、辅存、cache"><span>主存、辅存、cache</span></a></h4><table><thead><tr><th><strong>存储类型</strong></th><th><strong>全称</strong></th><th><strong>速度</strong></th><th><strong>容量</strong></th><th><strong>作用</strong></th><th><strong>典型设备</strong></th></tr></thead><tbody><tr><td><strong>Cache</strong></td><td>高速缓存</td><td>极快（纳秒级）</td><td>极小（MB 级）</td><td>缓解 CPU 与主存的速度差异</td><td>CPU 内置缓存</td></tr><tr><td><strong>主存</strong></td><td>主存储器</td><td>快（微秒级）</td><td>中等（GB 级）</td><td>CPU 直接访问的临时存储</td><td>内存条</td></tr><tr><td><strong>辅存</strong></td><td>辅助存储器</td><td>慢（毫秒级）</td><td>大（TB 级）</td><td>长期存储程序和数据</td><td>硬盘、SSD</td></tr></tbody></table><p><strong>主存主要采用动态随机存储器 DRAM</strong></p><p><strong>Cache 采用静态随机存储器 SRAM</strong></p><p><strong>EEPROM 是电擦除可编程的只读存储器</strong></p><p><strong>Cache 与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的。</strong></p><ol><li><p><strong>存储层次结构</strong></p><ul><li><strong>常考</strong>：Cache - 主存 - 辅存构成三级存储体系，速度递减、容量递增。</li></ul></li><li><p><strong>命中率优化</strong></p><ul><li><strong>示例</strong>：Cache 命中率越高，CPU 等待时间越少，性能越好。</li></ul></li><li><p><strong>虚拟内存技术</strong></p><ul><li><strong>常考</strong>：主存不足时，部分数据暂存到辅存（虚拟内存），但会导致速度下降。</li></ul></li></ol><h4 id="全相联、直接相连、组相连映射对比详解" tabindex="-1"><a class="header-anchor" href="#全相联、直接相连、组相连映射对比详解"><span>全相联、直接相连、组相连映射对比详解</span></a></h4><p><strong>一、核心概念</strong>**</p><ol><li><p><strong>直接相连映射（Direct Mapping）</strong></p><ul><li>主存块只能映射到 <strong>Cache 的唯一固定位置</strong>。</li><li>例如：主存块 0 → Cache 块 0，主存块 1 → Cache 块 1，依此类推。</li></ul></li><li><p><strong>组相连映射（Set Associative Mapping）</strong></p><ul><li>主存块映射到 Cache 的 <strong>某个组</strong>（如每组 4 块），组内块可自由选择。</li><li>例如：主存块 0 → Cache 组 0 的任意块（块 0-3）。</li></ul></li><li><p><strong>全相联映射（Fully Associative Mapping）</strong></p><ul><li>主存块可映射到 Cache 的 <strong>任意位置</strong>，无固定限制。</li></ul><p><strong>二、工作原理对比</strong></p><table><thead><tr><th><strong>映射方式</strong></th><th><strong>地址划分</strong></th><th><strong>查找逻辑</strong></th><th><strong>替换策略</strong></th></tr></thead><tbody><tr><td><strong>直接相连</strong></td><td>主存地址 = 块号 + 块内偏移</td><td>根据块号直接定位 Cache 块</td><td>固定替换（如覆盖）</td></tr><tr><td><strong>组相连</strong></td><td>主存地址 = 组号 + 块号 + 块内偏移</td><td>先定位组，再查找组内块</td><td>LRU、FIFO 等</td></tr><tr><td><strong>全相联</strong></td><td>主存地址 = 标签 + 块内偏移</td><td>遍历所有 Cache 块，对比标签</td><td>LRU、FIFO 等</td></tr></tbody></table><p><strong>三、特点对比表</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>直接相连</strong></th><th><strong>组相连</strong></th><th><strong>全相联</strong></th></tr></thead><tbody><tr><td><strong>映射规则</strong></td><td>固定位置</td><td>组内自由</td><td>完全自由</td></tr><tr><td><strong>冲突率</strong></td><td><strong>高</strong>（易地址冲突）</td><td><strong>中</strong></td><td><strong>低</strong></td></tr><tr><td><strong>查找速度</strong></td><td><strong>快</strong>（直接计算地址）</td><td><strong>中</strong>（组内搜索）</td><td><strong>慢</strong>（全 Cache 搜索）</td></tr><tr><td><strong>硬件复杂度</strong></td><td><strong>低</strong></td><td><strong>中</strong></td><td><strong>高</strong>（需全比较电路）</td></tr><tr><td><strong>典型应用</strong></td><td>片外 Cache、简单系统</td><td>一级 Cache、通用系统</td><td>小容量 Cache、高性能场景</td></tr></tbody></table></li></ol><h4 id="存储容量、存储块的计算方式" tabindex="-1"><a class="header-anchor" href="#存储容量、存储块的计算方式"><span>存储容量、存储块的计算方式</span></a></h4><h4 id="一、存储容量计算" tabindex="-1"><a class="header-anchor" href="#一、存储容量计算"><span><strong>一、存储容量计算</strong></span></a></h4><p><strong>存储容量</strong> 指存储器能存储的二进制信息总量，公式为： <strong>存储容量 = 存储单元数 × 每个单元的位数</strong></p><ul><li>若某存储器有 <strong>1024 个存储单元</strong>，每个单元 <strong>8 位</strong>，则总容量为： <code>1024 × 8 = 8192位 = 1024字节（1KB）</code></li><li>单位换算： <code>1KB=1024B</code>，<code>1MB=1024KB</code>，<code>1GB=1024MB</code>，依此类推。</li></ul><h4 id="二、存储块计算方式" tabindex="-1"><a class="header-anchor" href="#二、存储块计算方式"><span><strong>二、存储块计算方式</strong></span></a></h4><p><strong>存储块</strong> 是主存与 Cache 之间数据交换的最小单位，计算需明确：</p><ol><li><p><strong>主存总容量</strong></p></li><li><p><strong>块大小</strong>（主存与 Cache 的块大小必须一致）</p><p><strong>公式</strong>： <strong>主存块数量 = 主存总容量 ÷ 块大小</strong><strong>Cache 块数量 = Cache 总容量 ÷ 块大小</strong></p></li></ol><p><strong>示例</strong>：</p><ul><li>主存容量 <strong>1MB</strong>，块大小 <strong>16 字节</strong>： <code>1MB ÷ 16B = 65536块</code></li><li>Cache 容量 <strong>64KB</strong>，块大小 <strong>16 字节</strong>： <code>64KB ÷ 16B = 4096块</code></li></ul><h4 id="计算机的存储体系" tabindex="-1"><a class="header-anchor" href="#计算机的存储体系"><span>计算机的存储体系</span></a></h4><p>计算机中不同容量、不同速度、不同访问形式、不同用途的各种存储器形成的是一种层次结构的存储系统。所有的存储器设备按照一定的层次逻辑关系通过软硬件连接起来，并进行有效的管理，就形成了存储体系。不同层次上的存储器发挥着不同的作用。</p><p>一般计算机系统中主要有两种存储体系:</p><p>Cache 存储体系由 Cache 和主存储器构成，主要目的是提高存储器速度，对系统程序员以上均透明; 虚拟存储体系由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明。</p><h4 id="存储体系中的存储器" tabindex="-1"><a class="header-anchor" href="#存储体系中的存储器"><span>存储体系中的存储器</span></a></h4><p>按访问方式可分为按 <strong>地址访问的存储器</strong> 和 <strong>按内容访问的存储器</strong>;</p><p>按寻址方式分类可分为 <strong>随机存储器</strong>、<strong>顺序存储器</strong> 和 <strong>直接存储器</strong>。</p><ul><li><p>随机存储器(Random AccessMemory，<strong>RAM</strong>)指可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间是相同的。</p></li><li><p>顺序存储器(Sequentially AddressedMemory，SAM)指访问数据所需要的时间与数据所在的存储位置相关，磁带是典型的顺序存储器。</p></li><li><p>直接存储器(Direct AddressedMemory，<strong>DAM</strong>)是介于随机存取和顺序存取之间的一种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而在一个磁道内，则是顺序寻址。</p></li></ul><p>按照内容访问可分为相联存储器</p><ul><li>相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，将该关键字与存储器中的每一单元进行比较，从而找出存储器中所有与关键字相同的数据字。</li></ul><h3 id="总线系统" tabindex="-1"><a class="header-anchor" href="#总线系统"><span>总线系统</span></a></h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h4><p>总线（Bus）是一组信号线组成的传输线束，它作为计算机各种功能部件之间传送信息的公共通信干线。根据计算机所传输的信息种类，总线可以分为数据总线、地址总线和控制总线。</p><ul><li><strong>数据总线（Data Bus）</strong>：用于在 CPU 与 RAM 之间来回传送需要处理或是需要储存的数据。它是双向的，意味着数据可以在两个方向上传输。</li><li><strong>地址总线（Address Bus）</strong>：用来指定在 RAM 之中储存的数据的地址。它是单向的，从 CPU 发出到内存或其他设备。</li><li><strong>控制总线（Control Bus）</strong>：将微处理器控制单元的信号传送到周边设备，如 USB Bus 和 1394 Bus 等。</li></ul><p><strong>总线的分类</strong></p><p>总线可以根据其所在位置、传输方式和工作模式进行分类：</p><ul><li><p><strong>按位置分</strong>：</p><ul><li>内部总线（片内总线）：存在于 CPU 芯片内部，用于寄存器之间和算术逻辑部件 ALU 与控制部件之间的数据传输。</li><li>系统总线（板级总线）：连接微机各插件板与系统板之间的总线，实现插件板一级的互联。</li><li>外部总线（通信总线）：连接计算机与其他外部设备或系统之间的总线。</li></ul></li><li><p><strong>按传输方式分</strong>：</p><ul><li>并行总线：多位数据同时通过多条线路传输，适合短距离高速数据传输。</li><li>串行总线：数据一位接一位地顺序传输，适用于长距离传输，成本较低且抗干扰能力强。</li></ul></li><li><p><strong>按工作模式分</strong>：</p><ul><li>单工：数据只能在一个方向上传输。</li><li>半双工：允许数据双向传输，但同一时间只能在一个方向上进行。</li><li>全双工：支持数据同时双向传输。</li></ul></li></ul><p><strong>总线性能指标</strong></p><p>了解总线的性能指标对于评估系统的效率至关重要。主要的性能指标包括：</p><ul><li><strong>带宽（Bandwidth）</strong>：指总线每秒可以传输的最大数据量，通常以位/秒（bps）或字节/秒（Bps）表示。</li><li><strong>总线速度（Bus Speed）</strong>：即总线的时钟频率，决定了每秒能进行多少次数据传输周期。</li><li><strong>总线协议（Bus Protocol）</strong>：定义了总线上的设备如何进行通信的具体规则。</li><li><strong>总线仲裁（Bus Arbitration）</strong>：当多个设备尝试同时访问总线时，决定哪个设备获得优先权的机制。</li></ul><p><strong>总线设计考虑因素</strong></p><p>在选择或设计总线时，需要综合考虑以下因素：</p><ul><li>数据传输速率的需求。</li><li>可靠性和稳定性，尤其是在高负载情况下。</li><li>成本效益分析，包括硬件成本和维护成本。</li><li>电磁兼容性（EMC），特别是在并行总线设计中尤为重要。</li></ul><h4 id="总线结构" tabindex="-1"><a class="header-anchor" href="#总线结构"><span>总线结构</span></a></h4><h5 id="单总线结构-single-bus-architecture" tabindex="-1"><a class="header-anchor" href="#单总线结构-single-bus-architecture"><span><strong>单总线结构（Single Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>所有设备共享一条单一总线（数据、地址、控制信号复用）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：简单、成本低、易于扩展。</li><li><strong>缺点</strong>：带宽瓶颈（多设备竞争）、延迟高。</li></ul></li><li><p><strong>应用场景</strong>：早期微型计算机（如 8 位 / 16 位系统）、嵌入式系统。</p></li></ul><h5 id="_2-双总线结构-dual-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_2-双总线结构-dual-bus-architecture"><span><strong>2. 双总线结构（Dual Bus Architecture）</strong></span></a></h5><ul><li><p>结构分为</p><p>系统总线（连接 CPU、内存）和 I/O 总线（连接外设）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：分离高速与低速设备，减少冲突。</li><li><strong>缺点</strong>：需通过桥接器（如北桥芯片）中转，增加延迟。</li></ul></li><li><p><strong>应用场景</strong>：传统 x86 架构计算机（如 PCI 总线与 ISA 总线并存）。</p></li></ul><h5 id="_3-多总线结构-multi-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_3-多总线结构-multi-bus-architecture"><span><strong>3. 多总线结构（Multi-Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>多级总线分层连接，如高速总线（如 PCIe）连接 CPU 与显卡，低速总线（如 USB）连接外设。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：优化带宽分配，支持高速设备（如 GPU、SSD）。</li><li><strong>缺点</strong>：复杂度高，需总线控制器协调。</li></ul></li><li><p><strong>应用场景</strong>：现代服务器、高性能计算机。</p></li></ul><h5 id="_4-层次化总线结构-hierarchical-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_4-层次化总线结构-hierarchical-bus-architecture"><span><strong>4. 层次化总线结构（Hierarchical Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>总线按层次划分，如：</p><ol><li><strong>片内总线</strong>（SoC 内部，如 AMBA AHB/AXI）；</li><li><strong>系统总线</strong>（主板级，如 PCIe）；</li><li><strong>外部总线</strong>（外设级，如 USB）。</li></ol></li><li><p>特点</p><ul><li><strong>优点</strong>：分层管理，提升整体性能。</li><li><strong>缺点</strong>：依赖协议兼容性（如 PCIe 与 USB 的转换）。</li></ul></li><li><p><strong>应用场景</strong>：智能手机 SoC（如骁龙芯片）、个人计算机。</p></li></ul><h5 id="_5-专用总线结构" tabindex="-1"><a class="header-anchor" href="#_5-专用总线结构"><span><strong>5. 专用总线结构</strong></span></a></h5><ul><li><p>示例</p><ul><li><strong>内存总线</strong>：专用连接 CPU 与内存（如 DDR4/DDR5）；</li><li><strong>存储总线</strong>：连接存储控制器与硬盘（如 SATA、NVMe）。</li></ul></li><li><p>特点</p><ul><li><strong>优点</strong>：针对特定设备优化，高带宽、低延迟。</li><li><strong>缺点</strong>：通用性差。</li></ul><p><strong>总线结构的性能对比</strong></p><table><thead><tr><th><strong>结构类型</strong></th><th><strong>带宽</strong></th><th><strong>延迟</strong></th><th><strong>扩展性</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td>单总线</td><td>低</td><td>高</td><td>有限</td><td>嵌入式系统、早期微机</td></tr><tr><td>双总线</td><td>中</td><td>中</td><td>中等</td><td>传统 PC（已淘汰）</td></tr><tr><td>多总线</td><td>高</td><td>低</td><td>强</td><td>服务器、游戏 PC</td></tr><tr><td>层次化总线</td><td>极高</td><td>极低</td><td>极强</td><td>智能手机 SoC、高性能计算</td></tr></tbody></table></li></ul><h4 id="总线带宽计算" tabindex="-1"><a class="header-anchor" href="#总线带宽计算"><span>总线带宽计算</span></a></h4><p><strong>总线带宽 = 总线宽度 × 时钟频率</strong></p><p>假设我们有一个 32 位宽的总线，并且它的时钟频率是 200MHz，那么根据上述公式，我们可以这样计算总线带宽：</p><p>总线带宽 = 32 bits×200 MHz = 6400 Mbits/s</p><p>但是，因为数据传输率通常以字节（Byte）而非比特（bit）来表示，我们需要将结果转换成字节形式。由于 1 字节等于 8 比特，所以：</p><p>总线带宽 = 64008 MB/s = 800 MB/s</p><p>或者，如果我们想要将其转换为 GB/s，则需要进一步除以 1024：</p><p>总线带宽 = 8001024 GB/s≈0.78 GB/s</p><h3 id="输入输出系统" tabindex="-1"><a class="header-anchor" href="#输入输出系统"><span>输入输出系统</span></a></h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h4><ol><li><p><strong>输入输出定义</strong></p><ul><li><strong>输入</strong>：数据从外部设备传入计算机（如键盘、扫描仪）。</li><li><strong>输出</strong>：数据从计算机传出到外部设备（如显示器、打印机）。</li></ul></li><li><p><strong>输入输出系统组成</strong></p><ul><li><strong>外设</strong>：输入 / 输出设备（如磁盘、网卡）。</li><li><strong>I/O 接口</strong>：连接 CPU 与外设的桥梁，含数据、状态、控制寄存器。</li><li><strong>总线</strong>：系统总线（地址、数据、控制）用于传输信号。</li></ul></li></ol><h4 id="数据传送方式" tabindex="-1"><a class="header-anchor" href="#数据传送方式"><span>数据传送方式</span></a></h4><ol><li><p><strong>无条件传送</strong></p><ul><li>CPU 直接读写外设，无需状态查询。</li><li><strong>适用场景</strong>：简单外设（如开关、LED）。</li></ul></li><li><p><strong>查询传送</strong></p><ul><li>CPU 循环检测外设状态，就绪后传输数据。</li><li><strong>优点</strong>：实现简单；<strong>缺点</strong>：CPU 利用率低。</li></ul></li><li><p><strong>中断方式</strong></p><ul><li>外设主动向 CPU 发送中断请求，CPU 暂停当前任务处理中断。</li><li><strong>优点</strong>：CPU 利用率高；<strong>缺点</strong>：需处理中断上下文切换。</li></ul></li><li><p><strong>DMA（直接内存访问）</strong></p><ul><li>外设直接访问内存，无需 CPU 干预。</li><li><strong>优点</strong>：高速传输，适合大块数据（如磁盘读写）；<strong>缺点</strong>：硬件成本高。</li><li><strong>常考对比</strong>：DMA 与中断的区别（CPU 是否参与数据传输）。</li></ul></li></ol><h4 id="中断嵌套" tabindex="-1"><a class="header-anchor" href="#中断嵌套"><span>中断嵌套</span></a></h4><p>当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为中断嵌套。</p><p><strong>实现中断嵌套用后进先出的栈来保护断点和现场最有效。</strong></p><h3 id="指令系统和计算机体系结构" tabindex="-1"><a class="header-anchor" href="#指令系统和计算机体系结构"><span>指令系统和计算机体系结构</span></a></h3><h4 id="程序的局部性" tabindex="-1"><a class="header-anchor" href="#程序的局部性"><span>程序的局部性</span></a></h4><p><strong>一、核心概念</strong></p><p>程序的局部性原理是指 <strong>程序在执行时倾向于访问 *<em>*</em> 近期使用过的数据或指令</strong>，以及 <strong>邻近的数据或指令</strong>。这一特性是计算机系统设计（如缓存、虚拟内存）的基础，也是程序优化的重要依据。</p><p><strong>二、局部性分类</strong></p><ol><li><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据或指令被访问，那么在 <strong>不久的将来</strong> 很可能再次被访问。</li><li>示例 <ul><li>循环中的变量（如 <code>for (int i=0; i&lt;1000; i++)</code> 中的 <code>i</code>）。</li><li>函数调用中的局部变量（多次被使用）。</li></ul></li></ul></li><li><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><p><strong>定义</strong>：如果一个数据或指令被访问，那么与其 <strong>相邻的内存区域</strong> 的数据或指令也可能很快被访问。</p></li><li><p>示例</p><ul><li>连续存储的数组元素（如 <code>arr[0], arr[1], arr[2]</code>）。</li><li>代码中的顺序执行（如连续的指令块）。</li></ul></li></ul></li></ol><h5 id="精简指令系统和复杂指令系统" tabindex="-1"><a class="header-anchor" href="#精简指令系统和复杂指令系统"><span>精简指令系统和复杂指令系统</span></a></h5><ol><li><p><strong>RISC（精简指令系统）</strong></p><ul><li><strong>设计理念</strong>：简化指令集，通过减少指令种类和复杂度提升执行效率。</li><li><strong>典型代表</strong>：ARM、MIPS、RISC-V。</li></ul></li><li><p><strong>CISC（复杂指令系统）</strong></p><ul><li><p><strong>设计理念</strong>：提供丰富复杂的指令，通过单条指令完成复杂操作以减少代码量。</p></li><li><p><strong>典型代表</strong>：x86（如 Intel/AMD 处理器）。</p></li></ul></li></ol><table><thead><tr><th><strong>对比项</strong></th><th style="text-align:center;"><strong>RISC</strong></th><th><strong>CISC</strong></th></tr></thead><tbody><tr><td><strong>指令数量</strong></td><td style="text-align:center;">少（约 100 条以内）</td><td>多（可达数百条）</td></tr><tr><td><strong>指令长度</strong></td><td style="text-align:center;">固定（便于流水线处理）</td><td>可变（复杂指令长度不同）</td></tr><tr><td><strong>执行周期</strong></td><td style="text-align:center;">单周期执行</td><td>多周期执行</td></tr><tr><td><strong>内存访问</strong></td><td style="text-align:center;">仅 LOAD/STORE 指令访问内存</td><td>指令可直接操作内存</td></tr><tr><td><strong>流水线效率</strong></td><td style="text-align:center;">高（指令简单，并行性强）</td><td>低（指令复杂，易阻塞流水线）</td></tr><tr><td><strong>硬件复杂度</strong></td><td style="text-align:center;">低（无需微程序控制）</td><td>高（需微程序解析复杂指令）</td></tr><tr><td><strong>编译器依赖</strong></td><td style="text-align:center;">高（依赖编译器优化）</td><td>低（指令功能强，编程灵活）</td></tr></tbody></table><h4 id="流水线概念以及常见计算" tabindex="-1"><a class="header-anchor" href="#流水线概念以及常见计算"><span>流水线概念以及常见计算</span></a></h4><p><strong>一、吞吐率定义</strong></p><ul><li><strong>概念</strong>：单位时间内完成的指令数量（或任务数），衡量流水线的处理效率。</li><li><strong>公式</strong>： <strong>吞吐率（TP）= 指令数（n） / 总执行时间（T）</strong> 单位：指令数 / 时间单位（如条 / 秒、条 /ns）。</li></ul><p><strong>二、流水线吞吐率计算</strong></p><ol><li><p><strong>最大吞吐率（理想情况）</strong></p><ul><li>当流水线完全填满后，每周期完成一条指令。<strong>最长执行时间的倒数</strong></li><li><strong>公式</strong>： <strong>最大吞吐率（TP_max）= 1 / 最长阶段时间（Δt_max）</strong></li><li><strong>示例</strong>：最长阶段时间为 3ns → TP_max ≈ 0.33 条 /ns。</li></ul></li><li><p><strong>实际吞吐率（考虑指令数）</strong></p><ul><li><strong>公式</strong>： <strong>TP = n / [ (k + n -1) × Δt_max ]</strong> （k 为阶段数，n 为指令数）</li><li><strong>示例</strong>：k = 5，n = 100，Δt_max = 3ns → TP = 100 / 312 ≈ 0.32 条 /ns。</li></ul></li></ol><h4 id="vliw-超长指令字" tabindex="-1"><a class="header-anchor" href="#vliw-超长指令字"><span>VLIW（超长指令字）</span></a></h4><p>一种非常长的指令组合，把许多条指令连在一起增加运算速度。</p><h4 id="寻址方式" tabindex="-1"><a class="header-anchor" href="#寻址方式"><span>寻址方式</span></a></h4><p>采用不同寻址方式的目的是为了扩大寻址空间提高编程灵活性</p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>立即寻址</strong></td><td>操作数直接包含在指令中</td><td><code>ADD R0, #5</code>（R0 += 5）</td><td>无需内存访问，速度快，但操作数范围受限（受指令长度限制）。</td></tr><tr><td><strong>直接寻址</strong></td><td>指令中包含内存地址</td><td><code>LOAD R1, [0x1000]</code>（R1 = 内存 0x1000）</td><td>地址固定，适合访问静态数据，但地址空间有限（需完整地址位）。</td></tr><tr><td><strong>寄存器寻址</strong></td><td>操作数存于寄存器中</td><td><code>ADD R0, R1</code>（R0 += R1）</td><td>速度最快，RISC 架构核心方式（如 ARM、RISC-V）。</td></tr><tr><td><strong>寄存器间接寻址</strong></td><td>寄存器存储内存地址</td><td><code>LOAD R2, [R3]</code>（R2 = 内存 [R3]）</td><td>灵活访问动态数据，适合数组、指针操作。</td></tr><tr><td><strong>基址寻址</strong></td><td>基址寄存器 + 偏移量确定地址</td><td><code>LOAD R4, [R5+0x20]</code>（R4 = 内存 [R5+32]）</td><td>简化数组、结构体访问，支持内存分段管理。</td></tr><tr><td><strong>变址寻址</strong></td><td>变址寄存器 + 偏移量确定地址</td><td><code>LOAD R6, [0x1000+R7]</code>（R6 = 内存 [2560 + R7]）</td><td>适合循环遍历数组，偏移量固定，寄存器动态调整。</td></tr><tr><td><strong>相对寻址</strong></td><td>当前指令地址 + 偏移量确定地址</td><td><code>JMP 0x10</code>（跳转到当前地址 + 16）</td><td>常用于分支指令，节省地址空间（只需偏移量）。</td></tr></tbody></table><p><strong>典型应用场景</strong></p><ol><li><strong>立即寻址</strong>：初始化常量、简单运算。</li><li><strong>寄存器间接寻址</strong>：动态数据访问（如链表、堆内存）。</li><li><strong>基址 + 变址寻址</strong>：二维数组、结构体成员访问。</li><li><strong>相对寻址</strong>：程序跳转（如函数调用、条件分支）。</li></ol><h4 id="寻址范围计算" tabindex="-1"><a class="header-anchor" href="#寻址范围计算"><span>寻址范围计算</span></a></h4><p>范围 = 内存容量/字节长度</p><h4 id="flynn-分类法" tabindex="-1"><a class="header-anchor" href="#flynn-分类法"><span>flynn 分类法</span></a></h4><p><strong>Flynn 分类法定义</strong></p><ul><li><p><strong>提出背景</strong>：由 Michael J. Flynn 于 1966 年提出，用于 <strong>根据指令流（Instruction Stream）和数据流（Data Stream）的并行性</strong> 对计算机体系结构进行分类。</p></li><li><p>核心维度：</p><ol><li><strong>指令流并行性</strong>：是否同时执行多条指令。</li><li><strong>数据流并行性</strong>：是否同时处理多个数据项。</li></ol><h4 id="flynn-分类法四大类型" tabindex="-1"><a class="header-anchor" href="#flynn-分类法四大类型"><span><strong>Flynn 分类法四大类型</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>全称</strong></th><th><strong>指令流</strong></th><th><strong>数据流</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>SISD</strong></td><td>单指令流单数据流</td><td>单指令</td><td>单数据</td><td>传统串行计算机，无并行处理能力。</td><td>早期个人计算机（如 8086）</td></tr><tr><td><strong>SIMD</strong></td><td>单指令流多数据流</td><td>单指令</td><td>多数据</td><td>一条指令操作多个数据（数据级并行）。</td><td>GPU、向量处理器（如 Intel AVX）</td></tr><tr><td><strong>MISD</strong></td><td>多指令流单数据流</td><td>多指令</td><td>单数据</td><td>理论上存在，实际应用极少（可能用于容错处理）。</td><td>研究原型（如某些纠错系统）</td></tr><tr><td><strong>MIMD</strong></td><td>多指令流多数据流</td><td>多指令</td><td>多数据</td><td>多条指令独立操作多个数据（任务级并行）。</td><td>多核 CPU、分布式计算集群</td></tr></tbody></table></li></ul><h3 id="系统性能评测和可靠性基础" tabindex="-1"><a class="header-anchor" href="#系统性能评测和可靠性基础"><span>系统性能评测和可靠性基础</span></a></h3><h4 id="系统可靠度计算" tabindex="-1"><a class="header-anchor" href="#系统可靠度计算"><span>系统可靠度计算</span></a></h4><p>可靠度表示为 R</p><p><strong>串联</strong>: R 相乘</p><p><strong>示例</strong>：R1 = 0.9, <em>R</em> 2 = 0.95, <em>R</em> 3 = 0.98。</p><p><em>R</em> 串联 = 0.9×0.95×0.98 = 0.8379(83.79%)</p><p><strong>并联:</strong></p><p>两个并联为 1-(1-R)²</p><p>R = 0.9</p><p>R 并联 = 1−(0.1×0.1)= 0.99(99%)</p><p><img src="'+h+`" alt="image-20250405110413577"></p><p>可靠度为（1-（1-R）³）（1-（1-R）²）</p><h2 id="程序语言" tabindex="-1"><a class="header-anchor" href="#程序语言"><span>程序语言</span></a></h2><h3 id="程序设计语言基础概念" tabindex="-1"><a class="header-anchor" href="#程序设计语言基础概念"><span>程序设计语言基础概念</span></a></h3><h4 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念"><span>核心概念</span></a></h4><ol><li><p><strong>低级语言 vs 高级语言</strong></p><ul><li><strong>低级语言</strong>：机器语言（二进制指令）、汇编语言（符号指令），执行效率高但开发效率低。</li><li><strong>高级语言</strong>：Java、C、Python 等，接近自然语言，开发效率高但需翻译（编译 / 解释）。</li></ul></li><li><p><strong>编译程序 vs 解释程序</strong></p><ul><li><strong>编译程序</strong>：一次性生成目标程序（如.exe 文件），执行效率高，不可调试。</li><li><strong>解释程序</strong>：边翻译边执行，开发灵活但效率低（如 Python、JavaScript）。</li></ul></li><li><p><strong>语言三要素</strong></p><ul><li><p><strong>语法</strong>：结构规则（如括号匹配、分号结尾）。</p></li><li><p><strong>语义</strong>：逻辑含义（如变量类型是否匹配）。</p></li><li><p><strong>语用</strong>：符号与使用者的关系（如注释、代码规范）。</p></li></ul></li></ol><h4 id="语言处理程序基础" tabindex="-1"><a class="header-anchor" href="#语言处理程序基础"><span>语言处理程序基础</span></a></h4><ul><li><strong>词法分析</strong>：识别单词符号（如关键字、标识符）。</li><li><strong>语法分析</strong>：检查语法结构（如表达式是否合法）。</li><li><strong>语义分析</strong>：类型检查（如整数与字符串相加错误）。</li><li><strong>中间代码生成</strong>：转换为与机器无关的代码（如逆波兰式、四元式）。</li><li><strong>代码优化</strong>：提升执行效率（如循环展开、冗余删除）。</li><li><strong>目标代码生成</strong>：输出机器语言或汇编代码。</li></ul><h4 id="程序设计语言基本成分" tabindex="-1"><a class="header-anchor" href="#程序设计语言基本成分"><span>程序设计语言基本成分</span></a></h4><ol><li><p><strong>数据成分</strong></p><ul><li><strong>常量 / 变量</strong>：全局量（静态存储） vs 局部量（动态存储）。</li><li><strong>数据类型</strong>：基本类型（int、char）、构造类型（数组、结构体）、抽象类型（类）。</li></ul></li><li><p><strong>控制成分</strong></p><ul><li><strong>条件语句</strong>：<code>if-else</code>、<code>switch-case</code>。</li><li><strong>循环语句</strong>：<code>for</code>、<code>while</code>、<code>do-while</code>。</li><li><strong>函数调用</strong>: <ul><li><strong>值调用</strong>：形参修改不影响实参。</li><li><strong>引用调用</strong>：形参修改直接影响实参（如 C++ 的指针）。</li></ul></li></ul></li><li><p><strong>运算成分</strong></p><ul><li><p><strong>运算符优先级</strong>：如 <code>*</code> 高于 <code>+</code>。</p></li><li><p><strong>逻辑运算</strong>：<code>&amp;&amp;</code>（短路与）、<code>||</code>（短路或）、<code>!</code>。</p></li></ul></li></ol><h4 id="核心传递方式对比-软考高频" tabindex="-1"><a class="header-anchor" href="#核心传递方式对比-软考高频"><span><strong>核心传递方式对比（软考高频）</strong></span></a></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>定义</strong></th><th><strong>语言示例</strong></th><th><strong>是否修改实参</strong></th><th><strong>常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>值调用</strong></td><td>传递参数副本，函数内修改不影响实参。</td><td>C 的普通参数、Java 基本类型</td><td>❌ 否</td><td>交换函数无效（如 <code>swap(int a, int b)</code> 无法交换实参）。</td></tr><tr><td><strong>引用调用</strong></td><td>传递实参地址（或别名），函数内修改直接影响实参。</td><td>C++ 引用（<code>&amp;</code>）、C# <code>ref</code>/<code>out</code></td><td>✅ 是</td><td>Java 对象引用是 “值传递的引用”：可修改对象属性，但无法改变引用指向（如无法交换两个对象）。</td></tr><tr><td><strong>指针传递</strong></td><td>传递指针变量（地址的副本），通过解引用修改实参。</td><td>C 的指针（<code>int*</code>）</td><td>✅ 是</td><td>区分 “传递指针” 与 “传递指针指向的值”：<code>func(int* p)</code> 可改 <code>*p</code>，但无法改 <code>p</code> 本身（如交换指针无效）。</td></tr><tr><td><strong>传名调用</strong></td><td>参数在调用处替换为表达式，可能多次求值（已过时，软考仅考概念）。</td><td>Algol、早期 Pascal</td><td>✅ 可能</td><td>副作用：表达式含自增（如 <code>a++</code>）时，多次求值导致结果不可控。</td></tr></tbody></table><p><strong>典型语言实现与常考细节</strong></p><ol><li><strong>C 语言</strong><ul><li><strong>值调用</strong>：默认方式，如 <code>void f(int x) { x=5; }</code>，调用后实参不变。</li><li><strong>指针传递</strong>：需显式传递地址，如 <code>void f(int* x) { *x=5; }</code>，调用 <code>f(&amp;a)</code> 修改 <code>a</code>。</li><li><strong>常考题</strong>：交换函数必须用指针，否则无效。</li></ul></li><li><strong>C++</strong><ul><li><strong>引用调用</strong>：<code>void f(int&amp; x) { x=5; }</code>，实参直接被修改。</li><li><strong>区别指针</strong>：引用必须初始化，且语法更简洁（无需 <code>*</code>）。</li></ul></li><li><strong>Java</strong><ul><li><strong>基本类型</strong>：值调用，如 <code>void f(int x)</code> 无法修改实参。</li><li><strong>对象类型</strong>：传递对象引用的副本（值调用的引用），可修改对象属性（如 <code>obj.name=&quot;new&quot;</code>），但无法改变引用指向（如无法通过函数让 <code>obj</code> 指向新对象）。</li><li><strong>常考题</strong>：判断 “Java 的对象传递是引用调用” 是否正确（错误，本质是值传递的引用）。</li></ul></li><li><strong>C#</strong><ul><li><strong><code>ref</code></strong>：引用调用，实参需初始化，如 <code>void f(ref int x) { x=5; }</code>。</li><li><strong><code>out</code></strong>：强制函数内赋值，用于 “输出参数”，如 <code>void f(out int x) { x=5; }</code>。</li></ul></li><li><strong>Python</strong><ul><li><strong>可变对象（列表、字典）</strong>：值调用传递对象引用，可修改内容（如 <code>lst.append(3)</code>），但无法重新赋值（如 <code>lst = [1,2]</code> 不影响实参）。</li><li><strong>不可变对象（整数、字符串）</strong>：值调用，修改无效。</li></ul></li></ol><h4 id="语言分类以及特点" tabindex="-1"><a class="header-anchor" href="#语言分类以及特点"><span>语言分类以及特点</span></a></h4><table><thead><tr><th><strong>分类</strong></th><th><strong>代表语言</strong></th><th><strong>核心特点</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><strong>命令式语言</strong></td><td>C、Java、C#、C++</td><td>强调算法步骤，支持变量和控制流（顺序、分支、循环），分面向过程和面向对象。</td><td>C：系统开发、嵌入式；Java/C#：企业级应用、Android 开发；C++：游戏引擎、桌面软件。</td></tr><tr><td><strong>函数式语言</strong></td><td>Haskell、Lisp、Scala</td><td>纯函数、不可变性、惰性求值，强调数学计算逻辑。</td><td>Haskell：金融计算；Lisp：早期 AI；Scala：大数据处理（Spark）。</td></tr><tr><td><strong>逻辑式语言</strong></td><td>Prolog</td><td>基于一阶逻辑，声明性编程，自动推理。</td><td>专家系统、自然语言处理、数据库查询优化。</td></tr><tr><td><strong>脚本语言</strong></td><td>Python、JavaScript、PHP</td><td>动态类型、语法简洁、解释执行，开发效率高。</td><td>Python：数据分析、AI；JavaScript：Web 全栈；PHP：中小型 Web 应用。</td></tr><tr><td><strong>科学计算语言</strong></td><td>Fortran、MATLAB</td><td>高效数值计算，支持矩阵运算和可视化。</td><td>Fortran：工程模拟；MATLAB：信号处理、控制系统设计。</td></tr><tr><td><strong>现代语言</strong></td><td>Go、Swift、Rust</td><td>高性能、安全性、简洁语法，支持并发或特定场景优化。</td><td>Go：云服务（Docker）；Swift：iOS 开发；Rust：区块链、内存安全服务端。</td></tr><tr><td><strong>其他重要语言</strong></td><td>SQL</td><td>非过程化，面向数据操作，声明式查询。</td><td>数据库管理、数据检索与分析。</td></tr></tbody></table><h4 id="错误类型分类" tabindex="-1"><a class="header-anchor" href="#错误类型分类"><span>错误类型分类</span></a></h4><table><thead><tr><th><strong>错误类型</strong></th><th><strong>定义</strong></th><th><strong>典型示例</strong></th><th><strong>语言示例</strong></th><th><strong>软考常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>语法错误</strong></td><td>违反编程语言的语法规则，无法通过编译。</td><td>缺少分号、括号不匹配、关键字拼写错误</td><td>C、Java、Python 编译阶段报错</td><td>注意中文符号（如 “；” 代替 “;”）导致的隐藏错误。</td></tr><tr><td><strong>类型错误</strong></td><td>操作符与操作数类型不匹配，编译阶段检查。</td><td>字符串与整数相加、数组越界</td><td>C 的 <code>int + char</code>、Java 的 <code>String s = 123</code></td><td>注意自动类型转换（如 C 的 <code>char</code> 转 <code>int</code>）可能掩盖类型错误。</td></tr><tr><td><strong>语义错误</strong></td><td>语法正确但逻辑含义错误，导致程序行为不符合预期。</td><td>条件判断错误、算法逻辑错误</td><td>错误的循环终止条件、错误的公式计算</td><td>软考常考 “逻辑错误” 与 “运行时错误” 的区分：逻辑错误可能在运行时才暴露。</td></tr><tr><td><strong>运行时错误</strong></td><td>程序运行期间发生的错误，通常导致程序崩溃或异常。</td><td>除零错误、空指针解引用、数组越界</td><td>C 的 <code>NULL指针解引用</code>、Java 的 <code>NullPointerException</code></td><td>注意 Java 的 “受检异常” 与 “非受检异常” 区别（如 <code>IOException</code> 需显式处理）。</td></tr><tr><td><strong>链接错误</strong></td><td>编译通过但链接阶段找不到符号（如未定义的函数或变量）。</td><td>函数声明与实现不匹配、库文件缺失</td><td>C 的 <code>undefined reference to &#39;func&#39;</code></td><td>软考可能结合编译流程考查链接错误的原因（如函数名大小写不一致）。</td></tr><tr><td><strong>逻辑错误</strong></td><td>算法设计错误，导致结果不正确但程序不崩溃。</td><td>排序算法错误、错误的业务逻辑</td><td>冒泡排序中的循环次数错误</td><td>逻辑错误是软考重点考查对象，需通过测试用例发现（如错误的闰年判断条件）。</td></tr></tbody></table><h4 id="典型错误类型解析与常考细节" tabindex="-1"><a class="header-anchor" href="#典型错误类型解析与常考细节"><span><strong>典型错误类型解析与常考细节</strong></span></a></h4><ol><li><p><strong>语法错误</strong></p><ul><li><p><strong>特点</strong>：编译阶段直接报错，必须修复才能运行。</p></li><li><p>示例</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 缺少分号（语法错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：混淆 “语法错误” 与 “语义错误”，例如 <code>if (a = 0)</code> 是语法正确但语义错误（应为 <code>a == 0</code>）。</p></li></ul></li><li><p><strong>运行时错误</strong></p><ul><li><p>分类</p><ul><li><strong>异常</strong>：可捕获处理（如 Java 的 <code>try-catch</code>）。</li><li><strong>崩溃</strong>：不可恢复（如 C 的除零错误直接终止程序）。</li></ul></li><li><p>示例</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数组越界（运行时错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考常考</strong>：Java 的 <code>ArrayIndexOutOfBoundsException</code> 属于运行时错误，而 C 的数组越界可能导致未定义行为。</p></li></ul></li><li><p><strong>逻辑错误</strong></p><ul><li><p><strong>隐蔽性</strong>：程序正常运行但结果错误，需通过测试发现。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">def</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> is_leap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">year</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> year </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">%</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 错误，未处理整百年（软考经典逻辑错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考重点</strong>：算法设计题中常见，如错误的循环条件导致结果偏差。</p></li></ul></li><li><p><strong>类型错误</strong></p><ul><li><p><strong>静态类型语言</strong>（如 C、Java）：编译阶段检查。</p></li><li><p><strong>动态类型语言</strong>（如 Python）：运行时检查。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 运行时类型错误（Python）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：Java 的自动拆箱 / 装箱可能掩盖类型错误（如 <code>Integer i = null; int j = i;</code> 导致 <code>NullPointerException</code>）。</p></li></ul></li></ol><h3 id="编译、解释系统" tabindex="-1"><a class="header-anchor" href="#编译、解释系统"><span>编译、解释系统</span></a></h3><h4 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h4><p><strong>编译是将高级程序设计语言编写的源程序转化为目标机器可执行的机器语言程序的过程</strong>。</p><ul><li><strong>词法分析</strong>：编译的第一个阶段，使用有限自动机实现。从左到右扫描源程序字符流，依据词法规则将其识别为一个个单词，如关键字、标识符、常量、运算符等。</li><li><strong>语法分析</strong>：基于词法分析得到的单词序列，依据语法规则，使用多种方法如 <strong>自顶向下</strong>（递归下降分析法和预测分析法）<strong>和自底向上</strong> 等（移进-归约分析法），构建语法树，检查源程序的语法结构是否正确。</li><li><strong>语义分析</strong>：在语法分析基础上，对语法树进行遍历，依据语义规则检查源程序语义的正确性，如类型检查、变量声明与使用一致性检查等，并进行必要的语义处理，如生成中间代码。</li><li><strong>中间代码生成</strong>：是编译程序的重要阶段，将源程序转换为一种中间表示形式，<strong>方便进行与目标机器无关的优化和生成目标代码</strong>，常采用规定的表示形式有 <strong>三地址码、四元式、后缀式、语法树</strong> 等。</li><li><strong>代码优化</strong>：对中间代码进行等价变换，依据优化原则和技术，如常量折叠、公共子表达式删除等，提高目标代码的执行效率。</li><li><strong>目标代码生成</strong>：根据目标机器的指令集和体系结构，将优化后的中间代码转换为目标机器可执行的机器语言代码，涉及寄存器分配、指令选择等工作。</li></ul><p>常见的中间代码形式。</p><h4 id="编译语言和解释语言" tabindex="-1"><a class="header-anchor" href="#编译语言和解释语言"><span>编译语言和解释语言</span></a></h4><p><strong>编译语言</strong></p><ul><li><strong>简介</strong>：编写的源代码通过编译器一次性翻译成目标机器的机器码，生成可执行文件，执行时直接运行可执行文件。</li><li><strong>举例</strong>：C、C++、Java（Java 有编译过程，生成字节码，在虚拟机上运行，也可看作特殊的编译语言）等。</li></ul><p><strong>解释语言</strong></p><ul><li><p><strong>简介</strong>：源代码由解释器逐行解释并执行，不生成目标机器码，边解释边执行。</p></li><li><p><strong>举例</strong>：Python、JavaScript、Ruby 等。</p><p><strong>对比</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>解释型语言</strong></th><th><strong>编译型语言</strong></th><th><strong>软考常考点</strong></th></tr></thead><tbody><tr><td><strong>翻译方式</strong></td><td>逐行翻译并立即执行</td><td>一次性整体翻译为目标代码</td><td>翻译方式的差异（逐行 vs 整体）</td></tr><tr><td><strong>运行过程</strong></td><td>源代码 → 解释器 → 执行</td><td>源代码 → 编译器 → 可执行文件 → 执行</td><td>运行阶段的步骤（是否生成中间文件）</td></tr><tr><td><strong>语法检查</strong></td><td>运行时检查（错误即时反馈）</td><td>编译时检查（生成错误报告）</td><td>错误检测的时机（运行时 vs 编译时）</td></tr><tr><td><strong>开发效率</strong></td><td>高（修改后立即生效）</td><td>低（需重新编译）</td><td>开发效率与调试便利性</td></tr><tr><td><strong>执行速度</strong></td><td>慢（逐行解释）</td><td>快（直接执行机器码）</td><td>执行效率对比（软考高频考点）</td></tr><tr><td><strong>跨平台性</strong></td><td>好（只需解释器）</td><td>差（需编译不同平台版本）</td><td>跨平台能力的优劣</td></tr><tr><td><strong>典型语言</strong></td><td>Python、PHP、JavaScript、BASIC</td><td>C、C++、Java（编译为字节码后由 JVM 解释）</td><td>语言分类（如 Java 的特殊性：编译 + 解释）</td></tr><tr><td><strong>代码安全性</strong></td><td>伪码易被反编译</td><td>机器码难逆向</td><td>安全性对比（需注意 Java 的字节码也可能被反编译）</td></tr><tr><td><strong>中间代码</strong></td><td>可能生成中间码（如字节码）但不保存</td><td>生成目标代码（如机器码、汇编）并保存</td><td>是否生成独立的中间文件</td></tr></tbody></table></li></ul><h3 id="文法分析" tabindex="-1"><a class="header-anchor" href="#文法分析"><span>文法分析</span></a></h3><h4 id="_1-文法的定义与分类" tabindex="-1"><a class="header-anchor" href="#_1-文法的定义与分类"><span>1. 文法的定义与分类</span></a></h4><ul><li><strong>文法</strong>：形式化描述语言的规则集合，由四元组 <em>G</em> =(<em>V</em> <em>N</em>, <em>V</em> <em>T</em>, <em>P</em>, <em>S</em>) 表示： <ul><li><em>V</em> <em>N</em>：非终结符集（如 <em>S</em>, <em>A</em>, <em>B</em>）。</li><li><em>V</em> <em>T</em>：终结符集（如 <em>a</em>, <em>b</em>,+）。</li><li><em>P</em>：产生式规则（如 <em>S</em> → <em>a</em> <em>S</em> <em>b</em>）。</li><li><em>S</em>：开始符号。</li></ul></li><li><strong>文法类型（乔姆斯基分类）</strong>： <ul><li><strong>0 型（无限制文法）</strong>：无约束条件，等价于图灵机。</li><li><strong>1 型（上下文有关文法）</strong>：产生式形如 <em>α</em> → <em>β</em>，其中 ∣ <em>α</em> ∣≤∣ <em>β</em> ∣。</li><li><strong>2 型（上下文无关文法）</strong>：产生式形如 <em>A</em> → <em>β</em>，非终结符可替换为任意符号串。</li><li><strong>3 型（正规文法）</strong>：产生式形如 <em>A</em> → <em>a</em> <em>B</em> 或 <em>A</em> → <em>a</em>，对应有限自动机。</li></ul></li></ul><h4 id="_2-推导与归约" tabindex="-1"><a class="header-anchor" href="#_2-推导与归约"><span>2. 推导与归约</span></a></h4><ul><li><strong>推导</strong>：从开始符号出发，通过产生式规则生成句子的过程（如 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> ⇒ <em>aabb</em>）。</li><li><strong>最左（右）推导</strong>：每次替换最左（右）非终结符。</li><li><strong>归约</strong>：推导的逆过程，从句子反向构造语法树。</li></ul><h4 id="_3-语法树与短语" tabindex="-1"><a class="header-anchor" href="#_3-语法树与短语"><span>3. 语法树与短语</span></a></h4><ul><li><strong>语法树</strong>：可视化推导过程的树形结构。</li><li><strong>短语</strong>：某个非终结符可推导出的符号串（如在 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> 中，<em>a</em> <em>S</em> 是相对于 <em>S</em> 的短语）。</li><li><strong>句柄</strong>：最左直接短语，用于自底向上分析（如 LR 分析）。</li></ul><h4 id="_4-语法分析方法" tabindex="-1"><a class="header-anchor" href="#_4-语法分析方法"><span>4. 语法分析方法</span></a></h4><ul><li>自顶向下分析：LL (1)、递归下降分析。 <ul><li><strong>LL(1)</strong>：第一个 L 表示从左到右扫描，第二个 L 表示最左推导，1 表示向前看一个符号。</li><li><strong>条件</strong>：无左递归、无回溯、First 和 Follow 集不相交。</li></ul></li><li>自底向上分析：LR(0)、SLR(1)、LR(1)、LALR(1)。 <ul><li><strong>LR 分析</strong>：L 表示从左到右扫描，R 表示最右推导的逆过程。</li></ul></li></ul><h4 id="软考常考题目解析" tabindex="-1"><a class="header-anchor" href="#软考常考题目解析"><span>软考常考题目解析</span></a></h4><h6 id="_1-文法分类题" tabindex="-1"><a class="header-anchor" href="#_1-文法分类题"><span>1. <strong>文法分类题</strong></span></a></h6><p><strong>题目</strong>：判断以下文法类型：<em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em><strong>分析</strong>：</p><ul><li>产生式形式为 <em>A</em> → <em>β</em>，符合上下文无关文法（2 型）。</li><li>无法转换为正规文法（3 型），因存在递归嵌套。 <strong>答案</strong>：上下文无关文法。</li></ul><h5 id="_2-first-和-follow-集计算" tabindex="-1"><a class="header-anchor" href="#_2-first-和-follow-集计算"><span>2. <strong>First 和 Follow 集计算</strong></span></a></h5><p><strong>题目</strong>：文法 <em>G</em> =(<em>S</em>, <em>A</em>, <em>a</em>, <em>b</em>, <em>P</em>, <em>S</em>)，其中 <em>P</em> 为：<em>S</em> → <em>a</em> <em>A</em> <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em> 求 First (S)、First (A)、Follow (S)、Follow (A)。 <strong>解答</strong>：</p><ul><li><p><strong>First(S)</strong>：由 <em>S</em> → <em>a</em> <em>A</em>，First(S) = {a}。</p></li><li><p><strong>First(A)</strong>：由 <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，First(A) = {b, ε}。</p></li><li><p>Follow(S)</p><p>：</p><ul><li>S 是开始符号，初始 Follow (S) = {#}。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号。</li><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号，而 A 可推导出 ε，因此 Follow (S) = Follow (S) ∪ Follow (A)。</li><li>最终 Follow (S) = {#, b}。</li></ul></li><li><p>Follow(A)</p><p>：</p><ul><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号（即 {#, b}）。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号，但 S 的 Follow 集包含 {#, b}，因此 Follow (A) = {#, b}。</li></ul></li></ul><h5 id="_3-ll-1-文法判定" tabindex="-1"><a class="header-anchor" href="#_3-ll-1-文法判定"><span>3. <strong>LL (1) 文法判定</strong></span></a></h5><p><strong>题目</strong>：判断文法 <em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em> 是否为 LL (1)。 <strong>分析</strong>：</p><ul><li><p><strong>First(S)</strong>：{a}（两个产生式的 First 集相同，无冲突）。</p></li><li><p><strong>Follow(S)</strong>：{b, #}（由推导 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em>，S 后可能有 b 或结束符 #）。</p></li><li><p>条件</p><p>：所有产生式的 First 集不相交，且 First 集与 Follow 集无交集。</p><ul><li>此处两个产生式的 First 集均为 {a}，无冲突，且 First (S) 与 Follow (S) 无交集。 <strong>结论</strong>：是 LL (1) 文法。</li></ul></li></ul><h5 id="_4-lr-分析表构造" tabindex="-1"><a class="header-anchor" href="#_4-lr-分析表构造"><span>4. <strong>LR 分析表构造</strong></span></a></h5><p><strong>题目</strong>：对文法 <em>S</em> → <em>a</em> <em>A</em>, <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，构造 LR (0) 分析表。 <strong>步骤</strong>：</p><ol><li><p><strong>拓广文法</strong>：添加 <em>S</em>′→ <em>S</em>。</p></li><li><p>构造项目集</p><p>：</p><ul><li><em>I</em> 0: <em>S</em>′→⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 1: <em>S</em>′→ <em>S</em> ⋅（接受状态）</li><li><em>I</em> 2: <em>S</em> → <em>a</em> ⋅ <em>A</em>, <em>A</em> →⋅ <em>b</em> <em>S</em> ∣⋅ <em>ϵ</em></li><li><em>I</em> 3: <em>A</em> → <em>b</em> ⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 4: <em>A</em> → <em>ϵ</em> ⋅（归约状态）</li></ul></li><li><p><strong>转移函数</strong>：根据符号跳转（如 <em>I</em> 0 输入 a 转移到 <em>I</em> 2）。</p></li><li><p>分析表</p><p>：</p><ul><li><em>I</em> 0：action [a] = s2（移进）。</li><li><em>I</em> 2：action [b] = s3（移进），action [ε] = r2（归约）。</li><li><em>I</em> 4：goto [A] = I_1（归约后转到 S 的状态）。 <strong>答案</strong>：分析表需完整列出所有状态和符号的 action/goto 项。</li></ul></li></ol><h3 id="有限自动机" tabindex="-1"><a class="header-anchor" href="#有限自动机"><span>有限自动机</span></a></h3><h4 id="核心知识点" tabindex="-1"><a class="header-anchor" href="#核心知识点"><span><strong>核心知识点</strong></span></a></h4><ol><li><strong>定义与五元组</strong> 有限自动机是一个五元组：<code>M = (Q, Σ, δ, q₀, F)</code>，其中： <ul><li><strong>Q</strong>：有限状态集；</li><li><strong>Σ</strong>：输入字母表；</li><li><strong>δ</strong>：转移函数（DFA 为单值映射，NFA 为多值映射或含 ε 转移）；</li><li><strong>q₀</strong>：初始状态；</li><li><strong>F</strong>：终止状态集。</li></ul></li><li><strong>类型</strong><ul><li><strong>确定有限自动机（DFA）</strong>：每个状态对每个输入有唯一转移。</li><li><strong>非确定有限自动机（NFA）</strong>：允许 ε 转移和多值转移，可通过 ε- 闭包简化为 DFA。</li></ul></li><li><strong>语言识别</strong> 输入字符串被接受的条件是：从初始状态出发，按转移规则遍历字符后到达终止状态。</li><li><strong>正则表达式与自动机的转换</strong><ul><li><strong>正则式 →NFA</strong>：通过 Thompson 算法构造。</li><li><strong>NFA→DFA</strong>：通过子集构造法（如 ε- 闭包计算）。</li><li><strong>DFA 最小化</strong>：通过等价类划分（如 Hopcroft 算法）。</li></ul></li></ol><h4 id="二、软考常考点" tabindex="-1"><a class="header-anchor" href="#二、软考常考点"><span><strong>二、软考常考点</strong></span></a></h4><ol><li><p><strong>DFA 与 NFA 的区别</strong></p><ul><li>重点：DFA 转移唯一，NFA 允许多转移和 ε 动作。</li><li>题型示例：判断给定自动机是 DFA 还是 NFA。</li></ul></li><li><p><strong>状态转移图分析</strong></p><ul><li>常考：根据状态转移图，选择自动机接受的字符串（如以特定模式结尾）。</li><li>解题技巧：模拟路径，关注终止状态条件。</li></ul></li><li><p><strong>正则式与自动机的转换</strong></p><ul><li>软考高频考点：将正则式转换为 NFA，或根据自动机图写出对应的正则式。</li></ul></li><li><p><strong>ε- 闭包与子集构造法</strong></p><ul><li>常考步骤：计算 NFA 的 ε- 闭包，将其转换为等价 DFA。</li></ul></li><li><p><strong>DFA 最小化</strong></p><ul><li>步骤：划分状态等价类，合并不可区分状态。</li></ul></li></ol><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h2><h3 id="操作系统定义分类及其功能" tabindex="-1"><a class="header-anchor" href="#操作系统定义分类及其功能"><span>操作系统定义分类及其功能</span></a></h3><h3 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理"><span>进程管理</span></a></h3><h3 id="文件管理" tabindex="-1"><a class="header-anchor" href="#文件管理"><span>文件管理</span></a></h3><h3 id="存储管理" tabindex="-1"><a class="header-anchor" href="#存储管理"><span>存储管理</span></a></h3><h3 id="设备管理" tabindex="-1"><a class="header-anchor" href="#设备管理"><span>设备管理</span></a></h3><h3 id="作业管理" tabindex="-1"><a class="header-anchor" href="#作业管理"><span>作业管理</span></a></h3><h2 id="软件工程基础知识" tabindex="-1"><a class="header-anchor" href="#软件工程基础知识"><span>软件工程基础知识</span></a></h2><h3 id="软件工程概述" tabindex="-1"><a class="header-anchor" href="#软件工程概述"><span>软件工程概述</span></a></h3><p>软件工程基本要素：方法，工具，过程</p><h4 id="软件生存周期" tabindex="-1"><a class="header-anchor" href="#软件生存周期"><span>软件生存周期</span></a></h4><h5 id="可行性分析与项目开发计划" tabindex="-1"><a class="header-anchor" href="#可行性分析与项目开发计划"><span>可行性分析与项目开发计划</span></a></h5><p>这个阶段主要确定软件的开发目标及其可行性  参加人员有用户，项目负责人和系统分析师  该阶段产生的主要文档有可行性分析报告和项目 开发计划，从而确定系统的逻辑模型</p><h5 id="需求分析" tabindex="-1"><a class="header-anchor" href="#需求分析"><span>需求分析</span></a></h5><p>这个阶段确定软件的系统的功能，性能，数据和界面等要求  参加人员有用户，项目负责人和系统分析师。  该阶段产生的主要文档软件需求说明书</p><h5 id="概要设计" tabindex="-1"><a class="header-anchor" href="#概要设计"><span>概要设计</span></a></h5><p>在概要设计阶段，开发人员要把确定的各项功能 需求转换需要的体系结构。概要设计就是设计软件的结构  概要设计概要的参加人员有系统分析师和软件设计师  该阶段主要产生文档有概要设计说明书</p><h5 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计"><span>详细设计</span></a></h5><p>详细设计阶段的主要任务是对每个模块完成的功能进行具体描述，要把功能描述转变为精确的，结构化的过程描述。  详细设计阶段的参加人员有软件设计师和程序员。  该阶段主要产生文档有详细设计文档。</p><h5 id="编码" tabindex="-1"><a class="header-anchor" href="#编码"><span>编码</span></a></h5><p>编码阶段就是把每个模块的控制结构转换成计算机课接受的程序代码。即写成某种特定程序设计语言表示的源程序清单</p><h5 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h5><p>测试是保证软件质量的重要手段，其主要方式是在设计测试用例的基础上检查软件的各个组成部分。  测试阶段的参加人员通常是另一部门的软件设计师或系统分析师。  该阶段主要产生文档有软件测试计划，测试用例和软件测试报告。</p><h3 id="软件工具与开发环境" tabindex="-1"><a class="header-anchor" href="#软件工具与开发环境"><span>软件工具与开发环境</span></a></h3><p>有效的项目管理集中在4P上：人员，产品，过程，项目。</p><p>软件项目估算方法：成本估算方法   自顶向下估算：又称类比估算法，确定一个总金额，在向下分摊到每一个功能点。   自底向上估算：又称底层功能点开始估算成本，向上累加。   差别估算法：与以前的项目相比，找出不同点重新估算，相同点则直接估算。   专家估算：聘请专家以其经验对项目整体费用进行估算。 COCOMO模型：常见的软件规模估算方法。常用的代码行分析方法作为一种度量估计单位，以代码行数估算每个程序员工作量。累加得软件成本。  模型按其详细程度可以可以分为三级：基本COCOMO模型，中间COCOMO模型，详细COCOMO模型。其中基本COCOMO模型是一个静态单变量模型，它用一个以估算出来的原代码行数为自变量的经验函数计算软件开发工作量。中间COCOMO模型在基础COCOMO模型的基础上，再用涉及产品、硬件、人员、项目等方面影响因素调整工作量的估算。详细COCOMO模型包括中间COCOMO模型所有特性，但更进一步考虑了软件工程的每一个步骤的影响。 COCOMO II模型：COCOMO模型的升级，也是以软件规模作为成本的主要因素，考虑多个成本驱动因子。该方法包括三个阶段性模型，即应用组装模型，早期设计阶段模型，体系结构阶段模型 Putnam估算模型：一种动态多变量模型，假设在软件开发的整个生存周期中工作量有特定的分布。</p><h4 id="进度管理" tabindex="-1"><a class="header-anchor" href="#进度管理"><span>进度管理</span></a></h4><p>基本原则：划分，相互依赖，时间分配，工作量确认，确认责任，明确输出结果，确定里程碑。   Gantt图：又称横道图，横轴表示时间，纵轴表示活动，以时间顺序表示活动，能 反应活动间的并行关系，但无法反应活动间的依赖关系，因此也难以清晰的确定关键任务和关键路径。  PERT图：类似前趋图，是有向图，反应活动间的依赖关系，有向边上标注活动的运行时间，但无法反应活动间的并行关系。  PERT图关键路径：  最早开始时间ES：取所有前驱活动最早完成时间EF的最大值。  最早完成时间EF：ES+DU（活动本身时间）。  关键路径（项目总工期）：项目中耗时最长的线路。  最晚完成时间LF：取后续活动最晚开始时间的最小值。  最晚开始时间LS：LF-DU  松弛时间：LS-ES 或者LF-EF （即活动最多可以晚几天开始） 例： 关键路径为图中最长的路径即 D-F-H 权值为48所以第一空选C FG的松弛时间为 关键路径 - 包含FG的最长路径 （DFH）-（DFG）=48-28=20 所以第二空为B</p><h4 id="软件项目的组织" tabindex="-1"><a class="header-anchor" href="#软件项目的组织"><span>软件项目的组织</span></a></h4><p>程序设计小组的组织方式：  主程序员制小组：主程序员全权负责，后援工程师有必要时能替代主程序员，适合大规模项目。  民主制小组：也即无主程序员小组，成员之间地位平等，任何决策都是全员参与投票，适合于项目规模小，开发人员少，采用新技术和确定性较小的项目。  层次式小组：两个层次，一名组长领导若干个高级程序员，每个高级程序员领导若干个程序员。</p><h3 id="软件开发项目管理" tabindex="-1"><a class="header-anchor" href="#软件开发项目管理"><span>软件开发项目管理</span></a></h3><h3 id="软件质量管理" tabindex="-1"><a class="header-anchor" href="#软件质量管理"><span>软件质量管理</span></a></h3><p>通常将质量理解为用户满意程度，为了使用户满意，有两个必要条件：设计的规格说明书符合用户标准，称为设计质量。程序按照设计规模书所规定的情况正确执行，称为程序质量。  设计质量评审，程序质量评审。</p><table><thead><tr><th>质量特性</th><th>质量子特性</th></tr></thead><tbody><tr><td>功能性</td><td>适合性 准确性 互用性 依从性 安全性</td></tr><tr><td>可靠性</td><td>成熟性 容错性 易恢复性</td></tr><tr><td>易使用性</td><td>易理解性 易学性 易操作性</td></tr><tr><td>效率</td><td>时间特性 资源特性</td></tr><tr><td>可维护性</td><td>易分析性 易改变性 稳定性 易测试性</td></tr><tr><td>可移植性</td><td>适应性 易安装性 一致性 易替换性</td></tr></tbody></table><p>易分析性：与为诊断缺陷或失效原因，或为判定待修改部分所需那里有关的软件属性。  易改变性：与进行修改、排错、或适应环境变换所需努力有关的软件属性。  稳定性：与修改造成未预料效果风险有关的软件属性。  易测试性：为确认经修改软件所需努力有关的软件属性。</p><h4 id="软件容错技术" tabindex="-1"><a class="header-anchor" href="#软件容错技术"><span>软件容错技术</span></a></h4><p>软件容错技术：  容错就是软件遇到错误的处理能力，实现容错的手段主要是冗余，包括下面四种冗余技术：  <strong>结构冗余</strong>：分为静态（通过表决和比较，少数服从多数）、动态（多重模块待机备份，故障是切换备份机）、混合冗余（二者综合）。  <strong>信息冗余</strong>：为检错和纠错在数据中加上一段额外的信息，例如检验码原理。  <strong>时间冗余</strong>：遇到错误是重复执行，例如回滚，重复执行还有错，则转入错误处理逻辑。  <strong>冗余附加技术</strong>：冗余附加技术是指为实现数据结构，信息和时间冗余技术所需的资源和技术，包括程序，指令，数据，存放和调动它们的空间和通道等</p><h4 id="风险管理" tabindex="-1"><a class="header-anchor" href="#风险管理"><span>风险管理</span></a></h4><p>风险管理两个特性：不确定性（可能发生也可能不发生）、损失（发生会产生恶性后果）。  <strong>项目风险</strong>威胁到项目计划，如果项目风险发生，有可能拖延项目的进度和增加项目的成本，指预算。进度、人员、资源。利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素。  <strong>技术风险</strong>威胁到要开发软件的质量和交付时间，如果技术风险发生，开发工作就变得很困难或者不可能，只设计、实现、接口、验证和维护等方面的潜在问题。此外，规格说明的歧义性，技术的不确定性，技术陈旧以及“前沿”技术也是技术风险因数。  商业风险威胁到要开发软件的生存能力，包括下面五种：</p><ol><li>市场风险：开发了一个没有人真正需要的优良产品或系统。</li><li>策略风险：开发的产品不在符合公司的整体商业策略。</li><li>销售风险：开发了一个销售部门不知道该如何销售的产品。</li><li>管理风险：由于重点的转移或人员变动而失去了高级管理层的支持。</li><li>预算风险：没有得到预算或人员的保证。</li></ol><p>风险管理过程如下：</p><ol><li>风险识别：识别出项目中已知和可预测的风险，确定风险的来源，产生的条件，描述风险的特征以及哪些项目可以产生风险。形成一个风险列表。</li><li>风险预测：又称为风险估计，从两个方面预测风险，即风险可能发生的概率和风险产生的后果，因此有风险曝光度=风险发生的可能性*风险发生带来的损失。</li><li>风险评估：定义风险参照水准，将识别出来的风险评估分类。</li><li>风险控制：辅助项目组建立处理风险的策略，包括风险避免，风险监控，RMMM计划（风险缓解，监控和管理计划）</li></ol><h4 id="软件度量" tabindex="-1"><a class="header-anchor" href="#软件度量"><span>软件度量</span></a></h4><p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的属性，如可靠度等，只能间接测量。  McCabe算法：又称为环路复杂度，假设有向图中有向边数为M，节点数为N，则此有向图的环路复杂度为M-N+2。</p><h3 id="软件过程管理" tabindex="-1"><a class="header-anchor" href="#软件过程管理"><span>软件过程管理</span></a></h3><h4 id="能力成熟度模型cmm" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型cmm"><span>能力成熟度模型CMM</span></a></h4><p>能力成熟度模型CMM：对软件组织化阶段的描述，随着软件组织地定义、实施，测量、控制和改进其软件过程，软件组织地能力经过这些阶段逐步提高。</p><ol><li>初始级（Initial）：软件过程的特点是杂乱无章，又是甚至很混乱，几乎没有明确定义的步骤，项目的完成全依赖个人的努力和英雄式核心人物的作用。</li><li>可重复级（Repeatable）：建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</li><li>已定义级（Defined）：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件来发组织地标准软件过程，所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li>已管理级（Managed）：制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织地成员所理解和控制。</li><li>优化级（Optimized）：加强了定量分析，通过来之过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</li></ol><h4 id="能力成熟度模型cmmi" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型cmmi"><span>能力成熟度模型CMMI</span></a></h4><p>能力成熟度模型CMMI：将已有的几个CMM模型结合在一起，使之构造成为“集成模型”。支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需求，能提高过程的质量和工作效率。  阶段式模型：类似于CMM，它关注组织地成熟度，五个成熟度模型如下：</p><ol><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程为以度量和控制。</li><li>优化的：集中于过程改进。</li></ol><h4 id="维护" tabindex="-1"><a class="header-anchor" href="#维护"><span>维护</span></a></h4><p>软件维护是软件设计生存周期中时间最长的阶段。已交付的软件投入正式使用后，便进入软件维护阶段，它可以持续几年甚至十几年。</p><h4 id="软件过程模型" tabindex="-1"><a class="header-anchor" href="#软件过程模型"><span>软件过程模型</span></a></h4><h5 id="统一过程模型-up" tabindex="-1"><a class="header-anchor" href="#统一过程模型-up"><span>统一过程模型（UP）</span></a></h5><p>统一过程模型：是一种“用例和风险驱动，以架构为中心，迭代并且增量”的开发过程。 开发的四个阶段</p><ol><li>起始阶段：项目的初始活动，如确认需求和风险评估等。</li><li>精化阶段：需求分析和架构设计等。</li><li>构建阶段：系统的构建，产生实现模型等。</li><li>移交阶段：软件提交方面的工作，产生软件增量，进行β测试，交付系统等。 UP的每一次迭代都是一次完整的软件开发过程，包括整个软件开发生命周期，有五个核心工作流（需求-分析-设计-实现-测试）。</li></ol><h5 id="瀑布模型" tabindex="-1"><a class="header-anchor" href="#瀑布模型"><span>瀑布模型</span></a></h5><p>结构化方法中的模型，是结构化的开发，开发流程如瀑布一样，一步一步走下去，直到项目完成开发  只适用于需求明确或者二次开发（需求稳定）的项目</p><h5 id="v模型" tabindex="-1"><a class="header-anchor" href="#v模型"><span>V模型</span></a></h5><p>是瀑布模型的一个变种。特点是增加了多轮测试，并且这些测试贯穿于软件开发的各个阶段</p><h5 id="原型" tabindex="-1"><a class="header-anchor" href="#原型"><span>原型</span></a></h5><p>快速原型开发，与瀑布模型相反，原型针对需求不明确的情况</p><h5 id="螺旋模型" tabindex="-1"><a class="header-anchor" href="#螺旋模型"><span>螺旋模型</span></a></h5><p>是多种模型的混合，针对需求不明确的项目，与原型相似，但增加了风险分析（制定计划—风险分析—实施工程—用户评估）</p><h5 id="增量模型" tabindex="-1"><a class="header-anchor" href="#增量模型"><span>增量模型</span></a></h5><p>首先开发核心功能模块，而后与用户确认，之后再开发次核心功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发，优先级高的服务最先交付。 增量模型的每一次增量版本都可作为独立操作的作品</p><h5 id="喷泉模型" tabindex="-1"><a class="header-anchor" href="#喷泉模型"><span>喷泉模型</span></a></h5><p>是一种以用户需求为动力，以对象作为驱动的模型。适用于面向对象的开发方法是开发过程具有迭代性和无间隙性</p><h5 id="基于构建的开发模型" tabindex="-1"><a class="header-anchor" href="#基于构建的开发模型"><span>基于构建的开发模型</span></a></h5><p>利于预先包装的构件来构造应用系统，构件是可以组织内部开发的构件，也可以是商品化成品软件构件。  提点是增强了复用性，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高复用性，节省时间和成本。</p><h5 id="敏捷开发" tabindex="-1"><a class="header-anchor" href="#敏捷开发"><span>敏捷开发</span></a></h5><p>敏捷开发的总体目标是通过“尽可能早，持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷开发使用户能够在开发周期的后期增加或者改变需求。</p><h5 id="自适应开发-asd" tabindex="-1"><a class="header-anchor" href="#自适应开发-asd"><span>自适应开发（ASD）</span></a></h5><p>强调开发方法的适应性</p><h5 id="水晶方法-crystal" tabindex="-1"><a class="header-anchor" href="#水晶方法-crystal"><span>水晶方法（Crystal）</span></a></h5><p>水晶法认为每一个不同项目都需要一套不同的策略，约定和方法论。</p><p>水晶法认为每一个不同项目都需要一套不同的策略，约定和方法论</p><h5 id="特性驱动开发" tabindex="-1"><a class="header-anchor" href="#特性驱动开发"><span>特性驱动开发</span></a></h5><p>是一套针对中小型软件开发项目的开发模式，是一个模型驱动的快速迭代开发过程，它强调的是简化，使用，易被开发团队接受，适用于需求经常变动的项目。</p><p>是一套针对中小型软件开发项目的开发模式，是一个模型驱动的快速迭代开发过程，它强调的是简化，使用，易被开发团队接受，适用于需求经常变动的项目</p><p>并列争求法（Scrum）</p><p>并列争求法是一种迭代的增量化过程，其中，把每30天一次的迭代称为一个“冲刺”，并按需求的优先级来实现产品。</p><h5 id="极限编程-xp" tabindex="-1"><a class="header-anchor" href="#极限编程-xp"><span>极限编程（XP）</span></a></h5><p>XP是一种轻量级（敏捷），高效，低风险，柔性，可预测，科学的软件开发方式。  四大价值观：沟通，简单性，反馈和勇气。  五个原则：快速反馈，简单性假设，逐步修改，提倡更改和优质工作。  12个最佳实践：计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结队编程，集体代码所有制，持续集成，每周工作40小时，现场客户和编码标准</p><h5 id="结对编程" tabindex="-1"><a class="header-anchor" href="#结对编程"><span>结对编程</span></a></h5><p>一个程序员开发，另一个审查代码，能够有效的提高代码的质量。</p><h2 id="系统开发与运行" tabindex="-1"><a class="header-anchor" href="#系统开发与运行"><span>系统开发与运行</span></a></h2><h3 id="系统分析概述" tabindex="-1"><a class="header-anchor" href="#系统分析概述"><span>系统分析概述</span></a></h3><p>系统分析是一种问题的求解技术，它将一个系统分解成各个组成部分，目的是研究各个部分如何工作，交互，以实现其系统目标。  目的和任务：系统分析的主要任务是对现行系统进一步详细调查，将调查中所得到的文档资料集中，对组织内部整体管理状况和信息处理过程进行分析，为系统开发提供所需资料，并提交系统方案说明书。  系统分析的主要步骤</p><ol><li>认识、理解当前的现实环境，获得当前系统的“物理模型”。</li><li>从当前系统的“物理模型”抽象出当前系统的“逻辑模型”。</li><li>对当前系统的“逻辑模型”进行分析和优化，建立目标系统的“逻辑模型”。</li><li>对目标系统的逻辑模型具体化（物理化），建立目标系统的物理模型。</li></ol><p>系统开发的目的是将现有系统的物理模型转换为目标系统的物理模型。</p><h4 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h4><p>系统设计基本原理：  抽象（重点说明本质问题，忽略非本质方面）  模块化（可组合、分解和更换的单元）  信息隐蔽（将每个程序的成分隐蔽或封装在一个单一的设计模块中）  模块独立（每个模块完成一个相对独立的特定子功能，且与其他模块之间的联系简单）</p><p>模块的设计要求独立性高，就必须高内聚，低耦合，内聚是指一个模块内部功能之间的相关性，耦合是指多个模块之间的联系。</p><h4 id="内聚" tabindex="-1"><a class="header-anchor" href="#内聚"><span>内聚</span></a></h4><p>内聚程度从低到高如下表所示：</p><table><thead><tr><th>内聚分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>偶然内聚</td><td>一个模块内各处理元素之间没有任何联系</td><td>无直接关系</td></tr><tr><td>逻辑内聚</td><td>模块内执行若干个逻辑上相似的功能，通过参数确定改模块完成哪一个功能</td><td>逻辑相似，参数决定</td></tr><tr><td>时间内聚</td><td>把需要同时执行的动作组合在一起形成模块</td><td>同时执行</td></tr><tr><td>过程内聚</td><td>一个模块完成多个任务，这些任务必须按指定的过程执行</td><td>指定的过程顺序</td></tr><tr><td>通信内聚</td><td>模块内所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据</td><td>相同的数据结构、形同的输入输出</td></tr><tr><td>顺序内聚</td><td>一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一个功能元素的输出就是后一个功能元素的输入</td><td>顺序执行、输入为输出</td></tr><tr><td>功能内聚</td><td>最强的内聚，模块内所有元素共同作用完成一个功能，缺一不可</td><td>共同作用，缺一不可</td></tr></tbody></table><h4 id="耦合" tabindex="-1"><a class="header-anchor" href="#耦合"><span>耦合</span></a></h4><p>耦合程度从低到高如下表所示：</p><table><thead><tr><th>耦合分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>无直接耦合</td><td>两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，不传递任何信息</td><td>无直接关系</td></tr><tr><td>数据耦合</td><td>两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递</td><td>传递数据值调用</td></tr><tr><td>标记耦合</td><td>两个模块之间传递的是数据结构</td><td>传递数据结构</td></tr><tr><td>控制耦合</td><td>一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值，有选择的执行模块内的某一功能</td><td>控制变量，选择执行某一功能</td></tr><tr><td>外部耦合</td><td>模块间通过软件之外的环境联合（如I/O将模块耦合到特定的设备，格式，通信协议）时</td><td>软件外部环境</td></tr><tr><td>公共耦合</td><td>通过一个公共数据环境相互作用的那些模块间的耦合</td><td>公共数据结构</td></tr><tr><td>内容耦合</td><td>当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个内部模块时</td><td>模块内部关联</td></tr></tbody></table><h4 id="系统设计-1" tabindex="-1"><a class="header-anchor" href="#系统设计-1"><span>系统设计</span></a></h4><p>系统设计的主要目的是系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理的使用各种资源，得出新系统的详细设计方案。 步骤：概要设计和详细设计  概要设计基本任务：设计软件系统总体结构，数据结构及数据库设计，编写概要设计文档，评审。  详细设计基本任务：模块内详细算法设计、模块内数据结构设计，数据库物理设计、其他设计（代码，输入输出格式，用户界面），编写详细设计文档，评审。</p><h4 id="软件需求" tabindex="-1"><a class="header-anchor" href="#软件需求"><span>软件需求</span></a></h4><p>按需求内容分类：  业务需求:由客户提出的宏观的一个功能需求。  用户需求：设计员去调查需求中涉及的每个用户的具体需求。  系统需求：经过整合，形成最终的系统需求，包括功能，性能，设计约束三个方面的需求。</p><p>从客户角度分类：  基本需求：需求明确规定的功能。  期望需求：除了基本需求外，客户认为理所应当包含在内的其他功能。  兴奋需求：客户未要求其他功能需求，会浪费项目开发时间和成本。</p><p>软件需求分类：  功能需求：软件必须完成的基本动作。  性能需求：说明软件或人与软件交互的静态或动态数值需求。如系统响应速度，处理速度等。  设计约束：受其他硬件标准限制等方面影响。  属性：可用性、安全性、可维护性，可移植性。  外部接口需求：用户接口，硬件接口，软件接口，通信接口。</p><h3 id="测试基础知识" tabindex="-1"><a class="header-anchor" href="#测试基础知识"><span>测试基础知识</span></a></h3><p>系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。 测试原则：  应尽早并不断的进行测试。  测试工作应该避免由开发软件的人或小组承担。  在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期的输出结果。  即包含有效、合理的测试用例，也包含不合理、失效的用例。  检验程序是否做了该做的事，且是否做了不该做的事。  严格按照测试计划执行。  妥善保存测试用例和测试计划。  测试用例可以重复使用或追加测试。</p><h4 id="测试阶段" tabindex="-1"><a class="header-anchor" href="#测试阶段"><span>测试阶段</span></a></h4><p>单元测试：对单个模块进行测试，由程序员自己测试模块内部的接口、信息、功能，测试依据是软件详细说明书。在单元测试中，驱动模块（上层）用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块，桩模块（底层）用来模拟被测模块所调用的子模块。  集成测试：将模块组合起来进行测试，分为一次性组装（简单，节约时间，发现错误少，只适合小项目）和增量式组装（能够发现更多错误，耗时长，又可分为：自顶向下，自底向上，混合式）。  确认测试：对已完成的软件进行功能上的测试，分为内部确认测试（无用户情况）、Alpha测试（用户在开发环境下测试），Beat测试（用户在实际使用时进行的测试）、验收测试（用户根据SRS对项目进行验收）。  系统测试：对软甲进行性能测试，主要分为三个方面，即负载测试（在极限情况下，系统各项性能指标）、强度测试（系统资源特别低的情况下），容量测试（并发测试，系统可以处理的同时在线的最大用户数）。其他还有可靠性等性能测试，系统测试一般使用黑盒测试方法。  回归测试：软件修改错误或者变更后，进行回归测试以验证之前正确的代码是否引入了错误。  动态测试：程序运行时测试，分为：   黑盒测试法：功能性测试，不了解软件代码结构，根据功能设计用例，测试软件功能。   白盒测试法：结构性测试，明确代码流程，根据代码逻辑设计用例，进行用例覆盖。   灰盒测试法：即既有黑盒测试，也有白盒测试。</p><p>静态测试：程序静止时测试，即対代码进行人工审查，分为：   桌前检查：程序员检查自己编写的程序，在程序编译后，单元测试前。   代码审查：由若干个程序员和测试人员组成评审小组，通过召开程序评审会来进行审查。   代码走查：也是采用开会来对代码进行审查，但并非简单的审查代码，而是由测试人员提供用例，让程序员扮演计算机的角色，手动运行测试用例，检查代码逻辑。</p><h4 id="测试策略" tabindex="-1"><a class="header-anchor" href="#测试策略"><span>测试策略</span></a></h4><p>自底向上：从最底层模块开始测试，需要编写驱动程序，而后开始逐一合并模块，最终完成整个系统的测试。优点是较早的验证了底层模块。  自顶向下：先测试整个系统，需要编写桩程序，而后逐步向下直至最后测试最低层模块。优点是较早的验证了系统的主要控制和判断点。  三明治：既有自底向上也有自顶向下的测试方法，二者都包括。兼有二者的优点，缺点是测试工作量大。</p><h4 id="测试用例设计" tabindex="-1"><a class="header-anchor" href="#测试用例设计"><span>测试用例设计</span></a></h4><p>黑盒测试用例：将程序看做一个黑盒子，只知道输入输出，不知道内部代码，由此设计出测试用例，分为下面几类：  等价类划分：把所有的数据按照某种特性进行归类，而后在每类的数据里选取一个即可。等价类测试用例的设计原则：设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类被覆盖为止。  边界值划分：将每类的边界值作为测试用例，边界值一般为范围的两断值以及在此范围之外的与此范围间隔最小的两个值，如年龄范围0-150，边界值为0,150，1,151四个。</p><p>白盒测试用例：知道程序的代码逻辑，按照程序的代码语句，来设计覆盖代码分支的测试用例，覆盖级别从低至高分为下面六种：</p><p>1.语句覆盖：逻辑代码中所有的语句都要执行一遍，覆盖层级最低，因为执行了所有语句，不代表执行了所有条件判断。</p><ol start="2"><li><p>判定覆盖：逻辑代码中所有判断语句的条件的真假分支都要覆盖一次。</p></li><li><p>条件覆盖：对于代码中的一个条件，可能是组合的，如a&gt;0&amp;&amp;b&lt;0，判断覆盖只针对此组合条件的真假分支做两个测试用例，而条件覆盖是对每个独立的条件都要做真假分支的测试用例，共可有4个测试用例，层级更高，注意区别，条件覆盖，针对每个条件都要真假覆盖，判定覆盖，只针对一个条件判断语句。</p></li><li><p>判定/条件覆盖：使判定中每个条件的所有可能取值（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即两种覆盖的综合。</p></li><li><p>条件组合覆盖：每个判定条件中条件的各个可能值的组合都至少出现一次。</p></li><li><p>路径覆盖：逻辑代码中所有可行路径都覆盖了，覆盖层级最高。</p></li></ol><h2 id="面向对象技术" tabindex="-1"><a class="header-anchor" href="#面向对象技术"><span>面向对象技术</span></a></h2><h3 id="面向对象基本概念" tabindex="-1"><a class="header-anchor" href="#面向对象基本概念"><span>面向对象基本概念</span></a></h3><p>面向对象分析：是为了确定问题域，理解问题。 包含五个活动：<code>认定对象</code>(按自然存在的实体确定对象)、<code>组织对象</code>(分析对象关系,抽象成类)、<code>对象间的互相作用</code>(描述各对象在应用系统中的关系)、<code>确定对象的操作</code>(操作,如创建增加删除等)、<code>定义对象的内部信息(属性)</code></p><p>面向对象设计：是设计分析模型和实现相应源代码，在目标代码环境中这种源代码可被执行。设计问题域的解决方案。 面向对象程序设计：用面向对象程序设计语言实现设计方案。详见案例分析。 面向对象测试：与普通测试步骤并无不同。可分为四个层次：</p><ol><li><code>算法层</code>(测试类中定义的每个方法，类似单元测试)</li><li><code>类层</code>(测试同一个类中所有方法与属性的互相作用，<code>特有的模块测试</code>)</li><li><code>模板层</code>(测试一组协同工作的类之间的互相作用，类似集成测试)</li><li><code>系统层</code>(类似系统测试)</li></ol><h3 id="uml图" tabindex="-1"><a class="header-anchor" href="#uml图"><span>UML图</span></a></h3><p>UML是统一建模语言，和程序设计语言并无关系。 UML三个要素：UML的基本<strong>构造快</strong>、支配这些构造块如何放置在一起的<strong>规则</strong>和运用与整个语言的一些<strong>公共机制</strong>。 UML的基本构造快包括：<strong>事务</strong>（对模型中最具有代表性的成分的抽象）、<strong>关系</strong>（把事务结合在一起）、<strong>图</strong>（聚集了相关的事务）。 UML中有四种事务：<strong>结构事务</strong>、<strong>行为事务</strong>、<strong>分组事务</strong>、<strong>注释事务</strong>。</p><p>结构事务：模型的静态部分，如<strong>类、接口、用例、构件等</strong>如下图示例： <img src="`+p+'" alt="img"></p><h4 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h4><p><img src="'+c+'" alt="img"></p><hr><h4 id="关系" tabindex="-1"><a class="header-anchor" href="#关系"><span>关系</span></a></h4><ol><li>依赖：一个事务的语义依赖于另一个事务的语义变化而变化</li><li>关联：是一种结构关系，描述一组链，链是对象之间的连接。分为<strong>组合（强关联）<strong>和</strong>聚合（弱关联）</strong></li><li>泛化：一般/特殊的关系，子类和父类之间的关系。</li><li>实现：一个类元指定了另一个类元保证执行的契约。 <img src="'+u+'" alt="img"></li></ol><hr><h4 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h4><p><code>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</code><img src="'+b+'" alt="img"></p><hr><h4 id="对象图" tabindex="-1"><a class="header-anchor" href="#对象图"><span>对象图</span></a></h4><p><code>对象图：静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</code><img src="'+f+'" alt="img"></p><hr><h4 id="用例图" tabindex="-1"><a class="header-anchor" href="#用例图"><span>用例图</span></a></h4><p><code>用例图：静态图，展现了一组用例、参与者以及他们之间的关系。</code> 用例图中的参与者是人、硬件或其它系统可以扮演的角色；用例是参与者完成的一系列操作。 用力之间的关系包括：</p><ol><li>包含(include)</li><li>扩展(extend)</li><li>泛化 <img src="'+y+'" alt="img"></li></ol><hr><h4 id="序列图" tabindex="-1"><a class="header-anchor" href="#序列图"><span>序列图</span></a></h4><p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。 有<strong>同步消息</strong>（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示）、 <strong>异步消息</strong>（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示）、 <strong>返回消息</strong>（由从右到左的虚线箭头表示）三种。 <img src="'+m+'" alt="img"></p><hr><h4 id="通信图" tabindex="-1"><a class="header-anchor" href="#通信图"><span>通信图</span></a></h4><p>通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过 <strong>不强调时间顺序，只强调事件之间的通信</strong>，而且也没有固定的画法规则，<strong>和顺序图统称为交互图</strong>。 <img src="'+x+'" alt="img"></p><hr><h4 id="状态图" tabindex="-1"><a class="header-anchor" href="#状态图"><span>状态图</span></a></h4><p>状态图：<strong>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态</strong>。 转换可以<strong>通过事件触发器出发</strong>，事件触发后相应的监护条件会进行检查。</p><p>状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件， 实心圆点为起点和终点。下图描述的就是一个图书的状态变化： <img src="'+k+'" alt="img"></p><hr><h4 id="活动图" tabindex="-1"><a class="header-anchor" href="#活动图"><span>活动图</span></a></h4><p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另二个活动的流程。 <code>活动的分叉和汇合线是一条水平粗线。</code> 每个分岔的分支数代表了可同时运行的线程数。 活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。 <img src="'+v+`" alt="img"></p><h4 id="uml图总结" tabindex="-1"><a class="header-anchor" href="#uml图总结"><span>UML图总结</span></a></h4><table><thead><tr><th>图名称</th><th>用途</th><th>类型</th></tr></thead><tbody><tr><td><strong>类图</strong></td><td>静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>对象图</strong></td><td>静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</td><td>静态图</td></tr><tr><td><strong>用例图</strong></td><td>静态图，展现了一组用例、参与者以及他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>序列图</strong></td><td>即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</td><td>动态图</td></tr><tr><td><strong>通信图</strong></td><td>不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图</td><td>动态图</td></tr><tr><td><strong>状态图</strong></td><td>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态。</td><td>动态图</td></tr><tr><td><strong>活动图</strong></td><td>展现了在系统内从一个活动到另二个活动的流程。</td><td>动态图</td></tr></tbody></table><h3 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h3><h4 id="创建型设计模式" tabindex="-1"><a class="header-anchor" href="#创建型设计模式"><span>创建型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：单抽元件厂</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Singleton 单例模式</strong></td><td>确保一个类仅有一个实例，并提供全局访问点</td><td>唯一实例</td></tr><tr><td><strong>Abstract Factory 抽象工厂模式</strong></td><td>提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类</td><td>抽象接口</td></tr><tr><td><strong>Prototype 原型模式</strong></td><td>通过复制现有原型对象来创建新对象，避免重复初始化操作</td><td>原型实例化，拷贝</td></tr><tr><td><strong>Builder 构建器模式</strong></td><td>将复杂对象的构造与其表示分离，使同样的构建过程可以创建不同对象</td><td>类和构造分离</td></tr><tr><td><strong>Factory Method 工厂方法模式</strong></td><td>定义一个创建对象的接口，但让子类决定实例化哪个类</td><td>子类决定实例化</td></tr></tbody></table><h4 id="结构型设计模式" tabindex="-1"><a class="header-anchor" href="#结构型设计模式"><span>结构型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：外侨组员带配饰</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Facade 外观模式</strong></td><td>为复杂子系统提供一个统一的高层接口，简化调用过程</td><td>对外统一接口</td></tr><tr><td><strong>Bridge 桥接模式</strong></td><td>将抽象部分与其实现部分分离，使它们可以独立变化</td><td>抽象和实现分离</td></tr><tr><td><strong>Composite 组合模式</strong></td><td>将对象组合成树形结构以表示”整体-部分”的层次关系</td><td>整体-部分，树形结构</td></tr><tr><td><strong>Flyweight 享元模式</strong></td><td>通过共享技术来高效地支持大量细粒度对象的重用</td><td>细粒度，共享</td></tr><tr><td><strong>Proxy 代理模式</strong></td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>代理控制</td></tr><tr><td><strong>Adapter 适配器模式</strong></td><td>将一个类的接口转换为另一个接口，使原本不兼容的类可以协同工作</td><td>转换，兼容接口</td></tr><tr><td><strong>Decorator 装饰模式</strong></td><td>动态地给对象添加额外的职责，相比继承更加灵活</td><td>附加职责</td></tr></tbody></table><h4 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式"><span>行为型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：观摩对(迭)策，责令解放，戒忘台</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Observer 观察者模式</strong></td><td>定义对象间的一对多依赖关系，当一个对象状态改变时自动通知所有依赖对象</td><td>通知、自动更新</td></tr><tr><td><strong>Template Method 模板方法模式</strong></td><td>定义算法框架，允许子类在不改变结构的情况下重写特定步骤</td><td>子类可重写算法步骤</td></tr><tr><td><strong>Iterator 迭代器模式</strong></td><td>提供一种方法顺序访问聚合对象的元素，而不暴露其内部表示</td><td>顺序访问，不暴露内部</td></tr><tr><td><strong>Strategy 策略模式</strong></td><td>定义一系列算法，将每个算法封装在独立的类中，并使它们可以相互替换</td><td>算法替换</td></tr><tr><td><strong>Chain of Responsibility 责任链模式</strong></td><td>将请求沿着处理链传递，直到有对象处理它</td><td>传递请求、职责链接</td></tr><tr><td><strong>Command 命令模式</strong></td><td>将请求封装为对象，支持可撤销操作和请求队列</td><td>日志记录、可撤销</td></tr><tr><td><strong>Interpreter 解释器模式</strong></td><td>定义语言的文法表示，并提供解释器来处理该语法</td><td>解释器，虚拟机</td></tr><tr><td><strong>Visitor 访问者模式</strong></td><td>将作用于对象结构的操作与对象本身分离，便于新增操作</td><td>数据和操作分离</td></tr><tr><td><strong>Mediator 中介者模式</strong></td><td>定义一个中介对象来封装一组对象间的交互，降低耦合度</td><td>不直接引用</td></tr><tr><td><strong>Memento 备忘录模式</strong></td><td>在不破坏封装性的前提下，捕获并保存对象的内部状态以便恢复</td><td>保存，恢复</td></tr><tr><td><strong>State 状态模式</strong></td><td>允许对象在其内部状态改变时改变它的行为</td><td>状态变成类</td></tr></tbody></table><h3 id="面向对象设计原则" tabindex="-1"><a class="header-anchor" href="#面向对象设计原则"><span>面向对象设计原则</span></a></h3><ol><li>单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭</li><li>里氏替换原则：所有引用基类的地方必须能透明的使用其子类的对象</li><li>依赖倒转原则：高层模块不应该依赖低层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>接口隔离原则：客户端不应该依赖那些它不需要的接口</li><li>合成复用原则：优先使用对象组合，而不是继承来达到复用的目的</li><li>迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</li></ol><h2 id="网络与信息安全和病毒防护" tabindex="-1"><a class="header-anchor" href="#网络与信息安全和病毒防护"><span>网络与信息安全和病毒防护</span></a></h2><h3 id="iso-osi-网络体系结构" tabindex="-1"><a class="header-anchor" href="#iso-osi-网络体系结构"><span>ISO/OSI 网络体系结构</span></a></h3><table><thead><tr><th><strong>层次</strong></th><th><strong>功能描述</strong></th><th><strong>典型协议 / 技术</strong></th><th><strong>数据单元</strong></th><th><strong>对应设备</strong></th></tr></thead><tbody><tr><td><strong>7. 应用层</strong></td><td>直接为用户应用程序提供服务（如文件传输、电子邮件、远程登录等）。</td><td>HTTP、FTP、SMTP、POP3、DNS、Telnet、SSH</td><td>消息（Message）</td><td>主机（终端设备）</td></tr><tr><td><strong>6. 表示层</strong></td><td>负责数据格式转换（如加密、压缩、解码），确保不同系统间数据格式兼容。</td><td>SSL/TLS、JPEG、MPEG、ASCII、UTF-8</td><td>数据（Data）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>5. 会话层</strong></td><td>管理主机间的通信会话（建立、维护、终止），如会话同步和错误恢复。</td><td>NFS、RPC、ZIP（会话管理）</td><td>会话数据单元</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>4. 传输层</strong></td><td>实现端到端的可靠（TCP）或不可靠（UDP）数据传输，处理流量控制和错误恢复。</td><td>TCP、UDP、SPX（Novell）</td><td>段（Segment）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>3. 网络层</strong></td><td>负责网络间的逻辑寻址和路由选择，将数据从一个网络传输到另一个网络。</td><td>IP、ICMP、IGMP、OSPF、BGP</td><td>数据包（Packet）</td><td>路由器（Router）</td></tr><tr><td><strong>2. 数据链路层</strong></td><td>将物理层的比特流封装为帧，实现相邻节点间的可靠传输（错误检测、流量控制）。</td><td>Ethernet、PPP、HDLC、VLAN、802.11（Wi-Fi）</td><td>帧（Frame）</td><td>交换机（Switch）、网桥（Bridge）、网卡（NIC）</td></tr><tr><td><strong>1. 物理层</strong></td><td>定义物理设备的电气、机械特性，传输原始比特流（0/1 信号）。</td><td>IEEE 802.3（以太网）、RJ-45、光纤、同轴电缆</td><td>比特（Bit）</td><td>集线器（Hub）、中继器（Repeater）、网卡（NIC）</td></tr></tbody></table><p>以下是对网络协议、网络安全、加密技术及常见网络诊断命令的优化整理，采用清晰的结构化格式：</p><hr><h3 id="一、网络协议" tabindex="-1"><a class="header-anchor" href="#一、网络协议"><span><strong>一、网络协议</strong></span></a></h3><h4 id="_1-局域网协议" tabindex="-1"><a class="header-anchor" href="#_1-局域网协议"><span><strong>1. 局域网协议</strong></span></a></h4><table><thead><tr><th><strong>协议标准</strong></th><th><strong>速率</strong></th><th><strong>传输介质</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>IEEE 802.3</strong></td><td>10Mbps</td><td>同轴电缆</td><td>标准以太网协议，基础局域网通信。</td></tr><tr><td><strong>IEEE 802.3u</strong></td><td>100Mbps</td><td>双绞线</td><td>快速以太网协议，支持更高带宽。</td></tr><tr><td><strong>IEEE 802.3z</strong></td><td>1Gbps</td><td>光纤/双绞线</td><td>千兆以太网协议，支持光纤或超五类双绞线。</td></tr></tbody></table><hr><h4 id="_2-网络层协议" tabindex="-1"><a class="header-anchor" href="#_2-网络层协议"><span><strong>2. 网络层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>功能</strong></th><th><strong>关键特性</strong></th></tr></thead><tbody><tr><td><strong>IP协议</strong></td><td>负责寻址和路由，将数据包从源传到目标。</td><td><strong>无连接、不可靠</strong>，仅保证尽力传输。</td></tr><tr><td><strong>ICMP协议</strong></td><td>网络诊断与错误报告（如ping命令）。</td><td>属于IP协议的补充，用于检测网络连通性。</td></tr><tr><td><strong>ARP协议</strong></td><td>将IP地址映射为物理地址（MAC）。</td><td><strong>IP → MAC</strong>，用于本地网络通信。</td></tr><tr><td><strong>RARP协议</strong></td><td>将物理地址（MAC）映射为IP地址。</td><td><strong>MAC → IP</strong>，常用于无盘工作站启动。</td></tr></tbody></table><hr><h4 id="_3-传输层协议" tabindex="-1"><a class="header-anchor" href="#_3-传输层协议"><span><strong>3. 传输层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>可靠性</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>TCP协议</strong></td><td><strong>可靠</strong></td><td>面向连接，三次握手建立连接，保证数据有序、无错传输。</td><td>文件传输（FTP）、网页浏览（HTTP）</td></tr><tr><td><strong>UDP协议</strong></td><td><strong>不可靠</strong></td><td>无连接，低延迟，适用于实时性要求高的场景。</td><td>视频通话、在线游戏、DNS查询</td></tr></tbody></table><hr><h4 id="_4-应用层协议" tabindex="-1"><a class="header-anchor" href="#_4-应用层协议"><span><strong>4. 应用层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>传输协议</strong></th><th><strong>端口</strong></th><th><strong>功能</strong></th><th><strong>可靠性</strong></th></tr></thead><tbody><tr><td><strong>HTTP</strong></td><td>TCP</td><td>80</td><td>超文本传输协议，用于网页浏览。</td><td>可靠</td></tr><tr><td><strong>HTTPS</strong></td><td>TCP</td><td>443</td><td>HTTP + SSL/TLS加密，安全传输。</td><td>可靠</td></tr><tr><td><strong>FTP</strong></td><td>TCP</td><td>21 (控制) <br> 20 (数据)</td><td>文件传输，支持文件上传/下载。</td><td>可靠</td></tr><tr><td><strong>DNS</strong></td><td>UDP</td><td>53</td><td>域名解析，将域名转换为IP地址。</td><td>不可靠</td></tr><tr><td><strong>DHCP</strong></td><td>UDP</td><td>67/68</td><td>动态分配IP地址，客户端/服务器模式，默认租期8天。</td><td>不可靠</td></tr><tr><td><strong>SMTP</strong></td><td>TCP</td><td>25</td><td>邮件发送协议，使用ASCII格式。</td><td>可靠</td></tr><tr><td><strong>POP3</strong></td><td>TCP</td><td>110</td><td>邮件接收协议，从服务器下载邮件。</td><td>可靠</td></tr><tr><td><strong>Telnet</strong></td><td>TCP</td><td>23</td><td>远程登录，明文传输（不安全）。</td><td>可靠</td></tr></tbody></table><hr><h3 id="二、网络安全" tabindex="-1"><a class="header-anchor" href="#二、网络安全"><span><strong>二、网络安全</strong></span></a></h3><h4 id="_1-核心要素" tabindex="-1"><a class="header-anchor" href="#_1-核心要素"><span><strong>1. 核心要素</strong></span></a></h4><ul><li><strong>保密性</strong>：数据仅对授权用户可见。</li><li><strong>完整性</strong>：数据未被篡改。</li><li><strong>可用性</strong>：系统资源可被授权用户随时访问。</li><li><strong>可控性</strong>：对网络行为和资源有控制权。</li><li><strong>不可抵赖性</strong>：操作行为可追溯，不可否认。</li></ul><hr><h4 id="_2-防火墙" tabindex="-1"><a class="header-anchor" href="#_2-防火墙"><span><strong>2. 防火墙</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>层级</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>网络级防火墙</strong></td><td>网络层</td><td>基于包过滤，检查IP、端口、协议等。</td><td><strong>优点</strong>：速度快，透明性高；<br><strong>缺点</strong>：无法检测内部伪装数据。</td></tr><tr><td><strong>应用级防火墙</strong></td><td>应用层</td><td>深度检测数据内容，如代理服务器。</td><td><strong>优点</strong>：安全性高；<br><strong>缺点</strong>：效率低，资源消耗大。</td></tr></tbody></table><p><strong>DMZ（非军事区）</strong>：</p><ul><li>位于内外网之间，存放Web服务器、邮件服务器等对外服务，增强内网安全。</li></ul><hr><h4 id="_3-病毒与木马" tabindex="-1"><a class="header-anchor" href="#_3-病毒与木马"><span><strong>3. 病毒与木马</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>病毒</strong></td><td>自我复制，破坏数据或系统功能。</td><td>CIH（破坏硬件）、宏病毒（如“美丽沙”）</td></tr><tr><td><strong>木马</strong></td><td>隐藏的后门程序，窃取数据或控制权。</td><td>冰河、特洛伊木马</td></tr><tr><td><strong>蠕虫</strong></td><td>通过网络自主传播，无需用户干预。</td><td>熊猫烧香、冲击波</td></tr></tbody></table><hr><h4 id="_4-网络攻击类型" tabindex="-1"><a class="header-anchor" href="#_4-网络攻击类型"><span><strong>4. 网络攻击类型</strong></span></a></h4><table><thead><tr><th><strong>攻击类型</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>拒绝服务（DoS）</strong></td><td>洪泛网络资源，导致合法用户无法访问。</td><td>SYN Flood、CC攻击</td></tr><tr><td><strong>中间人（MITM）</strong></td><td>窃听或篡改通信数据。</td><td>ARP欺骗、DNS劫持</td></tr><tr><td><strong>重放攻击</strong></td><td>重复发送合法数据包以达到恶意目的。</td><td>窃取认证信息</td></tr><tr><td><strong>SQL注入</strong></td><td>通过输入恶意SQL代码攻击数据库。</td><td>篡改或窃取数据</td></tr><tr><td><strong>XSS</strong></td><td>在网页中注入恶意脚本，攻击用户浏览器。</td><td>盗取Cookie、会话令牌</td></tr></tbody></table><hr><h3 id="三、加密技术" tabindex="-1"><a class="header-anchor" href="#三、加密技术"><span><strong>三、加密技术</strong></span></a></h3><h4 id="_1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-基本概念"><span><strong>1. 基本概念</strong></span></a></h4><ul><li><strong>明文</strong>：原始数据。</li><li><strong>密文</strong>：加密后的数据。</li><li><strong>加密/解密</strong>：通过算法和密钥转换数据。</li><li><strong>对称加密</strong>：加密/解密使用同一密钥。</li><li><strong>非对称加密</strong>：加密/解密使用公钥和私钥。</li></ul><hr><h4 id="_2-对称加密算法" tabindex="-1"><a class="header-anchor" href="#_2-对称加密算法"><span><strong>2. 对称加密算法</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>DES</strong></td><td>56位密钥，速度快，但安全性低。</td><td>历史遗留系统</td></tr><tr><td><strong>3DES</strong></td><td>三重DES，安全性增强，但效率低。</td><td>金融、支付系统</td></tr><tr><td><strong>AES</strong></td><td>128/192/256位密钥，安全性高，效率适中。</td><td>现代加密标准（如SSL/TLS）</td></tr><tr><td><strong>RC-5/IDEA</strong></td><td>可变参数，灵活性高。</td><td>专用加密场景</td></tr></tbody></table><hr><h4 id="_3-非对称加密算法" tabindex="-1"><a class="header-anchor" href="#_3-非对称加密算法"><span><strong>3. 非对称加密算法</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>RSA</strong></td><td>基于大整数分解，密钥长度长（1024/2048位）。</td><td>数字签名、SSL/TLS握手</td></tr><tr><td><strong>ECC</strong></td><td>基于椭圆曲线数学，密钥长度短，安全性高。</td><td>移动设备、物联网</td></tr><tr><td><strong>ElGamal</strong></td><td>基于Diffie-Hellman密钥交换，支持加密和数字签名。</td><td>安全通信协议</td></tr></tbody></table><hr><h3 id="四、常见网络诊断命令" tabindex="-1"><a class="header-anchor" href="#四、常见网络诊断命令"><span><strong>四、常见网络诊断命令</strong></span></a></h3><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th><th><strong>常用参数/示例</strong></th></tr></thead><tbody><tr><td><strong>ping</strong></td><td>检测网络连通性，发送ICMP回显请求。</td><td><code>ping 8.8.8.8</code></td></tr><tr><td><strong>tracert</strong></td><td>跟踪数据包路径，定位网络故障点。</td><td><code>tracert www.google.com</code></td></tr><tr><td><strong>ipconfig</strong></td><td>显示/修改TCP/IP配置（Windows）。</td><td><code>ipconfig /release</code>（释放IP）<br><code>ipconfig /flushdns</code>（清除DNS缓存）</td></tr><tr><td><strong>nslookup</strong></td><td>查询DNS记录，验证域名解析。</td><td><code>nslookup baidu.com</code></td></tr><tr><td><strong>netstat</strong></td><td>显示网络连接、端口状态及路由表。</td><td><code>netstat -ano</code>（查看所有连接）</td></tr></tbody></table><h2 id="数据库技术" tabindex="-1"><a class="header-anchor" href="#数据库技术"><span>数据库技术</span></a></h2><h3 id="数据库基础知识" tabindex="-1"><a class="header-anchor" href="#数据库基础知识"><span>数据库基础知识</span></a></h3><ul><li><strong>数据库</strong>：是指按照一定的结构来存储和管理数据的仓库。</li><li><strong>数据库管理系统（DBMS）</strong>：是用于创建和管理数据库的软件系统。它允许用户定义、创建、维护和控制对数据库的访问。</li><li><strong>数据库系统（DBS）</strong>：由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员（DBA）和用户构成的整体。</li></ul><h4 id="数据库类型" tabindex="-1"><a class="header-anchor" href="#数据库类型"><span>数据库类型</span></a></h4><ol><li><p><strong>关系型数据库（RDBMS）</strong></p><ul><li>使用表格形式存储数据，其中行代表记录，列表示字段。</li><li>支持SQL作为查询语言。</li><li>常见的关系型数据库有MySQL、PostgreSQL、Oracle、Microsoft SQL Server等。</li></ul></li><li><p><strong>非关系型数据库（NoSQL）</strong></p><ul><li>不使用传统的表格形式存储数据，而是采用键值对、文档、列族或图形存储方式。</li><li>更加灵活，适用于大规模分布式系统。</li><li>常见的NoSQL数据库有MongoDB（文档型）、Cassandra（列族型）、Redis（键值对型）、Neo4j（图数据库）等。</li></ul></li></ol><h4 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型"><span>数据模型</span></a></h4><ul><li><strong>层次模型</strong>：早期的数据组织形式，以树状结构表示数据之间的关系。</li><li><strong>网状模型</strong>：比层次模型更复杂，允许一个子节点拥有多个父节点。</li><li><strong>关系模型</strong>：现代最常用的模型，基于数学理论，通过表格的形式展示数据间的联系。</li><li><strong>面向对象模型</strong>：将数据和方法封装在一起，支持复杂的对象结构。</li></ul><h4 id="sql基础" tabindex="-1"><a class="header-anchor" href="#sql基础"><span>SQL基础</span></a></h4><ul><li><strong>数据定义语言（DDL）</strong>：用于定义数据库结构，如<code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>等命令。</li><li><strong>数据操作语言（DML）</strong>：用于添加、更新、删除数据，如<code>INSERT INTO</code>, <code>UPDATE</code>, <code>DELETE FROM</code>等。</li><li><strong>数据查询语言（DQL）</strong>：用于检索数据，主要命令为<code>SELECT</code>。</li><li><strong>数据控制语言（DCL）</strong>：用于权限管理，如<code>GRANT</code>, <code>REVOKE</code>等命令。</li></ul><h4 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h4><ul><li><strong>事务</strong>：指作为一个逻辑单元执行的一系列操作，要么全部成功，要么全部失败回滚。</li><li><strong>ACID属性</strong>： <ul><li><strong>原子性（Atomicity）</strong>：事务是不可分割的工作单位，要么都做，要么都不做。</li><li><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态。</li><li><strong>隔离性（Isolation）</strong>：并发事务之间相互不影响。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，它对数据库的影响就是永久性的。</li></ul></li></ul><h3 id="e-r-模型和关系模型" tabindex="-1"><a class="header-anchor" href="#e-r-模型和关系模型"><span>E-R 模型和关系模型</span></a></h3><h4 id="一、e-r模型-实体-联系模型" tabindex="-1"><a class="header-anchor" href="#一、e-r模型-实体-联系模型"><span><strong>一、E-R模型（实体-联系模型）</strong></span></a></h4><h5 id="_1-基本概念-1" tabindex="-1"><a class="header-anchor" href="#_1-基本概念-1"><span><strong>1. 基本概念</strong></span></a></h5><ul><li><strong>定义</strong>：E-R模型是用户视角的数据建模工具，通过实体、属性和联系描述现实世界的信息结构。 <ul><li><strong>实体（Entity）</strong>：现实世界可区分的对象，用<strong>矩形</strong>表示（如学生、课程）。 <ul><li><strong>软考重点</strong>：需明确实体的业务含义，避免遗漏关键实体（如“订单”与“订单详情”）。</li></ul></li><li><strong>属性（Attribute）</strong>：实体的特征，用<strong>椭圆</strong>表示，分为： <ul><li><strong>主属性</strong>（主键）：唯一标识实体（如学号），需用<strong>下划线或加粗</strong>标注。</li><li><strong>次属性</strong>：非唯一属性（如姓名、年龄）。</li><li><strong>软考重点</strong>：主键选择需唯一且最小化，避免多值属性（如“电话”可能为多值需单独表）。</li></ul></li><li><strong>联系（Relationship）</strong>：实体间的关联，用<strong>菱形</strong>表示，分为： <ul><li><strong>一对一（1:1）</strong>：如“身份证号”与“个人”的关系。</li><li><strong>一对多（1:N）</strong>：如“部门”与“员工”的关系。</li><li><strong>多对多（M:N）</strong>：如“学生”与“课程”的选课关系。</li><li><strong>软考重点</strong>：联系类型判断是考试高频考点，需结合业务场景（如“教师授课”是1:N还是N:M）。</li></ul></li></ul></li></ul><hr><h5 id="_2-e-r图设计步骤" tabindex="-1"><a class="header-anchor" href="#_2-e-r图设计步骤"><span><strong>2. E-R图设计步骤</strong></span></a></h5><ol><li><strong>确定实体</strong>：明确系统涉及的对象（如学生、教师、课程）。</li><li><strong>定义属性</strong>：为每个实体列出属性，并标记主属性。 <ul><li><strong>软考重点</strong>：主键需唯一且不可为空，避免冗余属性。</li></ul></li><li><strong>分析联系</strong>：确定实体间的关联类型（1:1、1:N、M:N）。</li><li><strong>转换为关系模式</strong>： <ul><li><strong>一对一（1:1）</strong>：合并到任意一端实体的表中，或单独建表。 <ul><li><strong>软考重点</strong>：若合并需考虑业务需求，考试中常考“如何选择更优方案”。</li></ul></li><li><strong>一对多（1:N）</strong>：在“多”端实体表中添加“一”端的主键作为外键。 <ul><li><strong>软考重点</strong>：外键命名需规范（如<code>DepartmentID</code>作为员工表的外键）。</li></ul></li><li><strong>多对多（M:N）</strong>：创建中间表，包含双方主键作为联合主键（如<code>学生选课表</code>包含学生学号和课程号）。 <ul><li><strong>软考重点</strong>：多对多联系必须转为中间表，否则视为错误设计。</li></ul></li></ul></li></ol><hr><h5 id="_3-转换规则与常见错误" tabindex="-1"><a class="header-anchor" href="#_3-转换规则与常见错误"><span><strong>3. 转换规则与常见错误</strong></span></a></h5><ul><li><strong>多对多联系</strong>：必须转为中间表，联合主键需包含双方主键。</li><li><strong>三个实体的联系</strong>：需拆分为两个二元联系，分别建表。 <ul><li><strong>软考重点</strong>：考试中常出现“三元联系”转换错误，需拆分后设计中间表。</li></ul></li></ul><hr><hr><h4 id="二、关系模型" tabindex="-1"><a class="header-anchor" href="#二、关系模型"><span><strong>二、关系模型</strong></span></a></h4><hr><h5 id="_1-基本概念-2" tabindex="-1"><a class="header-anchor" href="#_1-基本概念-2"><span><strong>1. 基本概念</strong></span></a></h5><ul><li><strong>定义</strong>：关系模型以二维表结构组织数据，所有信息均通过表表示。 <ul><li><strong>关系（Relation）</strong>：二维表的实例，由行（元组）和列（属性）组成。</li><li><strong>关系模式（Relation Schema）</strong>：表的结构定义（如<code>学生（学号，姓名，年龄）</code>）。 <ul><li><strong>软考重点</strong>：需区分“关系”与“关系模式”的区别。</li></ul></li></ul></li></ul><hr><h5 id="_2-范式理论-高频考点" tabindex="-1"><a class="header-anchor" href="#_2-范式理论-高频考点"><span><strong>2. 范式理论（高频考点）</strong></span></a></h5><ul><li><strong>规范化目标</strong>：消除冗余、减少更新异常。</li><li><strong>主要范式</strong>： <ul><li><strong>1NF（原子性）</strong>：每个属性值不可再分（如“地址”需拆分为省、市、街道）。</li><li><strong>2NF（无部分依赖）</strong>：非主属性不依赖主键的子集。 <ul><li><strong>软考重点</strong>：判断是否存在部分依赖（如表<code>订单（订单号，客户ID，客户姓名，金额）</code>中，客户姓名依赖客户ID而非订单号）。</li></ul></li><li><strong>3NF（无传递依赖）</strong>：非主属性不依赖其他非主属性。 <ul><li><strong>软考重点</strong>：传递依赖的判断（如“学号→班级→班主任”需拆分为两个表）。</li></ul></li><li><strong>BCNF（Boyce-Codd范式）</strong>：严格于3NF，所有函数依赖的决定因素必须是候选键。 <ul><li><strong>软考重点</strong>：BCNF与3NF的区别是考试必考（如存在多个候选键时需满足BCNF）。</li></ul></li><li><strong>4NF（无多值依赖）</strong>：处理多对多关系，需拆分为多个表。</li></ul></li></ul><hr><h5 id="_3-关系操作与sql" tabindex="-1"><a class="header-anchor" href="#_3-关系操作与sql"><span><strong>3. 关系操作与SQL</strong></span></a></h5><ul><li><strong>基本操作</strong>： <ul><li><strong>选择（SELECT）</strong>：筛选符合条件的元组。</li><li><strong>投影（PROJECT）</strong>：提取指定列。</li><li><strong>连接（JOIN）</strong>：通过外键关联多表数据（如<code>学生表 JOIN 选课表 ON 学号</code>）。 <ul><li><strong>软考重点</strong>：内连接、外连接的区别及使用场景。</li></ul></li></ul></li><li><strong>高级操作</strong>： <ul><li><strong>聚合函数</strong>：<code>SUM</code>, <code>AVG</code>, <code>COUNT</code>等。</li><li><strong>子查询</strong>：嵌套查询实现复杂条件（如<code>WHERE 学号 IN (SELECT 学号 FROM 选课表)</code>）。 <ul><li><strong>软考重点</strong>：子查询的性能优化及语法规范。</li></ul></li></ul></li></ul><hr><h5 id="_4-事务与并发控制" tabindex="-1"><a class="header-anchor" href="#_4-事务与并发控制"><span><strong>4. 事务与并发控制</strong></span></a></h5><ul><li><strong>ACID特性</strong>： <ul><li><strong>原子性（Atomicity）</strong>：事务要么全做，要么全不。</li><li><strong>一致性（Consistency）</strong>：事务前后数据合法。</li><li><strong>隔离性（Isolation）</strong>：并发事务互不干扰（如脏读、不可重复读的防范）。</li><li><strong>持久性（Durability）</strong>：提交后数据永久保存。 <ul><li><strong>软考重点</strong>：事务隔离级别（READ COMMITTED、REPEATABLE READ）及锁机制。</li></ul></li></ul></li><li><strong>死锁处理</strong>：考试中常考“如何避免和解决死锁”。</li></ul><hr><hr><h4 id="三、e-r模型与关系模型的对比-结合考点" tabindex="-1"><a class="header-anchor" href="#三、e-r模型与关系模型的对比-结合考点"><span><strong>三、E-R模型与关系模型的对比（结合考点）</strong></span></a></h4><table><thead><tr><th><strong>特征</strong></th><th><strong>E-R模型</strong></th><th><strong>关系模型</strong></th></tr></thead><tbody><tr><td><strong>表示形式</strong></td><td>图形化（实体、属性、联系）</td><td>二维表结构</td></tr><tr><td><strong>设计阶段</strong></td><td>概念模型（用户与设计师沟通工具）</td><td>逻辑模型（数据库具体结构设计）</td></tr><tr><td><strong>转换规则</strong></td><td>需转化为关系模式（如M:N转中间表）</td><td>直接对应数据库表结构</td></tr><tr><td><strong>联系处理</strong></td><td>显式菱形表示联系</td><td>通过外键隐式关联</td></tr><tr><td><strong>考试重点</strong></td><td>E-R图绘制、联系类型判断、中间表设计</td><td>范式规范化、SQL查询、事务ACID特性</td></tr></tbody></table><hr><hr><h4 id="四、综合示例与考点解析" tabindex="-1"><a class="header-anchor" href="#四、综合示例与考点解析"><span><strong>四、综合示例与考点解析</strong></span></a></h4><p><strong>题目</strong>：<br> 设计学生选课系统的E-R图，并转换为关系模式。<br><strong>解答步骤</strong>：</p><ol><li><strong>E-R图设计</strong>： <ul><li>实体：学生（学号（主键），姓名，年龄）、课程（课程号（主键），课程名，学分）。</li><li>联系：选课（学号，课程号，成绩）。</li><li><strong>考点</strong>：需正确标注主键（学号、课程号），联系类型为M:N。</li></ul></li><li><strong>关系模式转换</strong>： <ul><li><strong>学生表</strong>：<code>Student(Sno, Sname, Sage)</code>（主键：Sno）。</li><li><strong>课程表</strong>：<code>Course(Cno, Cname, Credit)</code>（主键：Cno）。</li><li><strong>选课表</strong>：<code>SC(Sno, Cno, Grade)</code>（主键：(Sno, Cno)，外键：Sno→Student.Sno，Cno→Course.Cno）。</li><li><strong>考点</strong>：中间表需包含双方主键作为联合主键，外键命名规范。</li></ul></li></ol><hr><h4 id="五、关键考点总结" tabindex="-1"><a class="header-anchor" href="#五、关键考点总结"><span><strong>五、关键考点总结</strong></span></a></h4><ol><li><strong>E-R模型</strong>： <ul><li>E-R图绘制：实体、属性、联系的正确标注及类型判断。</li><li>多对多联系转中间表，避免遗漏。</li><li>主键与外键的规范设置。</li></ul></li><li><strong>关系模型</strong>： <ul><li>范式规范化：3NF、BCNF的条件及拆分反例。</li><li>SQL查询：连接、子查询、聚合函数的正确使用。</li><li>事务ACID特性及并发控制（锁、隔离级别）。</li></ul></li></ol><h3 id="sql-语言" tabindex="-1"><a class="header-anchor" href="#sql-语言"><span>SQL 语言</span></a></h3><h4 id="基础查询-select" tabindex="-1"><a class="header-anchor" href="#基础查询-select"><span><strong>基础查询（SELECT）</strong></span></a></h4><p><strong>作用</strong>：从数据库中检索数据。 <strong>基本语法</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列名1, 列名2, ... </span></span>
<span class="line"><span>FROM 表名 </span></span>
<span class="line"><span>[WHERE 条件] </span></span>
<span class="line"><span>[GROUP BY 分组列] </span></span>
<span class="line"><span>[HAVING 分组条件] </span></span>
<span class="line"><span>[ORDER BY 排序列 ASC/DESC] </span></span>
<span class="line"><span>[LIMIT 分页参数];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-基础用法" tabindex="-1"><a class="header-anchor" href="#_1-基础用法"><span><strong>1. 基础用法</strong></span></a></h5><ul><li><p><strong>查询所有列</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名;  -- 返回表中所有行和列</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT * FROM 学生;</code><strong>考点</strong>：<code>*</code> 表示所有列，但实际应用中需避免滥用以减少数据量。</p></li><li><p><strong>查询指定列</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列1, 列2 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT 学号, 姓名 FROM 学生;</code><strong>考点</strong>：明确指定列可提高查询效率，避免冗余数据。</p></li><li><p><strong>别名（AS）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列 AS 新列名 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT 姓名 AS 学生姓名 FROM 学生;</code><strong>考点</strong>：<code>AS</code> 可省略，但增强可读性（如 <code>SELECT 姓名 学生姓名</code>）。</p></li><li><p><strong>去重（DISTINCT）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT DISTINCT 列 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT DISTINCT 部门 FROM 员工;</code><strong>考点</strong>：<code>DISTINCT</code> 仅对指定列去重，需与聚合函数区分。</p></li></ul><hr><h4 id="二、条件查询-where" tabindex="-1"><a class="header-anchor" href="#二、条件查询-where"><span><strong>二、条件查询（WHERE）</strong></span></a></h4><p><strong>作用</strong>：筛选满足条件的记录。 <strong>常用运算符</strong>：</p><ul><li><strong>比较运算符</strong>：<code>=</code>、<code>!=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>。</li><li><strong>逻辑运算符</strong>：<code>AND</code>、<code>OR</code>、<code>NOT</code>。</li><li><strong>范围查询</strong>：<code>BETWEEN ... AND ...</code>。</li><li><strong>模糊匹配</strong>：<code>LIKE</code>（结合通配符 <code>%</code> 和 <code>_</code>）。</li></ul><h5 id="_1-单条件与多条件" tabindex="-1"><a class="header-anchor" href="#_1-单条件与多条件"><span><strong>1. 单条件与多条件</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 单条件</span></span>
<span class="line"><span>SELECT * FROM 表名 WHERE 列 = 值;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 多条件</span></span>
<span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列1 = 值1 AND 列2 &gt; 值2 </span></span>
<span class="line"><span>OR 列3 IS NULL;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：</p><ul><li><code>SELECT * FROM 学生 WHERE 年龄 = 20;</code></li><li><code>SELECT * FROM 员工 WHERE 工资 &gt; 10000 AND 部门 = &#39;技术部&#39;;</code></li></ul><hr><h5 id="_2-范围查询-between" tabindex="-1"><a class="header-anchor" href="#_2-范围查询-between"><span><strong>2. 范围查询（BETWEEN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列 BETWEEN 值1 AND 值2;  -- 包含边界值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT * FROM 学生 WHERE 年龄 BETWEEN 18 AND 22;</code></p><hr><h5 id="_3-模糊查询-like" tabindex="-1"><a class="header-anchor" href="#_3-模糊查询-like"><span><strong>3. 模糊查询（LIKE）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列 LIKE &#39;模式&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>%</code>：匹配任意字符（0个或多个）。</li><li><code>_</code>：匹配单个字符。 <strong>示例</strong>：</li><li><code>SELECT * FROM 学生 WHERE 姓名 LIKE &#39;张%&#39;;</code> -- 查询姓“张”的学生。</li><li><code>SELECT * FROM 商品 WHERE 名称 LIKE &#39;A__&#39;;</code> -- 查询以“A”开头且长度为3的名称。</li></ul><hr><h4 id="三、聚合函数与分组-group-by-having" tabindex="-1"><a class="header-anchor" href="#三、聚合函数与分组-group-by-having"><span><strong>三、聚合函数与分组（GROUP BY/HAVING）</strong></span></a></h4><p><strong>作用</strong>：对数据进行分组统计。 <strong>常用聚合函数</strong>：</p><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>COUNT(*)</code></td><td>统计总行数</td><td><code>SELECT COUNT(*) FROM 学生</code></td></tr><tr><td><code>SUM(列)</code></td><td>求和</td><td><code>SELECT SUM(销售额) FROM 销售</code></td></tr><tr><td><code>AVG(列)</code></td><td>计算平均值</td><td><code>SELECT AVG(年龄) FROM 学生</code></td></tr><tr><td><code>MAX(列)</code></td><td>取最大值</td><td><code>SELECT MAX(成绩) FROM 考试</code></td></tr><tr><td><code>MIN(列)</code></td><td>取最小值</td><td><code>SELECT MIN(价格) FROM 商品</code></td></tr></tbody></table><h5 id="_1-分组查询-group-by" tabindex="-1"><a class="header-anchor" href="#_1-分组查询-group-by"><span><strong>1. 分组查询（GROUP BY）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 分组列, 聚合函数(列) </span></span>
<span class="line"><span>FROM 表名 </span></span>
<span class="line"><span>GROUP BY 分组列 </span></span>
<span class="line"><span>[HAVING 条件];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：</p><ul><li><p>统计各部门平均工资</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 部门, AVG(工资) AS 平均工资 </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>GROUP BY 部门;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>过滤分组结果（HAVING）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 部门, COUNT(*) AS 人数 </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>GROUP BY 部门 </span></span>
<span class="line"><span>HAVING 人数 &gt; 5;  -- 过滤员工数超过5人的部门</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h4 id="四、连接查询-join" tabindex="-1"><a class="header-anchor" href="#四、连接查询-join"><span><strong>四、连接查询（JOIN）</strong></span></a></h4><p><strong>作用</strong>：合并多表数据。 <strong>常见连接类型</strong>：</p><table><thead><tr><th>连接类型</th><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><strong>内连接（INNER JOIN）</strong></td><td><code>ON 条件</code></td><td>返回两个表中满足条件的匹配行。</td></tr><tr><td><strong>左连接（LEFT JOIN）</strong></td><td><code>LEFT JOIN ... ON 条件</code></td><td>返回左表所有行，右表匹配则返回，否则为NULL。</td></tr><tr><td><strong>右连接（RIGHT JOIN）</strong></td><td><code>RIGHT JOIN ... ON 条件</code></td><td>返回右表所有行，左表匹配则返回，否则为NULL。</td></tr><tr><td><strong>全连接（FULL JOIN）</strong></td><td><code>FULL JOIN ... ON 条件</code></td><td>返回两个表所有行，不匹配则对应列为NULL（部分数据库不支持）。</td></tr></tbody></table><h5 id="_1-内连接-inner-join" tabindex="-1"><a class="header-anchor" href="#_1-内连接-inner-join"><span><strong>1. 内连接（INNER JOIN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学生.学号, 课程.课程名, 成绩 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>INNER JOIN 选课 ON 学生.学号 = 选课.学号 </span></span>
<span class="line"><span>INNER JOIN 课程 ON 选课.课程号 = 课程.课程号;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-左连接-left-join" tabindex="-1"><a class="header-anchor" href="#_2-左连接-left-join"><span><strong>2. 左连接（LEFT JOIN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 表1.列, 表2.列 </span></span>
<span class="line"><span>FROM 表1 </span></span>
<span class="line"><span>LEFT JOIN 表2 </span></span>
<span class="line"><span>ON 表1.关联列 = 表2.关联列;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学生.学号, 学生.姓名, 选课.课程号 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>LEFT JOIN 选课 ON 学生.学号 = 选课.学号;  -- 包含未选课的学生</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="五、子查询-subquery" tabindex="-1"><a class="header-anchor" href="#五、子查询-subquery"><span><strong>五、子查询（Subquery）</strong></span></a></h4><p><strong>作用</strong>：嵌套查询实现复杂条件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 查询选修过课程ID为 &#39;C001&#39; 的学生</span></span>
<span class="line"><span>SELECT 姓名 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>WHERE 学号 IN (SELECT 学号 FROM 选课 WHERE 课程ID = &#39;C001&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 查询比平均工资高的员工</span></span>
<span class="line"><span>SELECT * </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>WHERE 工资 &gt; (SELECT AVG(工资) FROM 员工);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="六、排序与分页-order-by-limit" tabindex="-1"><a class="header-anchor" href="#六、排序与分页-order-by-limit"><span><strong>六、排序与分页（ORDER BY/LIMIT）</strong></span></a></h4><h5 id="_1-排序-order-by" tabindex="-1"><a class="header-anchor" href="#_1-排序-order-by"><span><strong>1. 排序（ORDER BY）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>ORDER BY 列 ASC/DESC;  -- ASC升序（默认），DESC降序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 学生 </span></span>
<span class="line"><span>ORDER BY 年龄 DESC, 姓名 ASC;  -- 先按年龄降序，再按姓名升序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-分页-limit-offset" tabindex="-1"><a class="header-anchor" href="#_2-分页-limit-offset"><span><strong>2. 分页（LIMIT/OFFSET）</strong></span></a></h5><ul><li><p>MySQL/PostgreSQL</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>LIMIT 偏移量, 行数;  -- 如 LIMIT 0, 10 表示第1页，每页10条</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>SQL Server</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT TOP 行数 * FROM 表名 </span></span>
<span class="line"><span>WHERE 条件 NOT IN (SELECT TOP 偏移量 * FROM 表名);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h4 id="七、高级查询技巧" tabindex="-1"><a class="header-anchor" href="#七、高级查询技巧"><span><strong>七、高级查询技巧</strong></span></a></h4><h5 id="_1-常见表表达式-cte" tabindex="-1"><a class="header-anchor" href="#_1-常见表表达式-cte"><span><strong>1. 常见表表达式（CTE）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>WITH 临时表名 AS (子查询) </span></span>
<span class="line"><span>SELECT * FROM 临时表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>WITH 高薪员工 AS (</span></span>
<span class="line"><span>  SELECT * FROM 员工 WHERE 工资 &gt; 20000</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT 部门, COUNT(*) AS 高薪人数 </span></span>
<span class="line"><span>FROM 高薪员工 </span></span>
<span class="line"><span>GROUP BY 部门;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-窗口函数-window-functions" tabindex="-1"><a class="header-anchor" href="#_2-窗口函数-window-functions"><span><strong>2. 窗口函数（Window Functions）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列, </span></span>
<span class="line"><span>       SUM(列) OVER (PARTITION BY 分组列) AS 累计值 </span></span>
<span class="line"><span>FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学号, 课程号, 成绩, </span></span>
<span class="line"><span>       AVG(成绩) OVER (PARTITION BY 学号) AS 学生平均分 </span></span>
<span class="line"><span>FROM 选课;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-联合查询-union-union-all" tabindex="-1"><a class="header-anchor" href="#_3-联合查询-union-union-all"><span><strong>3. 联合查询（UNION/UNION ALL）</strong></span></a></h5><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 列 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 表1 </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UNION</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [ALL] </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 列 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 表2;  </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 去重，UNION ALL保留所有行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="insert-插入数据" tabindex="-1"><a class="header-anchor" href="#insert-插入数据"><span><strong>INSERT（插入数据）</strong></span></a></h4><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>INSERT INTO 表名 (列1, 列2, ...) </span></span>
<span class="line"><span>VALUES (值1, 值2, ...);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>默认值/NULL</strong>：未指定列时需允许 <code>NULL</code> 或设置默认值。</li><li><strong>批量插入</strong>：<code>INSERT INTO 表A SELECT * FROM 表B</code>。</li></ul></li></ul><hr><h4 id="_3-update-更新数据" tabindex="-1"><a class="header-anchor" href="#_3-update-更新数据"><span><strong>3. UPDATE（更新数据）</strong></span></a></h4><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>UPDATE 表名 </span></span>
<span class="line"><span>SET 列1 = 新值, 列2 = 新值 </span></span>
<span class="line"><span>WHERE 条件;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>WHERE 条件</strong>：必须明确条件，否则会更新全表。</li><li><strong>自增字段</strong>：若表有自增主键，需谨慎更新以避免冲突。</li></ul></li></ul><hr><h4 id="_4-delete-删除数据" tabindex="-1"><a class="header-anchor" href="#_4-delete-删除数据"><span><strong>4. DELETE（删除数据）</strong></span></a></h4><ul><li><p>基础语法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>DELETE FROM 表名 </span></span>
<span class="line"><span>WHERE 条件;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>外键约束</strong>：删除主表数据前需先删除从表关联数据，或设置 <code>ON DELETE CASCADE</code>。</li><li><strong>全表删除</strong>：<code>DELETE FROM 表名</code> 删除所有数据，但保留表结构。</li></ul></li></ul><h4 id="字符串与日期函数" tabindex="-1"><a class="header-anchor" href="#字符串与日期函数"><span><strong>字符串与日期函数</strong></span></a></h4><hr><h5 id="_1-字符串函数" tabindex="-1"><a class="header-anchor" href="#_1-字符串函数"><span><strong>1. 字符串函数</strong></span></a></h5><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CONCAT(列1, 列2)</code></td><td>字符串拼接</td><td><code>SELECT CONCAT(姓, 名) AS 全名 FROM 员工</code></td></tr><tr><td><code>SUBSTRING(列, 起始, 长度)</code></td><td>截取子字符串</td><td><code>SELECT SUBSTRING(电话, 4, 4) FROM 客户</code></td></tr><tr><td><code>UPPER(列)</code></td><td>转大写</td><td><code>SELECT UPPER(城市) FROM 订单</code></td></tr><tr><td><code>LOWER(列)</code></td><td>转小写</td><td><code>SELECT LOWER(邮箱) FROM 用户</code></td></tr></tbody></table><hr><h5 id="_2-日期函数" tabindex="-1"><a class="header-anchor" href="#_2-日期函数"><span><strong>2. 日期函数</strong></span></a></h5><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CURRENT_DATE()</code></td><td>获取当前日期</td><td><code>SELECT CURRENT_DATE()</code></td></tr><tr><td><code>DATE_FORMAT(日期, 格式)</code></td><td>格式化日期</td><td><code>SELECT DATE_FORMAT(出生日期, &#39;%Y-%m-%d&#39;) FROM 学生</code></td></tr><tr><td><code>DATEDIFF(日期1, 日期2)</code></td><td>计算日期差</td><td><code>SELECT DATEDIFF(&#39;2023-01-01&#39;, &#39;2022-01-01&#39;)</code></td></tr></tbody></table><hr><hr><h4 id="四、授权与收回-dcl核心考点" tabindex="-1"><a class="header-anchor" href="#四、授权与收回-dcl核心考点"><span><strong>四、授权与收回（DCL核心考点）</strong></span></a></h4><hr><h5 id="_1-grant-授权" tabindex="-1"><a class="header-anchor" href="#_1-grant-授权"><span><strong>1. GRANT（授权）</strong></span></a></h5><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>GRANT 权限1, 权限2 </span></span>
<span class="line"><span>ON 对象类型.对象名 </span></span>
<span class="line"><span>TO 用户/角色 </span></span>
<span class="line"><span>[WITH GRANT OPTION];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考权限类型</p><ul><li><strong>数据操作权限</strong>：<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>。</li><li><strong>数据定义权限</strong>：<code>CREATE</code>, <code>DROP</code>, <code>ALTER</code>。</li><li><strong>全部权限</strong>：<code>ALL PRIVILEGES</code>。</li></ul></li><li><p>常考考点</p><ul><li><p><strong>列级权限</strong>：<code>GRANT UPDATE(列名) ON 表名 TO 用户</code>。</p></li><li><p><strong>转授权</strong>：<code>WITH GRANT OPTION</code> 允许被授权用户再次授权。</p></li><li><p>对象范围</p><ul><li><code>ON 表名</code>：对指定表授权。</li><li><code>ON *.*</code>：对数据库所有对象授权。</li></ul></li><li><p>示例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 授予用户UserA对表employees的查询权限</span></span>
<span class="line"><span>GRANT SELECT ON employees TO UserA;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 授予角色Analyst对所有表的全部权限</span></span>
<span class="line"><span>GRANT ALL PRIVILEGES ON *.* TO Analyst;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 列级权限：仅允许更新price列</span></span>
<span class="line"><span>GRANT UPDATE(price) ON sales TO UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><hr><h5 id="_2-revoke-收回权限" tabindex="-1"><a class="header-anchor" href="#_2-revoke-收回权限"><span><strong>2. REVOKE（收回权限）</strong></span></a></h5><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>REVOKE 权限1, 权限2 </span></span>
<span class="line"><span>ON 对象类型.对象名 </span></span>
<span class="line"><span>FROM 用户/角色;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点</p><ul><li><p>收回转授权权限：</p></li><li><p>需明确指定<strong>GRANT OPTION</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>REVOKE GRANT OPTION FOR INSERT ON projects FROM UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>对象范围</strong>：需与 <code>GRANT</code> 时指定的范围一致。</p></li><li><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 撤销UserA对表employees的查询权限</span></span>
<span class="line"><span>REVOKE SELECT ON employees FROM UserA;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 撤销UserB对列price的更新权限</span></span>
<span class="line"><span>REVOKE UPDATE(price) ON sales FROM UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="关系代数和关系模型" tabindex="-1"><a class="header-anchor" href="#关系代数和关系模型"><span>关系代数和关系模型</span></a></h3><h3 id="关系数据库的规范化" tabindex="-1"><a class="header-anchor" href="#关系数据库的规范化"><span>关系数据库的规范化</span></a></h3><h3 id="控制功能" tabindex="-1"><a class="header-anchor" href="#控制功能"><span>控制功能</span></a></h3><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h3 id="时间-空间-复杂度" tabindex="-1"><a class="header-anchor" href="#时间-空间-复杂度"><span>时间（空间）复杂度</span></a></h3><h4 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结"><span><strong>知识点总结</strong></span></a></h4><table><thead><tr><th><strong>知识点</strong></th><th><strong>内容概述</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度定义</strong></td><td>衡量算法运行时间随输入规模增长的趋势，用大O符号表示。通常关注最坏情况下的复杂度。</td></tr><tr><td><strong>空间复杂度定义</strong></td><td>衡量算法运行所需额外存储空间随输入规模的增长趋势，同样用大O符号表示。</td></tr><tr><td><strong>计算规则</strong></td><td>1. <strong>加法规则</strong>：总复杂度取最大项（如 T(n)=O(f(n))+O(g(n)) → O(max(f(n),g(n)))）。<br>2. <strong>乘法规则</strong>：嵌套操作复杂度相乘（如 T(n)=O(f(n))×O(g(n)) → O(f(n)*g(n))）。</td></tr><tr><td><strong>渐进符号（大O）</strong></td><td>忽略低阶项和系数，保留最高阶项。例如：T(n)=2n²+3n+5 → O(n²)。</td></tr><tr><td><strong>主定理（Master Theorem）</strong></td><td>用于求解递归式的时间复杂度，适用于形如 T(n)=aT(n/b)+f(n) 的递归方程。</td></tr></tbody></table><hr><h4 id="考点归纳" tabindex="-1"><a class="header-anchor" href="#考点归纳"><span><strong>考点归纳</strong></span></a></h4><table><thead><tr><th><strong>考点</strong></th><th><strong>核心内容</strong></th></tr></thead><tbody><tr><td><strong>常见时间复杂度等级</strong></td><td>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</td></tr><tr><td><strong>时间复杂度计算步骤</strong></td><td>1. 确定基本操作（如循环内耗时最多的语句）。<br>2. 计算基本操作的执行次数。<br>3. 用大O表示法简化。</td></tr><tr><td><strong>空间复杂度计算重点</strong></td><td>区分算法所需额外空间（如递归栈、辅助数组）与输入数据本身的存储空间。</td></tr><tr><td><strong>递归算法复杂度分析</strong></td><td>时间复杂度：递归次数 × 每次递归的操作次数。<br>空间复杂度：递归深度 × 每次递归的辅助空间。</td></tr></tbody></table><hr><h4 id="常见算法复杂度表" tabindex="-1"><a class="header-anchor" href="#常见算法复杂度表"><span><strong>常见算法复杂度表</strong></span></a></h4><table><thead><tr><th><strong>算法名称</strong></th><th><strong>时间复杂度（最坏情况）</strong></th><th><strong>空间复杂度</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>直接访问数组元素</strong></td><td>O(1)</td><td>O(1)</td><td>常数时间，无需额外空间。</td></tr><tr><td><strong>顺序查找（线性查找）</strong></td><td>O(n)</td><td>O(1)</td><td>遍历数组查找元素。</td></tr><tr><td><strong>二分查找</strong></td><td>O(log n)</td><td>O(1)</td><td>有序数组的对数时间查找。</td></tr><tr><td><strong>冒泡排序</strong></td><td>O(n²)</td><td>O(1)</td><td>简单排序，原地操作。</td></tr><tr><td><strong>快速排序</strong></td><td>O(n²)</td><td>O(log n)</td><td>平均O(n log n)，最坏O(n²)（递归栈）。</td></tr><tr><td><strong>归并排序</strong></td><td>O(n log n)</td><td>O(n)</td><td>需额外空间合并子数组。</td></tr><tr><td><strong>堆排序</strong></td><td>O(n log n)</td><td>O(1)</td><td>原地排序，基于堆结构。</td></tr><tr><td><strong>插入排序</strong></td><td>O(n²)</td><td>O(1)</td><td>适合小规模或部分有序数据。</td></tr><tr><td><strong>斐波那契数列（递归）</strong></td><td>O(2ⁿ)</td><td>O(n)</td><td>指数时间，递归栈深度为n。</td></tr><tr><td><strong>矩阵乘法（三重循环）</strong></td><td>O(n³)</td><td>O(1)</td><td>逐元素计算的朴素方法。</td></tr><tr><td><strong>Dijkstra算法（邻接表）</strong></td><td>O((V+E) log V)</td><td>O(V+E)</td><td>优先队列实现，V为顶点数，E为边数。</td></tr></tbody></table><hr><h4 id="复杂度等级对比" tabindex="-1"><a class="header-anchor" href="#复杂度等级对比"><span><strong>复杂度等级对比</strong></span></a></h4><table><thead><tr><th><strong>复杂度等级</strong></th><th><strong>示例算法/操作</strong></th><th><strong>输入规模n的适用范围</strong></th></tr></thead><tbody><tr><td>O(1)</td><td>数组访问、哈希表查询</td><td>任何规模，时间恒定。</td></tr><tr><td>O(log n)</td><td>二分查找、堆操作</td><td>n=1e9时，log2(n)≈30，效率极高。</td></tr><tr><td>O(n)</td><td>线性查找、单层循环</td><td>n=1e6时，可处理秒级。</td></tr><tr><td>O(n log n)</td><td>快速排序、归并排序</td><td>n=1e7时，仍可接受。</td></tr><tr><td>O(n²)</td><td>冒泡排序、简单矩阵乘法</td><td>n≤1e4时，可能超时。</td></tr><tr><td>O(n³)</td><td>三重循环、朴素矩阵乘法</td><td>n≤1e3时，可能超时。</td></tr><tr><td>O(2ⁿ)</td><td>子集枚举、斐波那契递归</td><td>n≤20时，可能超时；n=30时，不可行。</td></tr><tr><td>O(n!)</td><td>全排列生成</td><td>n≤12时，可能超时；n=20时，不可行。</td></tr></tbody></table><hr><h4 id="关键注意事项" tabindex="-1"><a class="header-anchor" href="#关键注意事项"><span><strong>关键注意事项</strong></span></a></h4><ol><li><strong>时间复杂度优先级</strong>：在算法选择中，优先考虑低阶复杂度（如O(n log n)优于O(n²)）。</li><li><strong>空间与时间的权衡</strong>：例如，哈希表（空间换时间）或分治算法（可能增加空间需求）。</li><li><strong>递归的隐式成本</strong>：递归可能导致额外空间开销（如栈深度）。</li><li><strong>实际优化</strong>：常数系数和低阶项在小规模数据中可能影响性能，但复杂度分析关注趋势。</li></ol><h3 id="线性结构" tabindex="-1"><a class="header-anchor" href="#线性结构"><span>线性结构</span></a></h3><h4 id="线性结构的核心概念" tabindex="-1"><a class="header-anchor" href="#线性结构的核心概念"><span><strong>线性结构的核心概念</strong></span></a></h4><p><strong>1. 定义与特点</strong></p><ul><li><strong>定义</strong>：数据元素之间存在<strong>一对一</strong>的线性关系，元素按顺序排列，每个元素有唯一前驱和后继（首尾元素除外）。</li><li>核心特点： <ul><li><strong>有序性</strong>：元素按逻辑顺序排列。</li><li><strong>唯一性</strong>：首元素无前驱，尾元素无后继。</li><li><strong>直接关系</strong>：相邻元素直接关联。</li></ul></li></ul><p><strong>2. 常见线性结构类型</strong></p><ul><li><strong>线性表</strong>：最基础的线性结构，包含顺序表和链表。</li><li><strong>栈（Stack）</strong>：后进先出（LIFO），仅允许在栈顶操作（如递归、表达式求值）。</li><li><strong>队列（Queue）</strong>：先进先出（FIFO），队尾入队、队头出队（如任务调度、BFS）。</li><li><strong>数组</strong>：固定大小的线性结构，支持随机访问。</li><li><strong>字符串</strong>：字符序列，属于线性表的特殊形式。</li></ul><hr><h4 id="存储方式对比与关键考点" tabindex="-1"><a class="header-anchor" href="#存储方式对比与关键考点"><span><strong>存储方式对比与关键考点</strong></span></a></h4><p><strong>1. 存储方式选择</strong></p><table><thead><tr><th><strong>存储方式</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th><th><strong>常考对比</strong></th></tr></thead><tbody><tr><td><strong>顺序存储</strong></td><td>内存连续，支持随机访问（<code>data[i]</code>），插入/删除需移动元素，动态扩容可能耗时</td><td>数据量固定或较少插入/删除操作</td><td>与链式存储对比：插入/删除效率低，但访问快</td></tr><tr><td><strong>链式存储</strong></td><td>动态分配内存，插入/删除快（改指针即可），但访问需遍历，空间利用率较低</td><td>频繁插入/删除操作，数据量动态变化</td><td>与顺序存储对比：访问慢，但插入/删除快</td></tr></tbody></table><p><strong>2. 线性表操作复杂度</strong></p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>顺序表</strong></th><th><strong>单链表</strong></th><th><strong>考点关联</strong></th></tr></thead><tbody><tr><td>插入/删除</td><td>平均 <code>O(n)</code></td><td>平均 <code>O(1)</code>（需找到位置）</td><td>考察存储方式选择：频繁操作选链表，静态数据选顺序表</td></tr><tr><td>查找</td><td><code>O(1)</code>（直接索引）</td><td><code>O(n)</code>（需遍历）</td><td>考察时间复杂度分析：顺序表随机访问快，链表需遍历</td></tr></tbody></table><hr><h4 id="栈与队列的核心对比与应用" tabindex="-1"><a class="header-anchor" href="#栈与队列的核心对比与应用"><span><strong>栈与队列的核心对比与应用</strong></span></a></h4><p><strong>1. 栈（Stack）与队列（Queue）的区别</strong></p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>栈（Stack）</strong></th><th><strong>队列（Queue）</strong></th><th><strong>常考题型</strong></th></tr></thead><tbody><tr><td><strong>操作原则</strong></td><td>后进先出（LIFO）</td><td>先进先出（FIFO）</td><td>概念对比题：区分LIFO与FIFO的应用场景</td></tr><tr><td><strong>典型应用</strong></td><td>递归、表达式求值、函数调用栈、括号匹配</td><td>任务调度、BFS、消息队列、缓存管理</td><td>应用实例题：DFS用栈，BFS用队列</td></tr><tr><td><strong>存储实现</strong></td><td>数组或链表实现，需维护栈顶指针</td><td>数组或链表实现，需维护队头/队尾指针</td><td>循环队列的溢出条件（<code>front = (rear + 1) % maxSize</code>）</td></tr></tbody></table><p><strong>2. 栈与队列的实现细节</strong></p><ul><li><strong>栈</strong>：通常用数组或链表实现，需注意栈满/栈空的判断。</li><li><strong>队列</strong>：循环队列需处理“假溢出”，需掌握其溢出条件（如 <code>front = (rear + 1) % maxSize</code>）。</li></ul><hr><h4 id="线性结构的典型应用与复杂度分析" tabindex="-1"><a class="header-anchor" href="#线性结构的典型应用与复杂度分析"><span><strong>线性结构的典型应用与复杂度分析</strong></span></a></h4><p><strong>1. 线性结构在算法中的应用</strong></p><ul><li>栈： <ul><li><strong>递归</strong>：函数调用栈的底层实现。</li><li><strong>表达式求值</strong>：用栈匹配括号或计算逆波兰表达式。</li></ul></li><li>队列： <ul><li><strong>BFS</strong>：通过队列按层次遍历图或树。</li><li><strong>任务调度</strong>：操作系统中任务队列的管理。</li></ul></li></ul><p><strong>2. 常考复杂度分析题</strong></p><ul><li>题目：顺序表和链表在插入操作上的时间复杂度有何差异？ <ul><li><strong>答案</strong>：顺序表需移动元素，复杂度 <code>O(n)</code>；链表仅改指针，复杂度 <code>O(1)</code>。</li></ul></li><li>题目：深度优先搜索（DFS）和广度优先搜索（BFS）分别使用什么结构？ <ul><li><strong>答案</strong>：DFS用栈（LIFO），BFS用队列（FIFO）。</li></ul></li></ul><hr><h4 id="关键注意事项与易错点" tabindex="-1"><a class="header-anchor" href="#关键注意事项与易错点"><span><strong>关键注意事项与易错点</strong></span></a></h4><ol><li><strong>线性结构与非线性结构的区别</strong>： <ul><li><strong>线性结构</strong>：元素间一对一（如线性表、栈、队列）。</li><li><strong>非线性结构</strong>：元素间多对多（如树、图）。</li><li><strong>易错点</strong>：将树或图误认为线性结构。</li></ul></li><li><strong>存储方式的权衡</strong>： <ul><li><strong>顺序表</strong>：适合静态数据或需频繁访问的场景（如数据库索引）。</li><li><strong>链表</strong>：适合动态数据或频繁插入/删除的场景（如链表实现LRU缓存）。</li></ul></li><li><strong>栈与队列的隐含要求</strong>： <ul><li>栈的操作仅限栈顶，队列的操作仅限队头/队尾。</li><li>循环队列的溢出条件需特别注意（避免“假溢出”）。</li></ul></li></ol><hr><p><strong>总结：线性结构对比表</strong></p><table><thead><tr><th><strong>结构类型</strong></th><th><strong>特点</strong></th><th><strong>存储方式</strong></th><th><strong>典型应用</strong></th><th><strong>时间复杂度（平均）</strong></th></tr></thead><tbody><tr><td>线性表</td><td>有序、一对一关系</td><td>顺序/链式</td><td>数据存储、排序算法</td><td>查找 <code>O(1)/O(n)</code>，插入/删除 <code>O(n)/O(1)</code></td></tr><tr><td>栈</td><td>LIFO</td><td>数组/链表</td><td>递归、表达式求值</td><td>入栈/出栈 <code>O(1)</code></td></tr><tr><td>队列</td><td>FIFO</td><td>数组/链表/循环队列</td><td>任务调度、BFS</td><td>入队/出队 <code>O(1)</code></td></tr><tr><td>顺序表</td><td>连续内存，支持随机访问</td><td>顺序存储</td><td>静态数据存储</td><td>插入/删除 <code>O(n)</code></td></tr><tr><td>链表</td><td>动态分配，插入/删除高效</td><td>链式存储</td><td>动态操作场景</td><td>查找 <code>O(n)</code></td></tr></tbody></table><h3 id="数组-矩阵-广义表" tabindex="-1"><a class="header-anchor" href="#数组-矩阵-广义表"><span>数组，矩阵，广义表</span></a></h3><h4 id="一、数组-array" tabindex="-1"><a class="header-anchor" href="#一、数组-array"><span><strong>一、数组（Array）</strong></span></a></h4><p><strong>1. 核心概念</strong></p><ul><li><strong>定义</strong>： 多个<strong>相同类型</strong>的元素按<strong>有序</strong>方式排列的集合，元素通过下标访问。</li><li>特点： <ul><li><strong>固定长度</strong>：定义后不可动态扩展或缩小（需重新分配内存）。</li><li><strong>连续存储</strong>：内存中连续存放，支持<strong>随机访问</strong>（通过下标直接定位）。</li><li><strong>多维特性</strong>：可以是高维结构（如二维数组、三维数组），但底层存储为一维线性结构。</li></ul></li></ul><p><strong>2. 存储方式</strong></p><ul><li>行优先（Row-major Order）： <ul><li>多维数组按行展开为一维数组。例如，二维数组 <code>A[m][n]</code> 中，<code>A[i][j]</code> 的地址计算公式为： <code>LOC(A[i][j]) = LOC(A[0][0]) + (i * n + j) * L</code>（L为元素大小）。</li><li><strong>C/C++/Java</strong> 等语言默认按行优先存储。</li></ul></li><li>列优先（Column-major Order）： <ul><li>多维数组按列展开，如 <code>A[i][j]</code> 的地址为 <code>LOC(A[i][j]) = LOC(A[0][0]) + (j * m + i) * L</code>。</li></ul></li></ul><p><strong>3. 考点与应用</strong></p><ul><li><strong>多维数组地址计算</strong>： 如二维数组 <code>A[3][4]</code> 中，<code>A[1][2]</code> 的地址为 <code>base + (1×4 + 2) × L</code>。</li><li>特殊矩阵的压缩存储： <ul><li><strong>对称矩阵</strong>：只存储下三角（含对角线）元素，空间复杂度降为 <code>n(n+1)/2</code>。</li><li><strong>三角矩阵</strong>：上/下三角全为常数，存储非常数区域。</li><li><strong>对角矩阵</strong>：非零元素集中在主对角线附近，按行或列压缩存储。</li></ul></li></ul><hr><h4 id="矩阵-matrix" tabindex="-1"><a class="header-anchor" href="#矩阵-matrix"><span><strong>矩阵（Matrix）</strong></span></a></h4><p><strong>1. 分类与存储</strong></p><ul><li>特殊矩阵： <ul><li><strong>对称矩阵</strong>：满足 <code>A[i][j] = A[j][i]</code>，存储下三角部分即可。</li><li>三角矩阵： <ul><li>上三角矩阵：下三角（不含对角线）全为常数。</li><li>下三角矩阵：上三角（不含对角线）全为常数。</li></ul></li><li><strong>对角矩阵</strong>：非零元素集中在主对角线附近（如三对角矩阵）。</li></ul></li><li>稀疏矩阵： <ul><li><strong>定义</strong>：非零元素远少于零元素，且分布无规律。</li><li>压缩存储方法： <ul><li><strong>三元组顺序表</strong>：存储<code>(行, 列, 值)</code>，如 <code>trimat[k][0]</code> 表示第k个非零元素的值。</li><li><strong>行逻辑链接表</strong>：增加行索引数组，快速定位某行的非零元素。</li><li><strong>十字链表</strong>：每个非零元素用节点表示，包含行、列、值，以及行指针和列指针。</li></ul></li></ul></li></ul><p><strong>2. 考点与应用</strong></p><ul><li><p>特殊矩阵的地址计算：</p><p>如三对角矩阵第i行的带状区域首元素下标为：</p><ul><li><code>i=1</code> 时为 <code>0</code>；</li><li><code>i&gt;1</code> 时为 <code>2 + (i-2)*3</code>。</li></ul></li><li><p><strong>稀疏矩阵的三元组操作</strong>： 如稀疏矩阵的转置、加法等需基于三元组顺序表实现。</p></li></ul><hr><h4 id="广义表-generalized-list" tabindex="-1"><a class="header-anchor" href="#广义表-generalized-list"><span><strong>广义表（Generalized List）</strong></span></a></h4><p><strong>1. 核心概念</strong></p><ul><li><strong>定义</strong>： 线性表的扩展，元素可以是<strong>原子</strong>（不可分数据）或<strong>子表</strong>（另一个广义表）。</li><li>关键术语： <ul><li><strong>长度</strong>：表中最外层元素的个数（如 <code>(a, (b, c))</code> 的长度为2）。</li><li><strong>深度</strong>：括号嵌套的最大层数（如 <code>(a, (b, (c)))</code> 的深度为3）。</li></ul></li></ul><p><strong>2. 存储方式</strong></p><ul><li><p>链式存储：</p><ul><li><p>节点类型：</p><ul><li><strong>原子节点</strong>：包含 <code>tag=0</code> 和原子值。</li><li><strong>表节点</strong>：包含 <code>tag=1</code>、<code>hp</code>（指向表头）和 <code>tp</code>（指向表尾）。</li></ul></li><li><p>C语言实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">typedef</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">          // 0:原子，1:子表</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    union</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        char</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> atom</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 原子值</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        struct</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">hp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">tp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 表头、表尾指针</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> un</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">GList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>存储特点：</p><ul><li>无法用顺序存储（因嵌套结构复杂）。</li><li>链式结构灵活，适合动态嵌套。</li></ul></li></ul><p><strong>3. 考点与应用</strong></p><ul><li><strong>深度与长度计算</strong>： 如广义表 <code>(a, (b, (c)))</code> 的长度为2，深度为3。</li><li>广义表操作： <ul><li><strong>取表头</strong>：<code>GetHead(L)</code> 返回第一个元素（原子或子表）。</li><li><strong>取表尾</strong>：<code>GetTail(L)</code> 返回剩余元素组成的表。</li></ul></li><li><strong>区别于线性表</strong>： 线性表元素只能是原子，广义表允许嵌套子表。</li></ul><hr><h4 id="对比总结" tabindex="-1"><a class="header-anchor" href="#对比总结"><span><strong>对比总结</strong></span></a></h4><table><thead><tr><th><strong>结构</strong></th><th><strong>元素类型</strong></th><th><strong>存储方式</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>数组</strong></td><td>同类型、固定长度</td><td>顺序存储（行/列优先）</td><td>随机访问高效，插入/删除低效</td><td>多维数据存储、矩阵运算</td></tr><tr><td><strong>矩阵</strong></td><td>数值型</td><td>特殊矩阵压缩存储，稀疏矩阵三元组/链表</td><td>节省内存空间，支持高效运算</td><td>科学计算、图像处理</td></tr><tr><td><strong>广义表</strong></td><td>原子或子表</td><td>链式存储（带tag节点）</td><td>支持嵌套结构，灵活但操作复杂</td><td>人工智能、符号计算</td></tr></tbody></table><hr><h4 id="高频考题示例" tabindex="-1"><a class="header-anchor" href="#高频考题示例"><span><strong>高频考题示例</strong></span></a></h4><ol><li><strong>数组地址计算</strong>： <em>题目</em>：二维数组 <code>A[5][6]</code> 按行优先存储，首地址为 <code>100</code>，每个元素占 <code>4B</code>，求 <code>A[3][4]</code> 的地址。 <em>答案</em>：<code>100 + (3×6 + 4)×4 = 100 + 88×4 = 452</code>。</li><li><strong>广义表深度计算</strong>： <em>题目</em>：广义表 <code>(a, (b, (c, d)))</code> 的深度是多少？ <em>答案</em>：3（括号嵌套层数为3）。</li><li><strong>稀疏矩阵三元组操作</strong>： <em>题目</em>：稀疏矩阵的三元组顺序表中，第k个元素的行标如何表示？ <em>答案</em>：<code>trimat[k][1]</code>（假设三元组结构为 <code>[值, 行, 列]</code>）。</li></ol><hr><h4 id="关键注意事项-1" tabindex="-1"><a class="header-anchor" href="#关键注意事项-1"><span><strong>关键注意事项</strong></span></a></h4><ul><li><strong>数组与广义表的区别</strong>： 数组元素类型固定且无嵌套；广义表允许嵌套子表，结构灵活。</li><li><strong>特殊矩阵压缩的适用场景</strong>： 对称、三角、对角矩阵适合压缩，而稀疏矩阵需用三元组或链表。</li><li><strong>广义表的链式存储实现</strong>： 必须区分原子节点和表节点，通过 <code>tag</code> 标志域控制。</li></ul><h3 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h3><p>以下是关于<strong>数据结构中树</strong>的核心知识点总结，结合知识库内容，以清晰的结构化形式呈现，突出重点、对比和高频考点：</p><hr><h4 id="树的基本概念" tabindex="-1"><a class="header-anchor" href="#树的基本概念"><span><strong>树的基本概念</strong></span></a></h4><p><strong>定义</strong></p><ul><li><strong>树（Tree）</strong>：<br> 由<strong>n个节点</strong>组成的有限集合，满足以下条件： <ul><li>有且仅有一个<strong>根节点（Root）</strong>，无父节点。</li><li>其余节点分为<strong>互不相交的子树</strong>，每个子树本身也是一棵树。</li></ul></li><li><strong>特点</strong>： <ul><li>非线性结构，层次分明。</li><li>节点间存在<strong>一对一或多对多</strong>的层次关系。</li></ul></li></ul><hr><p><strong>核心术语</strong></p><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>节点（Node）</strong></td><td>树的基本单位，包含数据元素和指向子节点的指针。</td><td>A、B、C等节点构成树的结构。</td></tr><tr><td><strong>根节点（Root）</strong></td><td>树的顶层节点，无父节点。</td><td>树结构中的A节点。</td></tr><tr><td><strong>叶子节点（Leaf）</strong></td><td>度为0的节点，无子节点。</td><td>B、C等末端节点。</td></tr><tr><td><strong>父节点（Parent）</strong></td><td>有子节点的节点。</td><td>A是B的父节点。</td></tr><tr><td><strong>子节点（Child）</strong></td><td>直接连接到父节点的节点。</td><td>B是A的子节点。</td></tr><tr><td><strong>度（Degree）</strong></td><td>节点的子节点数目；树的度是所有节点度的最大值。</td><td>A的度为3，树的度为3。</td></tr><tr><td><strong>层次（Level）</strong></td><td>根为第1层，子节点逐层递增。</td><td>A为1层，B为2层。</td></tr><tr><td><strong>高度（Height）</strong></td><td>根节点到最远叶子节点的路径长度（边数+1）。</td><td>树的高度为4层。</td></tr></tbody></table><hr><h4 id="树的分类" tabindex="-1"><a class="header-anchor" href="#树的分类"><span><strong>树的分类</strong></span></a></h4><p><strong>按节点分支数量分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>二叉树</strong></td><td>每个节点最多2个子节点（左、右）。</td><td>表达式求值、搜索、编译器语法分析</td></tr><tr><td><strong>多叉树</strong></td><td>节点可有任意子节点数。</td><td>文件系统、组织架构表示</td></tr><tr><td><strong>满二叉树</strong></td><td>所有非叶子节点都有2个子节点，且叶子节点在同一层。</td><td>完全对称的树结构</td></tr><tr><td><strong>完全二叉树</strong></td><td>除最后一层外，其他层满；最后一层从左到右填充。</td><td>堆结构实现</td></tr><tr><td><strong>平衡二叉树</strong></td><td>任意节点的左右子树高度差≤1（如AVL树、红黑树）。</td><td>动态数据高效查询</td></tr><tr><td><strong>B/B+树</strong></td><td>多路平衡树，每个节点存储多个键，适合磁盘存储。</td><td>数据库索引（如MySQL）</td></tr></tbody></table><hr><p><strong>按结构特性分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>二叉搜索树（BST）</strong></td><td>左子树值 &lt; 根值 &lt; 右子树值，中序遍历有序。</td><td>快速查找、插入、删除操作</td></tr><tr><td><strong>哈夫曼树</strong></td><td>权值大的节点离根近，用于最优编码（如数据压缩）。</td><td>Huffman编码算法</td></tr><tr><td><strong>线索二叉树</strong></td><td>在空闲指针域存储前驱/后继节点，支持非递归遍历。</td><td>遍历优化</td></tr></tbody></table><hr><h4 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构"><span><strong>树的存储结构</strong></span></a></h4><p><strong>常见存储方式</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>结构</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>双亲表示法</strong></td><td>每个节点存储父节点索引，便于查找父节点。</td><td>父节点访问频繁的场景</td></tr><tr><td><strong>孩子表示法</strong></td><td>每个节点的孩子构成链表，便于遍历子树。</td><td>子树操作频繁的场景</td></tr><tr><td><strong>孩子兄弟表示法</strong></td><td>每个节点保存第一个孩子和下一个兄弟的指针，支持多叉树转换为二叉树。</td><td>多叉树的二叉化存储</td></tr><tr><td><strong>顺序存储（数组）</strong></td><td>仅适用于完全二叉树，通过下标计算父子关系（父节点<code>i</code>，左子<code>2i+1</code>，右子<code>2i+2</code>）。</td><td>完全二叉树的高效索引访问</td></tr><tr><td><strong>链式存储</strong></td><td>每个节点包含数据和子节点指针，灵活支持任意树结构。</td><td>动态树结构（如AVL树）</td></tr></tbody></table><hr><h4 id="树的遍历方法" tabindex="-1"><a class="header-anchor" href="#树的遍历方法"><span>树的遍历方法</span></a></h4><p><strong>1. 遍历类型与实现</strong></p><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>规则</strong></th><th><strong>示例（根A，左B右C）</strong></th></tr></thead><tbody><tr><td><strong>前序遍历（根→左→右）</strong></td><td>访问根，遍历左子树，遍历右子树。</td><td>A → B → C</td></tr><tr><td><strong>中序遍历（左→根→右）</strong></td><td>遍历左子树，访问根，遍历右子树。</td><td>B → A → C</td></tr><tr><td><strong>后序遍历（左→右→根）</strong></td><td>遍历左子树，遍历右子树，访问根。</td><td>B → C → A</td></tr><tr><td><strong>层次遍历（广度优先）</strong></td><td>按层次从上到下、从左到右访问。</td><td>A → B → C → D → E → F → G</td></tr></tbody></table><p><strong>2. 遍历应用</strong></p><ul><li><strong>前序</strong>：复制树结构、表达式生成。</li><li><strong>中序</strong>：二叉搜索树的有序输出。</li><li><strong>后序</strong>：释放树资源、表达式求值。</li><li><strong>层次遍历</strong>：文件系统目录遍历。</li></ul><hr><h4 id="关键性质与公式" tabindex="-1"><a class="header-anchor" href="#关键性质与公式"><span><strong>关键性质与公式</strong></span></a></h4><ol><li><strong>节点数与边数</strong>： <ul><li>树有N个节点，则边数为 <strong>N-1</strong>。</li></ul></li><li><strong>完全二叉树性质</strong>： <ul><li>若高度为h，则节点数范围：<code>2^(h-1) ≤ N ≤ 2^h -1</code>。</li></ul></li><li><strong>二叉树遍历唯一性</strong>： <ul><li>前序+中序可唯一确定树结构；</li><li>后序+中序可唯一确定树结构；</li><li>前序+后序无法唯一确定（除非是满二叉树）。</li></ul></li></ol><hr><h4 id="高频考点与典型题型" tabindex="-1"><a class="header-anchor" href="#高频考点与典型题型"><span><strong>高频考点与典型题型</strong></span></a></h4><p><strong>1. 树的度与高度计算</strong></p><ul><li><strong>例题</strong>：某树的度为3，有9个叶子节点，5个度为2的节点，求度为3的节点数。<br><strong>答案</strong>：<br> 设度为3的节点数为x，根据公式：<br><code>叶子 = 1 + 2×度2节点 + 3×度3节点</code> → <code>9 = 1 + 2×5 + 3x</code> → x=2。</li></ul><p><strong>2. 二叉树性质应用</strong></p><ul><li><strong>例题</strong>：一棵完全二叉树有100个节点，求其高度。<br><strong>答案</strong>：<br> 完全二叉树高度h满足：<code>2^(h-1) ≤ 100 ≤ 2^h -1</code> → h=7（2<sup>6=64，2</sup>7-1=127）。</li></ul><p><strong>3. 遍历序列还原树结构</strong></p><ul><li><strong>例题</strong>：已知前序序列<code>A B D E C F</code>，中序序列<code>D B E A F C</code>，画出二叉树。<br><strong>步骤</strong>： <ol><li>前序首节点A为根；</li><li>中序中A左边为左子树（D B E），右边为右子树（F C）；</li><li>递归构造左右子树。</li></ol></li></ul><hr><h4 id="常见易错点与陷阱" tabindex="-1"><a class="header-anchor" href="#常见易错点与陷阱"><span><strong>常见易错点与陷阱</strong></span></a></h4><ol><li><strong>树与森林的区别</strong>： <ul><li><strong>森林</strong>：m棵互不相交的树的集合。</li></ul></li><li><strong>完全二叉树与满二叉树混淆</strong>： <ul><li>满二叉树一定是完全二叉树，但反之不成立。</li></ul></li><li><strong>树的存储结构选择</strong>： <ul><li>顺序存储仅适用于完全二叉树，动态结构优先链式存储。</li></ul></li><li><strong>遍历顺序混淆</strong>： <ul><li>中序遍历需先访问左子树，再根，再右子树（易与前序混淆）。</li></ul></li></ol><hr><h4 id="总结对比表" tabindex="-1"><a class="header-anchor" href="#总结对比表"><span><strong>总结对比表</strong></span></a></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>树</strong></th><th><strong>二叉树</strong></th><th><strong>完全二叉树</strong></th></tr></thead><tbody><tr><td><strong>节点限制</strong></td><td>无限制</td><td>≤2个子节点</td><td>必须完全填充除最后一层外的层</td></tr><tr><td><strong>存储方式</strong></td><td>链式/孩子兄弟表示法</td><td>链式/顺序存储（完全二叉树适用）</td><td>顺序存储最优</td></tr><tr><td><strong>遍历方法</strong></td><td>前序、中序、后序、层次</td><td>前序、中序、后序、层次</td><td>层次遍历最常用</td></tr><tr><td><strong>典型应用</strong></td><td>文件系统、组织架构</td><td>表达式求值、编译器语法分析</td><td>堆结构、优先队列</td></tr></tbody></table><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h3><p>以下是关于**图（Graph Theory）**的核心知识点整理，结合知识库内容，以清晰的结构化形式呈现，涵盖定义、分类、术语、性质、算法及应用：</p><hr><h4 id="图的基本定义" tabindex="-1"><a class="header-anchor" href="#图的基本定义"><span><strong>图的基本定义</strong></span></a></h4><p><strong>1. 定义</strong></p><ul><li><strong>图（Graph）</strong>：<br> 由**顶点集合（V）<strong>和</strong>边集合（E）**组成，记为 ( G = (V, E) )。 <ul><li><strong>顶点（Vertex/Node）</strong>：图的基本单元，表示实体或对象。</li><li><strong>边（Edge）</strong>：连接两个顶点的线段，表示顶点之间的关系。</li><li><strong>有向边（Arc）</strong>：具有方向的边（如 ( u \\rightarrow v )）。</li><li><strong>无向边（Edge）</strong>：无方向的边（如 ( (u, v) )）。</li></ul></li></ul><hr><h4 id="图的分类" tabindex="-1"><a class="header-anchor" href="#图的分类"><span><strong>图的分类</strong></span></a></h4><p><strong>1. 按边的方向分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>无向图</strong></td><td>边无方向，边是顶点的无序对（如 ( (u, v) = (v, u) )）。</td><td>社交网络中的朋友关系</td></tr><tr><td><strong>有向图（DAG）</strong></td><td>边有方向，边是顶点的有序对（如 ( u \\rightarrow v )）。</td><td>交通网络中的单向道路</td></tr></tbody></table><p><strong>2. 按边的特性分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>简单图</strong></td><td>无自环（顶点到自身的边）和多重边（连接同一对顶点的多条边）。</td><td>无向图中的完全图</td></tr><tr><td><strong>多重图</strong></td><td>允许自环或多重边。</td><td>交通网络中的多条并行道路</td></tr><tr><td><strong>有向无环图（DAG）</strong></td><td>有向且无环的图。</td><td>任务调度中的依赖关系</td></tr></tbody></table><hr><h4 id="核心术语与性质" tabindex="-1"><a class="header-anchor" href="#核心术语与性质"><span><strong>核心术语与性质</strong></span></a></h4><p><strong>1. 度（Degree）</strong></p><ul><li><strong>无向图</strong>： <ul><li><strong>顶点的度</strong>：与顶点关联的边的数量。</li><li><strong>握手定理</strong>：所有顶点的度数之和等于边数的<strong>2倍</strong>。</li></ul></li><li><strong>有向图</strong>： <ul><li><strong>入度（In-degree）</strong>：指向顶点的边数。</li><li><strong>出度（Out-degree）</strong>：从顶点出发的边数。</li><li><strong>度数关系</strong>：所有顶点的入度之和等于出度之和，且等于边数。</li></ul></li></ul><p><strong>2. 连通性</strong></p><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>连通图（无向）</strong></td><td>图中任意两顶点间存在路径。</td><td>互联网中的节点连接</td></tr><tr><td><strong>连通分量</strong></td><td>无向图的极大连通子图（最大可能的连通子图）。</td><td>非连通图中的独立子图</td></tr><tr><td><strong>强连通图（有向）</strong></td><td>图中任意两顶点间存在<strong>双向路径</strong>。</td><td>环形交通网络</td></tr><tr><td><strong>强连通分量</strong></td><td>有向图的极大强连通子图。</td><td>社交网络中的紧密社群</td></tr></tbody></table><p><strong>3. 其他关键术语</strong></p><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>路径（Path）</strong></td><td>顶点序列 ( v_1, v_2, ..., v_n )，使得每对相邻顶点间有边。</td><td>从A到B的路线</td></tr><tr><td><strong>环（Cycle）</strong></td><td>起点和终点相同的路径，且除起点外无重复顶点。</td><td>三角形结构中的闭合路径</td></tr><tr><td><strong>自环（Loop）</strong></td><td>顶点到自身的边。</td><td>顶点A到自身的边</td></tr><tr><td><strong>子图（Subgraph）</strong></td><td>顶点集和边集均为原图子集的图。</td><td>删除部分边后的简化图</td></tr><tr><td><strong>生成子图</strong></td><td>包含原图所有顶点的子图。</td><td>连通图的生成树</td></tr></tbody></table><hr><h4 id="图的存储结构" tabindex="-1"><a class="header-anchor" href="#图的存储结构"><span><strong>图的存储结构</strong></span></a></h4><p><strong>常见存储方式</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>结构</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>邻接矩阵</strong></td><td>二维数组 ( G[n][n] )，( G[i][j] = 1 ) 表示边 ( i \\rightarrow j )。</td><td>小规模图、稠密图（边数多）</td></tr><tr><td><strong>邻接表</strong></td><td>每个顶点对应一个链表，存储其邻接顶点。</td><td>大规模图、稀疏图（边数少）</td></tr><tr><td><strong>邻接表（带权）</strong></td><td>链表节点存储邻接顶点及边权值。</td><td>赋权图（如最短路径问题）</td></tr><tr><td><strong>边集数组</strong></td><td>保存所有边的列表，按顶点或边权排序。</td><td>简单图操作（如最小生成树）</td></tr></tbody></table><hr><h4 id="图的遍历算法" tabindex="-1"><a class="header-anchor" href="#图的遍历算法"><span><strong>图的遍历算法</strong></span></a></h4><p><strong>常见遍历方法</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>规则</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td><strong>深度优先搜索（DFS）</strong></td><td>沿路径尽可能深访问，直到无法继续，再回溯。</td><td>( O(V + E) )</td></tr><tr><td><strong>广度优先搜索（BFS）</strong></td><td>逐层扩展访问，按距离起点的远近顺序探索。</td><td>( O(V + E) )</td></tr></tbody></table><p><strong>2. 遍历应用</strong></p><ul><li><strong>DFS</strong>：检测图的连通性、寻找路径、拓扑排序（DAG）。</li><li><strong>BFS</strong>：求最短路径（无权图）、层次遍历、二分图检测。</li></ul><hr><h4 id="关键性质与公式-1" tabindex="-1"><a class="header-anchor" href="#关键性质与公式-1"><span><strong>关键性质与公式</strong></span></a></h4><p><strong>完全图的边数</strong>：</p><ul><li>无向完全图：( \\frac{n(n-1)}{2} ) 条边。</li><li>有向完全图：( n(n-1) ) 条边。</li></ul><p><strong>连通分量数量</strong>：</p><ul><li>无向图至多有 ( n ) 个连通分量（每个顶点独立）。</li></ul><ol><li><strong>欧拉定理</strong>： <ul><li>无向图存在欧拉回路的充要条件：所有顶点度数为偶数。</li></ul></li></ol><hr><h4 id="高频考点与典型题型-1" tabindex="-1"><a class="header-anchor" href="#高频考点与典型题型-1"><span><strong>高频考点与典型题型</strong></span></a></h4><p><strong>1. 度数计算</strong></p><ul><li><strong>例题</strong>：一个有向图有5个顶点，入度之和为8，求边数。<br><strong>答案</strong>：边数等于入度之和，即 <strong>8条</strong>。</li></ul><p><strong>2. 连通性判断</strong></p><ul><li><strong>例题</strong>：判断下图是否为强连通图。<br><strong>步骤</strong>： <ol><li>检查每对顶点是否存在双向路径；</li><li>若存在，则为强连通图。</li></ol></li></ul><p><strong>3. 最小生成树（MST）</strong></p><ul><li><strong>算法</strong>： <ul><li><strong>Kruskal算法</strong>：按边权从小到大选择，避免形成环。</li><li><strong>Prim算法</strong>：从单个顶点出发，逐步扩展最小边。</li></ul></li></ul><hr><h4 id="经典问题与应用" tabindex="-1"><a class="header-anchor" href="#经典问题与应用"><span><strong>经典问题与应用</strong></span></a></h4><p><strong>1. 典型问题</strong></p><table><thead><tr><th><strong>问题</strong></th><th><strong>描述</strong></th><th><strong>算法</strong></th></tr></thead><tbody><tr><td><strong>最短路径</strong></td><td>求两点间权值最小的路径。</td><td>Dijkstra、Floyd、Bellman-Ford</td></tr><tr><td><strong>拓扑排序</strong></td><td>对DAG进行线性排序，确保所有前驱在后继之前。</td><td>Kahn算法（BFS）、DFS</td></tr><tr><td><strong>旅行商问题（TSP）</strong></td><td>寻找访问所有顶点并返回起点的最短回路。</td><td>动态规划（NP难，近似算法）</td></tr></tbody></table><p><strong>2. 实际应用</strong></p><ul><li><strong>社交网络分析</strong>：通过图模型分析用户关系、社区发现。</li><li><strong>物流路径规划</strong>：利用最短路径算法优化运输路线。</li><li><strong>网页排名（PageRank）</strong>：基于有向图的节点重要性计算。</li></ul><hr><h4 id="常见易错点与陷阱-1" tabindex="-1"><a class="header-anchor" href="#常见易错点与陷阱-1"><span><strong>常见易错点与陷阱</strong></span></a></h4><ol><li><strong>连通分量与强连通分量混淆</strong>： <ul><li>连通分量针对无向图，强连通分量针对有向图。</li></ul></li><li><strong>度数计算错误</strong>： <ul><li>有向图中，顶点的度数是入度与出度之和。</li></ul></li><li><strong>生成树误解</strong>： <ul><li>连通图的生成树必须包含所有顶点且无环。</li></ul></li><li><strong>欧拉回路条件误判</strong>： <ul><li>必须所有顶点度数为偶数，且图连通。</li></ul></li></ol><hr><h4 id="总结对比表-1" tabindex="-1"><a class="header-anchor" href="#总结对比表-1"><span><strong>总结对比表</strong></span></a></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>无向图</strong></th><th><strong>有向图</strong></th></tr></thead><tbody><tr><td><strong>边</strong></td><td>无方向</td><td>有方向</td></tr><tr><td><strong>连通性</strong></td><td>连通图/连通分量</td><td>强连通图/强连通分量</td></tr><tr><td><strong>度数</strong></td><td>顶点关联边的数量</td><td>入度（in-degree）和出度（out-degree）</td></tr><tr><td><strong>完全图边数</strong></td><td>( \\frac{n(n-1)}{2} )</td><td>( n(n-1) )</td></tr><tr><td><strong>典型应用</strong></td><td>社交网络、电路设计</td><td>任务调度、网页链接分析</td></tr></tbody></table><h3 id="算法" tabindex="-1"><a class="header-anchor" href="#算法"><span>算法</span></a></h3><h2 id="标准化和知识产权" tabindex="-1"><a class="header-anchor" href="#标准化和知识产权"><span>标准化和知识产权</span></a></h2><p><strong>标准化组织对比表</strong></p><table><thead><tr><th>组织名称</th><th>性质</th><th>代表标准 / 领域</th><th>备注</th></tr></thead><tbody><tr><td><strong>ISO</strong></td><td>国际标准化组织</td><td>ISO 9000（质量）、ISO 27001（信息安全）</td><td>全球通用，促进国际间技术协调</td></tr><tr><td><strong>IEEE</strong></td><td>美国电气电子工程师协会</td><td>IEEE 802（局域网）、IEEE 754（浮点数）</td><td>侧重电气、电子及计算机工程领域标准</td></tr><tr><td><strong>CMMI</strong></td><td>过程改进模型</td><td>CMMI-DEV（软件开发成熟度）</td><td>评估企业软件开发过程成熟度</td></tr><tr><td><strong>GB</strong></td><td>中国国家标准</td><td>GB（强制性）、GB/T（推荐性）</td><td>国内通用，如 GB 18030（汉字编码）</td></tr><tr><td><strong>行业标准</strong></td><td>特定行业规范</td><td>YD（通信）、GA（公安）、SJ（电子）</td><td>在行业内强制或推荐使用</td></tr></tbody></table><h3 id="二-标准分类表" tabindex="-1"><a class="header-anchor" href="#二-标准分类表"><span>（二）标准分类表</span></a></h3><h4 id="按适用范围分类" tabindex="-1"><a class="header-anchor" href="#按适用范围分类"><span>按适用范围分类</span></a></h4><table><thead><tr><th>分类</th><th>定义</th><th>示例</th></tr></thead><tbody><tr><td>国际标准</td><td>国际组织发布，全球适用</td><td>ISO、IEC 标准</td></tr><tr><td>国家标准</td><td>国家主管机构发布，全国适用</td><td>GB（中国）、ANSI（美国）</td></tr><tr><td>行业标准</td><td>行业协会发布，特定行业内适用</td><td>YD（通信）、IEEE 标准</td></tr><tr><td>企业标准</td><td>企业自行制定，内部适用</td><td>某公司技术规范</td></tr></tbody></table><h4 id="按性质分类" tabindex="-1"><a class="header-anchor" href="#按性质分类"><span>按性质分类</span></a></h4><table><thead><tr><th>分类</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>强制性标准</td><td>法律强制遵守，违规禁止生产 / 销售</td><td>GB（不带 / T 后缀）</td></tr><tr><td>推荐性标准</td><td>自愿采用，以 “/T” 标识</td><td>GB/T、ISO/IEC 指南</td></tr></tbody></table><h3 id="知识产权核心考点" tabindex="-1"><a class="header-anchor" href="#知识产权核心考点"><span>知识产权核心考点</span></a></h3><h4 id="知识产权保护期限表" tabindex="-1"><a class="header-anchor" href="#知识产权保护期限表"><span>知识产权保护期限表</span></a></h4><table><thead><tr><th>客体类型</th><th>权利类型</th><th>保护期限</th><th>特殊说明</th></tr></thead><tbody><tr><td><strong>软件著作权</strong></td><td>署名权、修改权</td><td>永久</td><td>公民作品归个人，职务作品归单位</td></tr><tr><td></td><td>发表权、使用权</td><td>公民：终生 + 死后 50 年；单位：首次发表后 50 年</td><td>合作开发以最后死亡作者为准</td></tr><tr><td><strong>专利权</strong></td><td>发明专利权</td><td>20 年（自申请日起）</td><td>需每年缴纳年费</td></tr><tr><td></td><td>实用新型 / 外观设计</td><td>10 年（自申请日起）</td><td></td></tr><tr><td><strong>商标权</strong></td><td>注册商标权</td><td>10 年（可无限续展，续展期 6 个月）</td><td>未续展则注销</td></tr><tr><td><strong>商业秘密</strong></td><td>技术 / 经营信息</td><td>未公开则永久有效</td><td>公开后丧失保护</td></tr></tbody></table><h4 id="知识产权归属判定表" tabindex="-1"><a class="header-anchor" href="#知识产权归属判定表"><span>知识产权归属判定表</span></a></h4><table><thead><tr><th>场景</th><th>归属原则</th><th>示例说明</th></tr></thead><tbody><tr><td><strong>职务作品</strong></td><td>单位享有著作权（除署名权）</td><td>员工在本职工作中开发的软件</td></tr><tr><td><strong>委托开发</strong></td><td>有合同按合同，无合同归受托人</td><td>甲委托乙开发软件，未约定则乙拥有</td></tr><tr><td><strong>合作开发</strong></td><td>共同享有，可分割成果可单独申请</td><td>甲乙合作开发，成果可拆分则各自申请</td></tr><tr><td><strong>商标 / 专利申请</strong></td><td>先申请原则，同时申请协商或抽签</td><td>甲乙同日申请，协商不成则抽签</td></tr></tbody></table><h3 id="常考例题汇总" tabindex="-1"><a class="header-anchor" href="#常考例题汇总"><span>常考例题汇总</span></a></h3><h4 id="一-标准化知识例题" tabindex="-1"><a class="header-anchor" href="#一-标准化知识例题"><span>（一）标准化知识例题</span></a></h4><ol><li><strong>题目</strong>：以下属于推荐性国家标准的是（ ） A. GB 18030 B. YD/T 1234 C. GB/T 2312 D. ISO 9001 <strong>答案</strong>：C <strong>解析</strong>：GB/T 是推荐性国家标准标识，GB 为强制性，YD/T 是通信行业推荐标准，ISO 是国际标准。</li><li><strong>题目</strong>：IEEE 802.11 属于（ ） A. 国际标准 B. 行业标准 C. 企业标准 D. 地方标准 <strong>答案</strong>：B <strong>解析</strong>：IEEE 是美国电气电子工程师协会制定的行业标准，专注于局域网技术。</li></ol><h4 id="二-知识产权知识例题" tabindex="-1"><a class="header-anchor" href="#二-知识产权知识例题"><span>（二）知识产权知识例题</span></a></h4><ol><li><strong>题目</strong>：某公司员工在业余时间开发的软件，著作权归（ ） A. 公司 B. 员工个人 C. 公司与员工共有 D. 无归属 <strong>答案</strong>：B <strong>解析</strong>：非职务作品（业余时间、未用公司资源）著作权归个人所有。</li><li><strong>题目</strong>：发明专利的保护期限是（ ） A. 10 年 B. 15 年 C. 20 年 D. 50 年 <strong>答案</strong>：C <strong>解析</strong>：发明专利权保护期自申请日起 20 年，实用新型和外观设计为 10 年。</li><li><strong>题目</strong>：甲委托乙开发软件，未约定著作权归属，该软件著作权归（ ） A. 甲 B. 乙 C. 甲乙共有 D. 国家所有 <strong>答案</strong>：B <strong>解析</strong>：委托开发未约定时，著作权归受托人（乙）所有。</li><li><strong>题目</strong>：以下属于侵犯软件著作权的行为是（ ） A. 购买正版后安装到公司 3 台电脑 B. 修改正版软件后自用 C. 备份正版软件到硬盘 D. 转让正版软件许可给他人 <strong>答案</strong>：D <strong>解析</strong>：转让软件许可需著作权人授权，个人安装、备份属于合理使用，修改后自用若未传播不侵权（具体视软件许可协议）。</li></ol><h2 id="专业英语" tabindex="-1"><a class="header-anchor" href="#专业英语"><span>专业英语</span></a></h2><table><thead><tr><th>英文</th><th style="text-align:left;">中文</th></tr></thead><tbody><tr><td>Abstract</td><td style="text-align:left;">摘要；抽象的</td></tr><tr><td>Abstraction</td><td style="text-align:left;">抽象</td></tr><tr><td>Access</td><td style="text-align:left;">访问</td></tr><tr><td>Accessibility</td><td style="text-align:left;">无障碍；辅助功能 (win/mac)</td></tr><tr><td>Activate, Activation</td><td style="text-align:left;">激活</td></tr><tr><td>Active</td><td style="text-align:left;">使用中的；现用的；有效的；激活的</td></tr><tr><td>Adapter, Adaptor</td><td style="text-align:left;">适配卡，适配器</td></tr><tr><td>Add</td><td style="text-align:left;">添加</td></tr><tr><td>Address</td><td style="text-align:left;">位址，地址</td></tr><tr><td>Advanced</td><td style="text-align:left;">高级的</td></tr><tr><td>Aggregation</td><td style="text-align:left;">聚合</td></tr><tr><td>AI (Artificial intelligence)</td><td style="text-align:left;">人工智能</td></tr><tr><td>Algorithm</td><td style="text-align:left;">算法</td></tr><tr><td>Allocate</td><td style="text-align:left;">分配</td></tr><tr><td>Allocator</td><td style="text-align:left;">分配器</td></tr><tr><td>Annotation</td><td style="text-align:left;">注释 (win)；注解 (mac)</td></tr><tr><td>App bundle</td><td style="text-align:left;">应用程序包 (win)；App 捆绑包 (mac)</td></tr><tr><td>Application</td><td style="text-align:left;">应用；应用程序</td></tr><tr><td>Apply</td><td style="text-align:left;">应用</td></tr><tr><td>Architecture</td><td style="text-align:left;">架构；结构</td></tr><tr><td>Argument</td><td style="text-align:left;">参数（也称为实际参数，实参）</td></tr><tr><td>Arity</td><td style="text-align:left;">参数数量</td></tr><tr><td>Artifact</td><td style="text-align:left;">项目 (win)；成品 (mac)</td></tr><tr><td>Array</td><td style="text-align:left;">数组</td></tr><tr><td>Assembly language</td><td style="text-align:left;">汇编语言</td></tr><tr><td>Assert, Assertion</td><td style="text-align:left;">断言 (win)；声明 (win/mac)；论断 (mac)</td></tr><tr><td>Assign, Assignment</td><td style="text-align:left;">分配；（编程）赋值</td></tr><tr><td>Assignment operator</td><td style="text-align:left;">赋值运算符</td></tr><tr><td>Asynchronize</td><td style="text-align:left;">异步</td></tr><tr><td>Asynchronous</td><td style="text-align:left;">异步的</td></tr><tr><td>Atomic</td><td style="text-align:left;">原子的</td></tr><tr><td>Attribute</td><td style="text-align:left;">属性</td></tr><tr><td>Audio</td><td style="text-align:left;">音频</td></tr><tr><td>Authenticate, Authentication</td><td style="text-align:left;">验证，认证</td></tr><tr><td>Authorize, Authorization</td><td style="text-align:left;">授权</td></tr><tr><td>Autoboxing</td><td style="text-align:left;">自动装箱</td></tr><tr><td>Background processes</td><td style="text-align:left;">后台进程</td></tr><tr><td>Bandwidth</td><td style="text-align:left;">带宽</td></tr><tr><td>Base class</td><td style="text-align:left;">基类</td></tr><tr><td>Batch</td><td style="text-align:left;">批（处理）</td></tr><tr><td>Binary function</td><td style="text-align:left;">二元函数</td></tr><tr><td>Binary operator</td><td style="text-align:left;">二元运算符</td></tr><tr><td>Binary search</td><td style="text-align:left;">二分查找</td></tr><tr><td>Binary tree</td><td style="text-align:left;">二叉树</td></tr><tr><td>Bind</td><td style="text-align:left;">绑定</td></tr><tr><td>Bit</td><td style="text-align:left;">位</td></tr><tr><td>Bitrate</td><td style="text-align:left;">码率</td></tr><tr><td>Block</td><td style="text-align:left;">屏蔽；阻止</td></tr><tr><td>Block</td><td style="text-align:left;">（代码）块</td></tr><tr><td>Blocker</td><td style="text-align:left;">阻止程序 (win)；拦截器 (mac)</td></tr><tr><td>Boolean</td><td style="text-align:left;">布尔</td></tr><tr><td>Bounce</td><td style="text-align:left;">退回；弹跳</td></tr><tr><td>Breakpoint</td><td style="text-align:left;">断点</td></tr><tr><td>Build (verb)</td><td style="text-align:left;">构建</td></tr><tr><td>Build (noun)</td><td style="text-align:left;">构件；版本（号）</td></tr><tr><td>Build-in</td><td style="text-align:left;">内置 (win)；内建 (mac)</td></tr><tr><td>Bundle (noun)</td><td style="text-align:left;">捆绑包</td></tr><tr><td>Bundle (verb)</td><td style="text-align:left;">整合</td></tr><tr><td>Bus</td><td style="text-align:left;">总线</td></tr><tr><td>Burn</td><td style="text-align:left;">刻录</td></tr><tr><td>Byte</td><td style="text-align:left;">字节</td></tr><tr><td>Cache</td><td style="text-align:left;">高速缓存，缓存</td></tr><tr><td>Call</td><td style="text-align:left;">调用</td></tr><tr><td>Callback</td><td style="text-align:left;">回调</td></tr><tr><td>Certificate</td><td style="text-align:left;">证书</td></tr><tr><td>Character</td><td style="text-align:left;">字符</td></tr><tr><td>Check</td><td style="text-align:left;">查看</td></tr><tr><td>Check box, Checkbox</td><td style="text-align:left;">复选框</td></tr><tr><td>Class</td><td style="text-align:left;">类</td></tr><tr><td>Point &amp; Click (noun)</td><td style="text-align:left;">点按</td></tr><tr><td>Click (vs. Tap)</td><td style="text-align:left;">点击 (win)；点按 (mac)</td></tr><tr><td>Tap (vs. Click)</td><td style="text-align:left;">触碰 (win)；轻点 (mac)</td></tr><tr><td>Client-side</td><td style="text-align:left;">客户端</td></tr><tr><td>Clipboard</td><td style="text-align:left;">剪贴板</td></tr><tr><td>Clone</td><td style="text-align:left;">克隆</td></tr><tr><td>Cloud computing</td><td style="text-align:left;">云计算</td></tr><tr><td>Cohesion</td><td style="text-align:left;">内聚</td></tr><tr><td>Collaborate, Collaboration</td><td style="text-align:left;">协作</td></tr><tr><td>Combo box</td><td style="text-align:left;">组合框</td></tr><tr><td>Come with</td><td style="text-align:left;">随附</td></tr><tr><td>Command</td><td style="text-align:left;">命令</td></tr><tr><td>Command line</td><td style="text-align:left;">命令行</td></tr><tr><td>Comment</td><td style="text-align:left;">评论</td></tr><tr><td>注解，注释</td><td style="text-align:left;"></td></tr><tr><td>Commit</td><td style="text-align:left;">提交</td></tr><tr><td>Communication</td><td style="text-align:left;">通信</td></tr><tr><td>Community</td><td style="text-align:left;">社区</td></tr><tr><td>Compatibility</td><td style="text-align:left;">兼容性</td></tr><tr><td>Compatible</td><td style="text-align:left;">兼容的</td></tr><tr><td>Compile, Compilation</td><td style="text-align:left;">编译</td></tr><tr><td>Compile time, Compile-time</td><td style="text-align:left;">编译期，编译时</td></tr><tr><td>Compiler</td><td style="text-align:left;">编译器</td></tr><tr><td>Component</td><td style="text-align:left;">组件</td></tr><tr><td>Composition</td><td style="text-align:left;">组合</td></tr><tr><td>Compress</td><td style="text-align:left;">压缩</td></tr><tr><td>Concurrency</td><td style="text-align:left;">并发性，并发</td></tr><tr><td>Concurrent</td><td style="text-align:left;">并发的；同时的</td></tr><tr><td>Configuration</td><td style="text-align:left;">配置</td></tr><tr><td>Connect, Connection</td><td style="text-align:left;">连接</td></tr><tr><td>Constant</td><td style="text-align:left;">常量</td></tr><tr><td>Constraint</td><td style="text-align:left;">约束；限制</td></tr><tr><td>Constructor</td><td style="text-align:left;">构造函数</td></tr><tr><td>Container</td><td style="text-align:left;">容器</td></tr><tr><td>Context</td><td style="text-align:left;">背景（关系）；环境；上下文；内容</td></tr><tr><td>Continuous delivery</td><td style="text-align:left;">持续交付</td></tr><tr><td>Continuous deployment</td><td style="text-align:left;">持续部署</td></tr><tr><td>Continuous integration</td><td style="text-align:left;">持续集成</td></tr><tr><td>Control</td><td style="text-align:left;">控件</td></tr><tr><td>Copy</td><td style="text-align:left;">复制 (win)；拷贝 (mac)</td></tr><tr><td>Coroutine</td><td style="text-align:left;">协程，协同程序</td></tr><tr><td>Coupling</td><td style="text-align:left;">耦合</td></tr><tr><td>Crash</td><td style="text-align:left;">崩溃 (win/mac)；故障 (win)</td></tr><tr><td>Create</td><td style="text-align:left;">创建</td></tr><tr><td>Cursor</td><td style="text-align:left;">光标</td></tr><tr><td>Custom</td><td style="text-align:left;">自定义</td></tr><tr><td>Data</td><td style="text-align:left;">数据</td></tr><tr><td>Data link layer</td><td style="text-align:left;">数据链路层</td></tr><tr><td>Data structure</td><td style="text-align:left;">数据结构</td></tr><tr><td>Database</td><td style="text-align:left;">数据库</td></tr><tr><td>Database schema</td><td style="text-align:left;">数据库架构，数据库模式</td></tr><tr><td>Deadlock</td><td style="text-align:left;">死锁</td></tr><tr><td>Debug</td><td style="text-align:left;">调试</td></tr><tr><td>Debugger</td><td style="text-align:left;">调试器</td></tr><tr><td>Declare, Declaration</td><td style="text-align:left;">声明</td></tr><tr><td>Default</td><td style="text-align:left;">默认</td></tr><tr><td>Definition</td><td style="text-align:left;">定义；清晰度</td></tr><tr><td>Delegate, Delegation</td><td style="text-align:left;">委托</td></tr><tr><td>Dependency</td><td style="text-align:left;">依赖</td></tr><tr><td>Derived class</td><td style="text-align:left;">派生类</td></tr><tr><td>Design pattern</td><td style="text-align:left;">设计模式</td></tr><tr><td>Destructor</td><td style="text-align:left;">析构函数</td></tr><tr><td>Detect, Detection</td><td style="text-align:left;">检测</td></tr><tr><td>Device</td><td style="text-align:left;">设备</td></tr><tr><td>Dialog</td><td style="text-align:left;">对话框</td></tr><tr><td>Digital</td><td style="text-align:left;">数字的；数字化</td></tr><tr><td>Digital signature</td><td style="text-align:left;">数字签名</td></tr><tr><td>Digital certificate</td><td style="text-align:left;">数字证书</td></tr><tr><td>Directory</td><td style="text-align:left;">目录</td></tr><tr><td>Disk</td><td style="text-align:left;">盘</td></tr><tr><td>Disk image</td><td style="text-align:left;">磁盘映像</td></tr><tr><td>Dispatch</td><td style="text-align:left;">分派；调度</td></tr><tr><td>Distributed</td><td style="text-align:left;">分布式</td></tr><tr><td>Distribute, Distribution</td><td style="text-align:left;">分发；分配；分布</td></tr><tr><td>Distribution</td><td style="text-align:left;">发行（版本）</td></tr><tr><td>Document</td><td style="text-align:left;">文档；文稿</td></tr><tr><td>Domain</td><td style="text-align:left;">域</td></tr><tr><td>Driver</td><td style="text-align:left;">驱动程序</td></tr><tr><td>Drop-down, Dropdown (noun)</td><td style="text-align:left;">下拉菜单</td></tr><tr><td>Drop-down, Dropdown (verb)</td><td style="text-align:left;">下拉</td></tr><tr><td>Drop-down menu</td><td style="text-align:left;">下拉菜单 (win/mac)</td></tr><tr><td>Drop-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Dynamic binding</td><td style="text-align:left;">动态绑定</td></tr><tr><td>Element</td><td style="text-align:left;">元素；元件</td></tr><tr><td>Email, E-mail</td><td style="text-align:left;">电子邮件</td></tr><tr><td>Enable</td><td style="text-align:left;">启用</td></tr><tr><td>Encapsulation</td><td style="text-align:left;">封装</td></tr><tr><td>Entity</td><td style="text-align:left;">实体</td></tr><tr><td>Enumeration</td><td style="text-align:left;">枚举</td></tr><tr><td>Equal</td><td style="text-align:left;">相等的</td></tr><tr><td>Equality</td><td style="text-align:left;">相等性，相等</td></tr><tr><td>Escape code</td><td style="text-align:left;">转义码</td></tr><tr><td>Event</td><td style="text-align:left;">事件</td></tr><tr><td>Exception</td><td style="text-align:left;">异常</td></tr><tr><td>Explicit</td><td style="text-align:left;">显式</td></tr><tr><td>Export</td><td style="text-align:left;">导出</td></tr><tr><td>Expression</td><td style="text-align:left;">表达式</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展（程序、功能）</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展名</td></tr><tr><td>Feature</td><td style="text-align:left;">特色，特点</td></tr><tr><td>Feature (vs. Function)</td><td style="text-align:left;">（特殊的）功能</td></tr><tr><td>Feedback</td><td style="text-align:left;">反馈</td></tr><tr><td>Field</td><td style="text-align:left;">字段，栏位；域</td></tr><tr><td>File</td><td style="text-align:left;">文件</td></tr><tr><td>Filter</td><td style="text-align:left;">过滤器</td></tr><tr><td>Find</td><td style="text-align:left;">查找</td></tr><tr><td>Firmware</td><td style="text-align:left;">固件</td></tr><tr><td>Flag</td><td style="text-align:left;">标记</td></tr><tr><td>Flash memory</td><td style="text-align:left;">闪存</td></tr><tr><td>Flush</td><td style="text-align:left;">刷新</td></tr><tr><td>对齐，齐平</td><td style="text-align:left;"></td></tr><tr><td>Folder</td><td style="text-align:left;">文件夹</td></tr><tr><td>Font</td><td style="text-align:left;">字体</td></tr><tr><td>Form</td><td style="text-align:left;">表单</td></tr><tr><td>Format (noun)</td><td style="text-align:left;">格式</td></tr><tr><td>Format (verb)</td><td style="text-align:left;">格式化</td></tr><tr><td>Forward</td><td style="text-align:left;">转发，转送，转寄</td></tr><tr><td>Fragment</td><td style="text-align:left;">片段</td></tr><tr><td>Frame</td><td style="text-align:left;">帧；框架</td></tr><tr><td>Frame rate FPS (frames per second)</td><td style="text-align:left;">帧率</td></tr><tr><td>Framework</td><td style="text-align:left;">框架</td></tr><tr><td>Frozen</td><td style="text-align:left;">冻结，锁定</td></tr><tr><td>Full screen, Fullscreen</td><td style="text-align:left;">全屏</td></tr><tr><td>Function</td><td style="text-align:left;">函数</td></tr><tr><td>Function (vs. Feature)</td><td style="text-align:left;">（一般的）功能</td></tr><tr><td>Functionality</td><td style="text-align:left;">功能</td></tr><tr><td>Game</td><td style="text-align:left;">游戏</td></tr><tr><td>Gateway</td><td style="text-align:left;">网关</td></tr><tr><td>General</td><td style="text-align:left;">通用的</td></tr><tr><td>Generate</td><td style="text-align:left;">生成</td></tr><tr><td>Generic</td><td style="text-align:left;">通用的</td></tr><tr><td>Generics</td><td style="text-align:left;">泛型</td></tr><tr><td>Global</td><td style="text-align:left;">全局的</td></tr><tr><td>Group box</td><td style="text-align:left;">分组框，群组框</td></tr><tr><td>Graph</td><td style="text-align:left;">图</td></tr><tr><td>Handle</td><td style="text-align:left;">句柄</td></tr><tr><td>Handler</td><td style="text-align:left;">处理程序，处理器</td></tr><tr><td>Hardware</td><td style="text-align:left;">硬件</td></tr><tr><td>Hash</td><td style="text-align:left;">哈希</td></tr><tr><td>Header file</td><td style="text-align:left;">头文件</td></tr><tr><td>Heap</td><td style="text-align:left;">堆</td></tr><tr><td>Help</td><td style="text-align:left;">帮助</td></tr><tr><td>Hierarchy</td><td style="text-align:left;">层次结构</td></tr><tr><td>High Definition</td><td style="text-align:left;">高清晰度，高清</td></tr><tr><td>Host file</td><td style="text-align:left;">主机文件</td></tr><tr><td>Home folder</td><td style="text-align:left;">主文件夹 (win)；个人文件夹 (mac)</td></tr><tr><td>Home page</td><td style="text-align:left;">主页</td></tr><tr><td>Icon</td><td style="text-align:left;">图标</td></tr><tr><td>IDE</td><td style="text-align:left;">集成开发环境</td></tr><tr><td>Identifier</td><td style="text-align:left;">标识符</td></tr><tr><td>Idle</td><td style="text-align:left;">闲置</td></tr><tr><td>Image</td><td style="text-align:left;">影像；图像，图片；映像</td></tr><tr><td>Immutable</td><td style="text-align:left;">不可变的；不可更改的</td></tr><tr><td>Implement</td><td style="text-align:left;">实现</td></tr><tr><td>Implementation</td><td style="text-align:left;">实现</td></tr><tr><td>Implicit</td><td style="text-align:left;">隐式</td></tr><tr><td>Import</td><td style="text-align:left;">导入</td></tr><tr><td>Indent</td><td style="text-align:left;">缩进</td></tr><tr><td>Info</td><td style="text-align:left;">简介</td></tr><tr><td>Information</td><td style="text-align:left;">信息</td></tr><tr><td>Inheritance</td><td style="text-align:left;">继承</td></tr><tr><td>Initialization</td><td style="text-align:left;">初始化</td></tr><tr><td>Inline</td><td style="text-align:left;">内联</td></tr><tr><td>Instance</td><td style="text-align:left;">实例</td></tr><tr><td>Integrate</td><td style="text-align:left;">集成</td></tr><tr><td>Integrated</td><td style="text-align:left;">集成的</td></tr><tr><td>Integrity</td><td style="text-align:left;">完整性</td></tr><tr><td>Interact, Interaction</td><td style="text-align:left;">交互</td></tr><tr><td>Interface</td><td style="text-align:left;">接口</td></tr><tr><td>Internal Storage</td><td style="text-align:left;">内存 (仅手机等便携装置，民间称谓)</td></tr><tr><td>Internationalization (I18N)</td><td style="text-align:left;">国际化</td></tr><tr><td>Internet</td><td style="text-align:left;">互联网</td></tr><tr><td>Interpreter</td><td style="text-align:left;">解释器</td></tr><tr><td>Invoke</td><td style="text-align:left;">调用</td></tr><tr><td>Iterate</td><td style="text-align:left;">迭代； 重复、循环（访问）</td></tr><tr><td>Iteration</td><td style="text-align:left;">迭代</td></tr><tr><td>Iterator</td><td style="text-align:left;">迭代器</td></tr><tr><td>Kernel</td><td style="text-align:left;">内核</td></tr><tr><td>Key</td><td style="text-align:left;">密钥</td></tr><tr><td>Keybind</td><td style="text-align:left;">快捷键</td></tr><tr><td>Lag</td><td style="text-align:left;">延迟</td></tr><tr><td>Layout</td><td style="text-align:left;">布局，配置</td></tr><tr><td>Lazy loading</td><td style="text-align:left;">延迟加载；懒加载</td></tr><tr><td>Library</td><td style="text-align:left;">程序库，函数库</td></tr><tr><td>Link</td><td style="text-align:left;">链接</td></tr><tr><td>Link time</td><td style="text-align:left;">链接期</td></tr><tr><td>Linked list</td><td style="text-align:left;">链表</td></tr><tr><td>Linker</td><td style="text-align:left;">链接器</td></tr><tr><td>List</td><td style="text-align:left;">列表</td></tr><tr><td>Listener</td><td style="text-align:left;">监听器</td></tr><tr><td>Literals</td><td style="text-align:left;">字面值，字面量</td></tr><tr><td>Literal constant</td><td style="text-align:left;">字面常量</td></tr><tr><td>Load</td><td style="text-align:left;">加载</td></tr><tr><td>Load time</td><td style="text-align:left;">加载期</td></tr><tr><td>Loader</td><td style="text-align:left;">加载器</td></tr><tr><td>Local</td><td style="text-align:left;">局部的，本地的；本地（主机）</td></tr><tr><td>Localization (L10N)</td><td style="text-align:left;">本地化</td></tr><tr><td>Local variable</td><td style="text-align:left;">局部变量</td></tr><tr><td>Lock</td><td style="text-align:left;">锁定</td></tr><tr><td>Log</td><td style="text-align:left;">日志</td></tr><tr><td>Log in, Login</td><td style="text-align:left;">登录</td></tr><tr><td>Log out, Logout</td><td style="text-align:left;">退出；注销</td></tr><tr><td>Loop</td><td style="text-align:left;">循环</td></tr><tr><td>Map, Mapping</td><td style="text-align:left;">映射</td></tr><tr><td>Match</td><td style="text-align:left;">匹配</td></tr><tr><td>Memory</td><td style="text-align:left;">内存</td></tr><tr><td>Menu</td><td style="text-align:left;">菜单</td></tr><tr><td>Message</td><td style="text-align:left;">消息；信息</td></tr><tr><td>Metadata</td><td style="text-align:left;">元数据</td></tr><tr><td>Middleware</td><td style="text-align:left;">中间件，中间软件</td></tr><tr><td>Mobile</td><td style="text-align:left;">移动</td></tr><tr><td>Moderate, Moderation</td><td style="text-align:left;">审核</td></tr><tr><td>Modifier</td><td style="text-align:left;">修饰符</td></tr><tr><td>Module</td><td style="text-align:left;">模块</td></tr><tr><td>Monomorphism</td><td style="text-align:left;">单态</td></tr><tr><td>Motherboard</td><td style="text-align:left;">主板</td></tr><tr><td>Mouse</td><td style="text-align:left;">鼠标</td></tr><tr><td>Mouse pointer</td><td style="text-align:left;">鼠标指针</td></tr><tr><td>Multitasking</td><td style="text-align:left;">多任务（处理）</td></tr><tr><td>Mutable</td><td style="text-align:left;">可变的</td></tr><tr><td>Mutex</td><td style="text-align:left;">互斥</td></tr><tr><td>Native</td><td style="text-align:left;">原生</td></tr><tr><td>Navigate, Navigation</td><td style="text-align:left;">导航</td></tr><tr><td>Navigator</td><td style="text-align:left;">导航器</td></tr><tr><td>Nested</td><td style="text-align:left;">嵌套的</td></tr><tr><td>Network</td><td style="text-align:left;">网络</td></tr><tr><td>New</td><td style="text-align:left;">新建</td></tr><tr><td>Notarization</td><td style="text-align:left;">公证</td></tr><tr><td>Object</td><td style="text-align:left;">对象</td></tr><tr><td>Object code</td><td style="text-align:left;">目标代码</td></tr><tr><td>Object file</td><td style="text-align:left;">目标文件</td></tr><tr><td>Object-oriented</td><td style="text-align:left;">面向对象</td></tr><tr><td>Online</td><td style="text-align:left;">在线</td></tr><tr><td>Operand</td><td style="text-align:left;">操作数，运算元</td></tr><tr><td>Operating system</td><td style="text-align:left;">操作系统</td></tr><tr><td>Operator</td><td style="text-align:left;">操作符，运算符</td></tr><tr><td>Optimize, Optimization</td><td style="text-align:left;">优化</td></tr><tr><td>Overflow</td><td style="text-align:left;">溢出（上溢出）</td></tr><tr><td>Overlay</td><td style="text-align:left;">叠加面板</td></tr><tr><td>Overload</td><td style="text-align:left;">重载</td></tr><tr><td>Override</td><td style="text-align:left;">覆盖，重写</td></tr><tr><td>Pack</td><td style="text-align:left;">打包，压缩</td></tr><tr><td>Package (noun)</td><td style="text-align:left;">（程序、软件）包</td></tr><tr><td>Package (verb)</td><td style="text-align:left;">打包，封装</td></tr><tr><td>Pane</td><td style="text-align:left;">窗格 (win) 面板 (mac)</td></tr><tr><td>Parallelism</td><td style="text-align:left;">并行性，并行</td></tr><tr><td>Parameter</td><td style="text-align:left;">参数（也称为形式参数，形参）</td></tr><tr><td>Parse</td><td style="text-align:left;">解析</td></tr><tr><td>Partition</td><td style="text-align:left;">分割；（硬盘）分区</td></tr><tr><td>Paste</td><td style="text-align:left;">粘贴</td></tr><tr><td>Patch</td><td style="text-align:left;">补丁 (win) 修补程序 (mac)</td></tr><tr><td>Pattern</td><td style="text-align:left;">模式；样式</td></tr><tr><td>Performance</td><td style="text-align:left;">性能</td></tr><tr><td>Persistence</td><td style="text-align:left;">持久性</td></tr><tr><td>Photo</td><td style="text-align:left;">照片</td></tr><tr><td>Physical layer</td><td style="text-align:left;">物理层</td></tr><tr><td>Picklist</td><td style="text-align:left;">选择列表</td></tr><tr><td>Placeholder</td><td style="text-align:left;">占位符</td></tr><tr><td>Pluggability</td><td style="text-align:left;">可插入性</td></tr><tr><td>Plugin</td><td style="text-align:left;">插件</td></tr><tr><td>Pointer</td><td style="text-align:left;">指针</td></tr><tr><td>Polymorphism</td><td style="text-align:left;">多态</td></tr><tr><td>Port</td><td style="text-align:left;">端口</td></tr><tr><td>Power bank</td><td style="text-align:left;">移动电源，充电宝</td></tr><tr><td>Presentation layer</td><td style="text-align:left;">表示层</td></tr><tr><td>Preset</td><td style="text-align:left;">预设</td></tr><tr><td>Print</td><td style="text-align:left;">打印</td></tr><tr><td>Printer</td><td style="text-align:left;">打印机</td></tr><tr><td>Procedure</td><td style="text-align:left;">过程</td></tr><tr><td>Process</td><td style="text-align:left;">进程</td></tr><tr><td>Profile</td><td style="text-align:left;">配置文件 (win) 描述文件 (mac)</td></tr><tr><td>Profile</td><td style="text-align:left;">评测</td></tr><tr><td>Profile (or Personal profile)</td><td style="text-align:left;">个人资料</td></tr><tr><td>Profiler</td><td style="text-align:left;">（性能）分析器</td></tr><tr><td>Program</td><td style="text-align:left;">程序</td></tr><tr><td>Project</td><td style="text-align:left;">项目</td></tr><tr><td>Protocol</td><td style="text-align:left;">协议</td></tr><tr><td>Provision, Provisioning</td><td style="text-align:left;">预配</td></tr><tr><td>Proxy (or Proxy server)</td><td style="text-align:left;">代理服务器</td></tr><tr><td>Pseudo code</td><td style="text-align:left;">伪代码</td></tr><tr><td>Pull-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Quality</td><td style="text-align:left;">质量</td></tr><tr><td>Queue</td><td style="text-align:left;">队列</td></tr><tr><td>Quit unexpectedly</td><td style="text-align:left;">意外退出</td></tr><tr><td>Radian</td><td style="text-align:left;">弧度</td></tr><tr><td>Radio button</td><td style="text-align:left;">单选按钮</td></tr><tr><td>RAM (Random Access Memory)</td><td style="text-align:left;">随机存取存储器</td></tr><tr><td>Read</td><td style="text-align:left;">读</td></tr><tr><td>Read-only</td><td style="text-align:left;">只读</td></tr><tr><td>Recovery</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Recursion</td><td style="text-align:left;">递归</td></tr><tr><td>Redirect, Redirection</td><td style="text-align:left;">重定向</td></tr><tr><td>Reference</td><td style="text-align:left;">参考</td></tr><tr><td>Register</td><td style="text-align:left;">寄存器；注册</td></tr><tr><td>Release</td><td style="text-align:left;">（发行、发布）版本</td></tr><tr><td>Remote</td><td style="text-align:left;">远程</td></tr><tr><td>Render</td><td style="text-align:left;">渲染</td></tr><tr><td>Resolution</td><td style="text-align:left;">分辨率</td></tr><tr><td>Response</td><td style="text-align:left;">响应</td></tr><tr><td>Response body</td><td style="text-align:left;">响应正文</td></tr><tr><td>Response header</td><td style="text-align:left;">响应头</td></tr><tr><td>Restore</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Return</td><td style="text-align:left;">返回；恢复</td></tr><tr><td>Revoke, Revocation</td><td style="text-align:left;">撤销</td></tr><tr><td>Rollback</td><td style="text-align:left;">回滚，回退</td></tr><tr><td>Routine</td><td style="text-align:left;">程序</td></tr><tr><td>Run</td><td style="text-align:left;">运行</td></tr><tr><td>Runtime, Run-time</td><td style="text-align:left;">运行期，运行时；运行环境</td></tr><tr><td>Runtime environment (RTE), Runtime system</td><td style="text-align:left;">运行环境；运行系统</td></tr><tr><td>Save</td><td style="text-align:left;">保存</td></tr><tr><td>Sampling</td><td style="text-align:left;">取样</td></tr><tr><td>Scalar</td><td style="text-align:left;">标量</td></tr><tr><td>Schedule</td><td style="text-align:left;">调度</td></tr><tr><td>Scheduler</td><td style="text-align:left;">调度器，调度程序</td></tr><tr><td>Scope</td><td style="text-align:left;">（作用、有效）范围，域</td></tr><tr><td>Scroll bar</td><td style="text-align:left;">滚动条</td></tr><tr><td>Script</td><td style="text-align:left;">脚本</td></tr><tr><td>SDK (Software Development Kit)</td><td style="text-align:left;">软件开发工具包 (win) 软件开发套件 (mac)</td></tr><tr><td>Search engine</td><td style="text-align:left;">搜索引擎</td></tr><tr><td>Security</td><td style="text-align:left;">安全性</td></tr><tr><td>Segment</td><td style="text-align:left;">段</td></tr><tr><td>Server</td><td style="text-align:left;">服务器</td></tr><tr><td>Server-side</td><td style="text-align:left;">服务器端</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session layer</td><td style="text-align:left;">会话层</td></tr><tr><td>Set up</td><td style="text-align:left;">设置</td></tr><tr><td>Settings</td><td style="text-align:left;">设置</td></tr><tr><td>Shortcut</td><td style="text-align:left;">快捷</td></tr><tr><td>Shortcut key</td><td style="text-align:left;">快捷键</td></tr><tr><td>Sign in, sign-in</td><td style="text-align:left;">登录</td></tr><tr><td>Sign out, sign-out</td><td style="text-align:left;">退出，注销</td></tr><tr><td>Silicon</td><td style="text-align:left;">硅</td></tr><tr><td>Simulation</td><td style="text-align:left;">模拟</td></tr><tr><td>Signature</td><td style="text-align:left;">签名</td></tr><tr><td>Slider</td><td style="text-align:left;">滑块</td></tr><tr><td>Smart</td><td style="text-align:left;">智能</td></tr><tr><td>Smartphone</td><td style="text-align:left;">智能手机</td></tr><tr><td>SMS (Short Message Service)</td><td style="text-align:left;">短信</td></tr><tr><td>Snip</td><td style="text-align:left;">截图</td></tr><tr><td>Source code</td><td style="text-align:left;">源代码，源码</td></tr><tr><td>Stack</td><td style="text-align:left;">栈</td></tr><tr><td>Star rating</td><td style="text-align:left;">星级评分</td></tr><tr><td>Statement</td><td style="text-align:left;">语句</td></tr><tr><td>Status bar</td><td style="text-align:left;">状态栏</td></tr><tr><td>Stepper</td><td style="text-align:left;">步进器</td></tr><tr><td>Stream</td><td style="text-align:left;">（数据）流</td></tr><tr><td>String</td><td style="text-align:left;">字符串</td></tr><tr><td>String interpolation</td><td style="text-align:left;">字符串插值</td></tr><tr><td>Stuttering</td><td style="text-align:left;">-</td></tr><tr><td>Subclass</td><td style="text-align:left;">子类</td></tr><tr><td>Subroutine</td><td style="text-align:left;">子例程</td></tr><tr><td>Superclass</td><td style="text-align:left;">超类</td></tr><tr><td>Support</td><td style="text-align:left;">支持</td></tr><tr><td>Suspend</td><td style="text-align:left;">暂停（权限）</td></tr><tr><td>Synchronize</td><td style="text-align:left;">同步</td></tr><tr><td>Synchronous</td><td style="text-align:left;">同步的</td></tr><tr><td>Tab</td><td style="text-align:left;">标签（页）</td></tr><tr><td>Tag</td><td style="text-align:left;">标签</td></tr><tr><td>Task</td><td style="text-align:left;">任务</td></tr><tr><td>Template</td><td style="text-align:left;">模板</td></tr><tr><td>Text</td><td style="text-align:left;">文本</td></tr><tr><td>Text box</td><td style="text-align:left;">文本框</td></tr><tr><td>Thread</td><td style="text-align:left;">线程</td></tr><tr><td>Top-up</td><td style="text-align:left;">充值</td></tr><tr><td>Token</td><td style="text-align:left;">标记 (win) 令牌 (mac)</td></tr><tr><td>权杖；代币</td><td style="text-align:left;"></td></tr><tr><td>Traverse</td><td style="text-align:left;">遍历</td></tr><tr><td>Tray (or System tray)</td><td style="text-align:left;">系统托盘</td></tr><tr><td>Tree</td><td style="text-align:left;">树</td></tr><tr><td>Tuple</td><td style="text-align:left;">元组</td></tr><tr><td>Tutorial</td><td style="text-align:left;">教程</td></tr><tr><td>Type</td><td style="text-align:left;">类型</td></tr><tr><td>Universal</td><td style="text-align:left;">通用的</td></tr><tr><td>Variable</td><td style="text-align:left;">变量</td></tr><tr><td>Video</td><td style="text-align:left;">视频</td></tr><tr><td>View</td><td style="text-align:left;">查看；显示；视图</td></tr><tr><td>Voice</td><td style="text-align:left;">语音</td></tr><tr><td>Volume</td><td style="text-align:left;">卷 (win)；宗卷 (mac)</td></tr><tr><td>Window</td><td style="text-align:left;">窗口</td></tr><tr><td>Widget</td><td style="text-align:left;">窗口部件；小部件</td></tr><tr><td>Wildcard</td><td style="text-align:left;">通配符</td></tr><tr><td>Workspaces</td><td style="text-align:left;">工作区</td></tr><tr><td>Write</td><td style="text-align:left;">写</td></tr></tbody></table>`,775)]))}const O=s(C,[["render",E]]),D=JSON.parse('{"path":"/article/ruankao/","title":"软考知识点","lang":"zh-CN","frontmatter":{"title":"软考知识点","createTime":"2025/03/18 17:13:30","permalink":"/article/ruankao/","description":"上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"软考知识点\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://www.52uni.cn/article/ruankao/"}],["meta",{"property":"og:site_name","content":"UNI知识库"}],["meta",{"property":"og:title","content":"软考知识点"}],["meta",{"property":"og:description","content":"上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"readingTime":{"minutes":124.22,"words":37265},"git":{},"autoDesc":true,"filePathRelative":"preview/softdesign.md","headers":[],"categoryList":[{"id":"5ebeb6","sort":10001,"name":"preview"}]}');export{O as comp,D as data};
