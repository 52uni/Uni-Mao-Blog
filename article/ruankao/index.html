<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.21" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.143" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"软考知识点","image":[""],"dateModified":null,"author":[]}</script><meta property="og:url" content="https://www.52uni.cn/article/ruankao/"><meta property="og:site_name" content="UNI知识库"><meta property="og:title" content="软考知识点"><meta property="og:description" content="上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><link rel="icon" type="image/png" href="https://avatars.githubusercontent.com/u/67443865?v=4"><title>软考知识点 | UNI知识库</title><meta name="description" content="上午题知识点 计算机组成原理 计算机基本工作原理 冯诺依曼体系结构 一、核心思想 存储程序 + 程序控制 计算机的 程序和数据统一存储在内存中，CPU 按顺序读取指令并执行。 二、五大组成部分 三、工作流程 输入：用户通过输入设备（如键盘）输入程序或数据。 存储：程序和数据存入存储器（如内存）。 执行 取指令：控制器从内存读取指令到 CPU。 译码：分..."><link rel="preload" href="/assets/style-CsH8MGI8.css" as="style"><link rel="stylesheet" href="/assets/style-CsH8MGI8.css"><link rel="modulepreload" href="/assets/app-BA0_WWK8.js"><link rel="modulepreload" href="/assets/index.html-X9b-p4da.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-d90a7a26><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-d5a8d0bc></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-d5a8d0bc> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-d90a7a26 data-v-e98a6132><div class="vp-navbar" vp-navbar data-v-e98a6132 data-v-2c31ea5e><div class="wrapper" data-v-2c31ea5e><div class="container" data-v-2c31ea5e><div class="title" data-v-2c31ea5e><div class="vp-navbar-title" data-v-2c31ea5e data-v-1a4f50af><a class="vp-link no-icon link title" href="/" data-v-1a4f50af data-v-442a52aa><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="https://avatars.githubusercontent.com/u/67443865?v=4" alt data-v-eda4b9bd><!--]--><!--[--><img class="vp-image light logo" style="" src="https://avatars.githubusercontent.com/u/67443865?v=4" alt data-v-eda4b9bd><!--]--><!--]--><!--]--><span data-v-1a4f50af>UNI知识库</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-2c31ea5e><div class="content-body" data-v-2c31ea5e><!--[--><!--]--><div class="vp-navbar-search search" data-v-2c31ea5e><div class="search-wrapper" data-v-97535d1e><!----><div id="local-search" data-v-97535d1e><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-97535d1e><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-2c31ea5e data-v-d43c1732><span id="main-nav-aria-label" class="visually-hidden" data-v-d43c1732>Main Navigation</span><!--[--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>博客</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/tags/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>标签</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/archives/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>归档</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/source/source/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>资源库</span><!----><!--]--><!----></a><!--]--><!--[--><div class="vp-flyout vp-navbar-menu-group" data-v-d43c1732 data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-86530b6c><span class="text" data-v-86530b6c><!----><!----><span data-v-86530b6c>笔记</span><!----><span class="vpi-chevron-down text-icon" data-v-86530b6c></span></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><div class="items" data-v-709dc2b1><!--[--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/basic/Readme/" data-v-1ff1855f data-v-442a52aa><!--[--><!----> 计算机基础知识 <!----><!--]--><!----></a></div><!--]--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/notes/backend/" data-v-1ff1855f data-v-442a52aa><!--[--><!----> 后端开发 <!----><!--]--><!----></a></div><!--]--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/notes/network-security/" data-v-1ff1855f data-v-442a52aa><!--[--><!----> 网络安全 <!----><!--]--><!----></a></div><!--]--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/notes/frontend/" data-v-1ff1855f data-v-442a52aa><!--[--><!----> 前端开发 <!----><!--]--><!----></a></div><!--]--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/notes/database/" data-v-1ff1855f data-v-442a52aa><!--[--><!----> 数据库 <!----><!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/nav/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-442a52aa><!--[--><!----><span data-v-d4acf911>导航</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-2c31ea5e data-v-a295abf6><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a295abf6 data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-2c31ea5e data-v-ad52545c data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-2c31ea5e data-v-652282fd data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-86530b6c><span class="vpi-more-horizontal icon" data-v-86530b6c></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><!----><!--[--><!--[--><!----><div class="group" data-v-652282fd><div class="item appearance" data-v-652282fd><p class="label" data-v-652282fd>外观</p><div class="appearance-action" data-v-652282fd><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-652282fd data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-652282fd><div class="item social-links" data-v-652282fd><div class="vp-social-links social-links-list" data-v-652282fd data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-2c31ea5e data-v-2b50024d><span class="container" data-v-2b50024d><span class="top" data-v-2b50024d></span><span class="middle" data-v-2b50024d></span><span class="bottom" data-v-2b50024d></span></span></button></div></div></div></div><div class="divider" data-v-2c31ea5e><div class="divider-line" data-v-2c31ea5e></div></div></div><!----></header><div class="vp-local-nav fixed reached-top is-blog" data-v-d90a7a26 data-v-3944d8e8><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-3944d8e8><span class="vpi-align-left menu-icon" data-v-3944d8e8></span><span class="menu-text" data-v-3944d8e8>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-3944d8e8 data-v-4114a62c><button data-v-4114a62c>返回顶部</button><!----></div></div><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-d90a7a26 data-v-b2beaca7><div class="vp-doc-container is-blog" data-v-b2beaca7 data-v-a703f9d3><!--[--><!--]--><div class="container" data-v-a703f9d3><!----><div class="content" data-v-a703f9d3><div class="content-container" data-v-a703f9d3><!--[--><!--]--><main class="main" data-v-a703f9d3><nav class="vp-breadcrumb" data-v-a703f9d3 data-v-1ae4ad7a><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-1ae4ad7a><!--[--><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-442a52aa><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="首页" data-v-1ae4ad7a><meta property="position" content="1" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/blog/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-442a52aa><!--[-->博客<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="博客" data-v-1ae4ad7a><meta property="position" content="2" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/blog/categories/?id=5ebeb6" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-442a52aa><!--[-->preview<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="preview" data-v-1ae4ad7a><meta property="position" content="3" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb current" href="/article/ruankao/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-442a52aa><!--[-->软考知识点<!--]--><!----></a><!----><meta property="name" content="软考知识点" data-v-1ae4ad7a><meta property="position" content="4" data-v-1ae4ad7a></li><!--]--></ol></nav><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-27be53cb>软考知识点 <!----></h1><div class="vp-doc-meta" data-v-27be53cb><!--[--><!--]--><p class="reading-time" data-v-27be53cb><span class="vpi-books icon" data-v-27be53cb></span><span data-v-27be53cb>约 51789 字</span><span data-v-27be53cb>大约 173 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-27be53cb><span class="vpi-clock icon" data-v-27be53cb></span><span data-v-27be53cb>2025-03-18</span></p></div><!--]--><!--[--><!--]--><div class="_article_ruankao_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-a703f9d3><!--[--><!--]--><div data-v-a703f9d3><h1 id="上午题知识点" tabindex="-1"><a class="header-anchor" href="#上午题知识点"><span>上午题知识点</span></a></h1><h2 id="计算机组成原理" tabindex="-1"><a class="header-anchor" href="#计算机组成原理"><span>计算机组成原理</span></a></h2><h3 id="计算机基本工作原理" tabindex="-1"><a class="header-anchor" href="#计算机基本工作原理"><span>计算机基本工作原理</span></a></h3><h4 id="冯诺依曼体系结构" tabindex="-1"><a class="header-anchor" href="#冯诺依曼体系结构"><span>冯诺依曼体系结构</span></a></h4><p><strong>一、核心思想</strong></p><p><strong>存储程序 + 程序控制</strong> 计算机的 <strong>程序和数据统一存储在内存中</strong>，CPU 按顺序读取指令并执行。</p><p><strong>二、五大组成部分</strong></p><table><thead><tr><th><strong>部件</strong></th><th><strong>功能</strong></th><th><strong>类比</strong></th></tr></thead><tbody><tr><td><strong>运算器</strong></td><td>算术运算（如加减乘除）和逻辑运算（如与或非）</td><td>计算器</td></tr><tr><td><strong>控制器</strong></td><td>指挥各部件协调工作（取指令、译码、执行）</td><td>指挥官</td></tr><tr><td><strong>存储器</strong></td><td>存放程序和数据（内存、硬盘等）</td><td>仓库</td></tr><tr><td><strong>输入设备</strong></td><td>将外部信息（如键盘、鼠标）输入到计算机</td><td>眼睛 / 耳朵</td></tr><tr><td><strong>输出设备</strong></td><td>将处理结果输出（如显示器、打印机）</td><td>嘴巴 / 手</td></tr></tbody></table><p><strong>三、工作流程</strong></p><ol><li><p><strong>输入</strong>：用户通过输入设备（如键盘）输入程序或数据。</p></li><li><p><strong>存储</strong>：程序和数据存入存储器（如内存）。</p></li><li><p><strong>执行</strong></p><ul><li><strong>取指令</strong>：控制器从内存读取指令到 CPU。</li><li><strong>译码</strong>：分析指令功能（如加法、跳转）。</li><li><strong>执行</strong>：运算器完成操作，结果存入内存或寄存器。</li></ul></li><li><p><strong>输出</strong>：结果通过输出设备（如屏幕）显示。</p><hr></li></ol><h4 id="计算机工作基本原理" tabindex="-1"><a class="header-anchor" href="#计算机工作基本原理"><span>计算机工作基本原理</span></a></h4><p><img src="/assets/image-20250316174337495-CO564BMc.png" alt="image-20250316174337495"></p><p><img src="/assets/image-20250404215904436-CXm_c510.png" alt="image-20250404215904436"></p><p><img src="/assets/image-20250316174428287-Cv9C5KZq.png" alt="image-20250316174428287"></p><p><img src="/assets/image-20250316174449320-DXoe8KSh.png" alt="image-20250316174449320"></p><p><img src="/assets/image-20250316174549313-D7x92kug.png" alt=""></p><p><img src="/assets/image-20250316174625466-BSTq1sdl.png" alt="image-20250316174625466"></p><hr><h4 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器"><span>寄存器</span></a></h4><h5 id="寄存器是什么" tabindex="-1"><a class="header-anchor" href="#寄存器是什么"><span><strong>寄存器是什么？</strong></span></a></h5><p><strong>定义</strong>：寄存器是 CPU 内部的 <strong>高速存储单元</strong>，用于 <strong>临时存放数据、指令或地址</strong>。 <strong>特点</strong>：</p><ul><li>访问速度极快（纳秒级，比内存快 100 倍以上）。</li><li>容量极小（通常每个 CPU 有几十个寄存器）。 <strong>比喻</strong>：类似你办公桌上的 <strong>临时小抽屉</strong>，存放你正在处理的文件（数据 / 指令），伸手就能拿到。</li></ul><h5 id="寄存器的分类与作用" tabindex="-1"><a class="header-anchor" href="#寄存器的分类与作用"><span><strong>寄存器的分类与作用</strong></span></a></h5><table><thead><tr><th><strong>寄存器类型</strong></th><th><strong>作用</strong></th><th><strong>典型例子</strong></th></tr></thead><tbody><tr><td><strong>通用寄存器</strong></td><td>存放临时数据、运算结果</td><td>AX（累加器）、BX（基址寄存器）</td></tr><tr><td><strong>程序计数器（PC）</strong></td><td>存储 <strong>下一条要执行的指令地址</strong></td><td>PC</td></tr><tr><td><strong>指令寄存器（IR）</strong></td><td>存放 <strong>当前正在执行的指令</strong></td><td>IR</td></tr><tr><td><strong>地址寄存器（MAR）</strong></td><td>存放 <strong>内存访问的地址</strong>（如读取数据或指令）</td><td>MAR</td></tr><tr><td><strong>状态寄存器（FLAGS）</strong></td><td>记录运算状态（如进位、溢出、零标志）</td><td>CF（进位标志）、ZF（零标志）</td></tr></tbody></table><hr><h4 id="校验码" tabindex="-1"><a class="header-anchor" href="#校验码"><span>校验码</span></a></h4><ul><li>CRC：<strong>模 2 运算</strong> 生成校验码，<strong>检错不纠错</strong>。</li><li>海明码：<strong>校验位定位错误</strong>，<strong>纠错能力强</strong>。</li><li>奇数校验：<strong>简单检错</strong>，但 <strong>可靠性低</strong>。</li></ul><h5 id="循环冗余校验-crc" tabindex="-1"><a class="header-anchor" href="#循环冗余校验-crc"><span>循环冗余校验（CRC）</span></a></h5><p><strong>循环冗余校验（CRC）</strong></p><ul><li><strong>核心原理</strong>：通过 <strong>多项式除法</strong>（模 2 运算）生成校验码，用于 <strong>检错</strong>。</li><li>常考点： <ul><li>生成多项式选择（如 CRC-16、CRC-32）。</li><li><strong>计算步骤</strong>：在数据后补 0，与生成多项式进行模 2 除法，余数即为校验码。</li><li><strong>检错能力</strong>：可检测 <strong>所有奇数位错误</strong> 和 <strong>突发错误</strong>（长度 ≤ 生成多项式位数）。</li></ul></li></ul><h5 id="海明码" tabindex="-1"><a class="header-anchor" href="#海明码"><span>海明码</span></a></h5><ul><li><strong>核心原理</strong>：通过插入 <strong>校验位</strong>（r 位），利用 <strong>奇偶校验</strong> 实现 <strong>纠错</strong>。</li><li>常考点： <ul><li>校验位位置：满足 <strong>2^r ≥ k + r + 1</strong>（k 为数据位，r 为校验位）。</li><li><strong>校验位计算</strong>：按位异或对应数据位。</li><li><strong>纠错过程</strong>：通过校验位组合定位错误位置。</li><li><strong>能力</strong>：可纠正 <strong>1 位错误</strong>，检测 <strong>2 位错误</strong>。</li></ul></li></ul><h5 id="奇数校验" tabindex="-1"><a class="header-anchor" href="#奇数校验"><span>奇数校验</span></a></h5><ul><li><p><strong>核心原理</strong>：使 <strong>数据位 + 校验位</strong> 的 1 的总数为 <strong>奇数</strong>。</p></li><li><p>常考点：</p><ul><li><p>校验位生成：根据数据位中 1 的个数确定（奇校验补 1，偶校验补 0）。</p></li><li><p><strong>局限性</strong>：仅能检测 <strong>奇数位错误</strong>，无法纠错。</p></li><li><p>应用场景：简单通信（如串口传输）。</p><hr></li></ul></li></ul><h4 id="原码补码反码移码" tabindex="-1"><a class="header-anchor" href="#原码补码反码移码"><span>原码补码反码移码</span></a></h4><h5 id="之间的相互转换" tabindex="-1"><a class="header-anchor" href="#之间的相互转换"><span>之间的相互转换</span></a></h5><ol><li><strong>原码</strong><ul><li><strong>定义</strong>：符号位（0 正 1 负）+ 数值绝对值的二进制表示。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1000 0110</code></li></ul></li><li><strong>转换规则</strong>：直接按符号位 + 数值转换。</li></ul></li><li><strong>反码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数符号位不变，其余位取反。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1001</code></li></ul></li><li><strong>转换规则</strong>：原码 → 反码（负数取反）。</li></ul></li><li><strong>补码</strong><ul><li><strong>定义</strong>：正数与原码相同；负数为反码末位加 1。</li><li>示例（8 位）： <ul><li>+6 → <code>0000 0110</code></li><li>-6 → <code>1111 1010</code></li></ul></li><li><strong>转换规则</strong>：反码 → 补码（末位 + 1）。</li></ul></li><li><strong>移码</strong><ul><li><strong>定义</strong>：补码符号位取反（常用于浮点数阶码）。</li><li>示例（8 位）： <ul><li>+6 → <code>1000 0110</code></li><li>-6 → <code>0111 1010</code></li></ul></li><li><strong>转换规则</strong>：补码 → 移码（符号位取反）。</li></ul></li></ol><h5 id="表示范围" tabindex="-1"><a class="header-anchor" href="#表示范围"><span>表示范围</span></a></h5><table><thead><tr><th>码制</th><th>整数范围</th><th>特殊值说明</th></tr></thead><tbody><tr><td>原码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1000 0000</code>）</td></tr><tr><td>反码</td><td>-127 ~ +127</td><td>±0 表示不同（<code>0000 0000</code> 和 <code>1111 1111</code>）</td></tr><tr><td>补码</td><td>-128 ~ +127</td><td>唯一 0（<code>0000 0000</code>），-128 表示为 <code>1000 0000</code></td></tr><tr><td>移码</td><td>-128 ~ +127</td><td>符号位取反，便于比较大小 唯一 0</td></tr></tbody></table><h5 id="真值计算" tabindex="-1"><a class="header-anchor" href="#真值计算"><span>真值计算</span></a></h5><ol><li><p><strong>原码转真值</strong></p><ul><li><code>1001 0101</code> → 符号位 1（负），数值 <code>001 0101</code> → -37。</li></ul></li><li><p><strong>补码转真值</strong></p><ul><li><code>1111 0101</code> → 符号位 1（负），取反得 <code>0000 1010</code>，加 1 得 <code>0000 1011</code> → -11。</li></ul></li><li><p><strong>移码转真值</strong></p><ul><li><code>0111 0101</code> → 符号位取反得补码 <code>1111 0101</code> → 真值 - 11。</li></ul><hr></li></ol><h4 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数"><span>浮点数</span></a></h4><p>浮点数在计算机中用以近似表示任意某个实数，一个浮点数 a 可如下表示: a = M*bE。</p><p><strong>尾数部分 M 的位数越多，数的精度越高。</strong></p><p><strong>指数部分 E 的位数越多，能表示的数值越大。</strong></p><p>因此在总长度固定的情况下，增加 E 的位数、减少 M 的位数可以扩大可表示的数的范围同时降低精度。</p><h5 id="定点表示和浮点表示" tabindex="-1"><a class="header-anchor" href="#定点表示和浮点表示"><span>定点表示和浮点表示</span></a></h5><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>定点表示</strong></td><td>小数点位置固定（如整数、纯小数），直接存储数值。</td><td>- 精度固定，范围小。 - 适合处理整数或固定精度小数。</td></tr><tr><td><strong>浮点表示</strong></td><td>采用科学计数法形式：<strong>尾数 × 基数 ^ 阶码</strong>（如 <code>±1.xxxxx×2^±yyy</code>）。</td><td>- 动态范围大，精度可变。 - 适合处理大范围数值（如科学计算）。</td></tr></tbody></table><h5 id="规格化" tabindex="-1"><a class="header-anchor" href="#规格化"><span>规格化</span></a></h5><p><strong>目的</strong>：使浮点数的表示唯一且有效位数最大化。 <strong>条件</strong>：</p><ul><li>原码规格化：尾数最高位必须为 1（避免前导零）。 <ul><li>例：<code>1.0101×2^3</code>（有效），<code>0.1010×2^4</code>（无效，需调整为 <code>1.010×2^3</code>）。</li></ul></li><li>补码规格化： <ul><li>正数：最高位为 1。</li><li>负数：最高位为 0（补码负数的绝对值最大，如 <code>1.0101</code> 表示 - 0.9375）。</li></ul></li></ul><p><strong>意义</strong>：消除冗余表示，提高精度。</p><h5 id="如何计算浮点数的表示范围" tabindex="-1"><a class="header-anchor" href="#如何计算浮点数的表示范围"><span>如何计算浮点数的表示范围</span></a></h5><hr><h4 id="与-或-异或-同或" tabindex="-1"><a class="header-anchor" href="#与-或-异或-同或"><span>与 或 异或 同或</span></a></h4><table><thead><tr><th><strong>输入 A</strong></th><th><strong>输入 B</strong></th><th><strong>与（AND）</strong></th><th><strong>或（OR）</strong></th><th><strong>异或（XOR）</strong></th><th><strong>同或（XNOR）</strong></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p><strong>关键规则说明</strong></p><ol><li><p><strong>与（AND）</strong>：只有 <strong>两个都为 1</strong> 时，结果才为 1。 → <strong>口诀</strong>：“有 0 则 0，全 1 才 1”。</p></li><li><p><strong>或（OR）</strong>：只要 <strong>有一个为 1</strong>，结果就为 1。 → <strong>口诀</strong>：“有 1 则 1，全 0 才 0”。</p></li><li><p><strong>异或（XOR）</strong>：两个值 <strong>不同</strong> 时结果为 1，相同则为 0。 → <strong>口诀</strong>：“不同为 1，相同为 0”。</p></li><li><p><strong>同或（XNOR）</strong>：两个值 <strong>相同</strong> 时结果为 1，不同则为 0。 → <strong>口诀</strong>：“相同为 1，不同为 0”（等同于异或结果取反）。</p><hr></li></ol><h4 id="冗余技术" tabindex="-1"><a class="header-anchor" href="#冗余技术"><span>冗余技术</span></a></h4><p>冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。通常冗余技术分为 4 类:</p><p>1.结构冗余，按其工作方法可以分为静态、动态和混合冗余;</p><p>2.信息冗余，指的是为了检测或纠正信息在运算或传输中的错误另外加的一部分信息;</p><p>3.时间冗余，是指以重复执行指令或程序来消除瞬时错误带来的影响;</p><p>4.冗余附件技术，是指为实现上述冗余技术所需的资源和技术。</p><hr><h3 id="存储系统" tabindex="-1"><a class="header-anchor" href="#存储系统"><span>存储系统</span></a></h3><h4 id="主存、辅存、cache" tabindex="-1"><a class="header-anchor" href="#主存、辅存、cache"><span>主存、辅存、cache</span></a></h4><table><thead><tr><th><strong>存储类型</strong></th><th><strong>全称</strong></th><th><strong>速度</strong></th><th><strong>容量</strong></th><th><strong>作用</strong></th><th><strong>典型设备</strong></th></tr></thead><tbody><tr><td><strong>Cache</strong></td><td>高速缓存</td><td>极快（纳秒级）</td><td>极小（MB 级）</td><td>缓解 CPU 与主存的速度差异</td><td>CPU 内置缓存</td></tr><tr><td><strong>主存</strong></td><td>主存储器</td><td>快（微秒级）</td><td>中等（GB 级）</td><td>CPU 直接访问的临时存储</td><td>内存条</td></tr><tr><td><strong>辅存</strong></td><td>辅助存储器</td><td>慢（毫秒级）</td><td>大（TB 级）</td><td>长期存储程序和数据</td><td>硬盘、SSD</td></tr></tbody></table><p><strong>主存主要采用动态随机存储器 DRAM</strong></p><p><strong>Cache 采用静态随机存储器 SRAM</strong></p><p><strong>EEPROM 是电擦除可编程的只读存储器</strong></p><p><strong>Cache 与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的。</strong></p><ol><li><p><strong>存储层次结构</strong></p><ul><li><strong>常考</strong>：Cache - 主存 - 辅存构成三级存储体系，速度递减、容量递增。</li></ul></li><li><p><strong>命中率优化</strong></p><ul><li><strong>示例</strong>：Cache 命中率越高，CPU 等待时间越少，性能越好。</li></ul></li><li><p><strong>虚拟内存技术</strong></p><ul><li><strong>常考</strong>：主存不足时，部分数据暂存到辅存（虚拟内存），但会导致速度下降。</li></ul></li></ol><h4 id="全相联、直接相连、组相连映射对比详解" tabindex="-1"><a class="header-anchor" href="#全相联、直接相连、组相连映射对比详解"><span>全相联、直接相连、组相连映射对比详解</span></a></h4><p><strong>一、核心概念</strong>**</p><ol><li><p><strong>直接相连映射（Direct Mapping）</strong></p><ul><li>主存块只能映射到 <strong>Cache 的唯一固定位置</strong>。</li><li>例如：主存块 0 → Cache 块 0，主存块 1 → Cache 块 1，依此类推。</li></ul></li><li><p><strong>组相连映射（Set Associative Mapping）</strong></p><ul><li>主存块映射到 Cache 的 <strong>某个组</strong>（如每组 4 块），组内块可自由选择。</li><li>例如：主存块 0 → Cache 组 0 的任意块（块 0-3）。</li></ul></li><li><p><strong>全相联映射（Fully Associative Mapping）</strong></p><ul><li>主存块可映射到 Cache 的 <strong>任意位置</strong>，无固定限制。</li></ul><p><strong>二、工作原理对比</strong></p><table><thead><tr><th><strong>映射方式</strong></th><th><strong>地址划分</strong></th><th><strong>查找逻辑</strong></th><th><strong>替换策略</strong></th></tr></thead><tbody><tr><td><strong>直接相连</strong></td><td>主存地址 = 块号 + 块内偏移</td><td>根据块号直接定位 Cache 块</td><td>固定替换（如覆盖）</td></tr><tr><td><strong>组相连</strong></td><td>主存地址 = 组号 + 块号 + 块内偏移</td><td>先定位组，再查找组内块</td><td>LRU、FIFO 等</td></tr><tr><td><strong>全相联</strong></td><td>主存地址 = 标签 + 块内偏移</td><td>遍历所有 Cache 块，对比标签</td><td>LRU、FIFO 等</td></tr></tbody></table><p><strong>三、特点对比表</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>直接相连</strong></th><th><strong>组相连</strong></th><th><strong>全相联</strong></th></tr></thead><tbody><tr><td><strong>映射规则</strong></td><td>固定位置</td><td>组内自由</td><td>完全自由</td></tr><tr><td><strong>冲突率</strong></td><td><strong>高</strong>（易地址冲突）</td><td><strong>中</strong></td><td><strong>低</strong></td></tr><tr><td><strong>查找速度</strong></td><td><strong>快</strong>（直接计算地址）</td><td><strong>中</strong>（组内搜索）</td><td><strong>慢</strong>（全 Cache 搜索）</td></tr><tr><td><strong>硬件复杂度</strong></td><td><strong>低</strong></td><td><strong>中</strong></td><td><strong>高</strong>（需全比较电路）</td></tr><tr><td><strong>典型应用</strong></td><td>片外 Cache、简单系统</td><td>一级 Cache、通用系统</td><td>小容量 Cache、高性能场景</td></tr></tbody></table></li></ol><h4 id="存储容量、存储块的计算方式" tabindex="-1"><a class="header-anchor" href="#存储容量、存储块的计算方式"><span>存储容量、存储块的计算方式</span></a></h4><h4 id="存储容量计算" tabindex="-1"><a class="header-anchor" href="#存储容量计算"><span><strong>存储容量计算</strong></span></a></h4><p><strong>存储容量</strong> 指存储器能存储的二进制信息总量，公式为： <strong>存储容量 = 存储单元数 × 每个单元的位数</strong></p><ul><li>若某存储器有 <strong>1024 个存储单元</strong>，每个单元 <strong>8 位</strong>，则总容量为： <code>1024 × 8 = 8192位 = 1024字节（1KB）</code></li><li>单位换算： <code>1KB=1024B</code>，<code>1MB=1024KB</code>，<code>1GB=1024MB</code>，依此类推。</li></ul><h4 id="存储块计算方式" tabindex="-1"><a class="header-anchor" href="#存储块计算方式"><span><strong>存储块计算方式</strong></span></a></h4><p><strong>存储块</strong> 是主存与 Cache 之间数据交换的最小单位，计算需明确：</p><ol><li><p><strong>主存总容量</strong></p></li><li><p><strong>块大小</strong>（主存与 Cache 的块大小必须一致）</p><p><strong>公式</strong>： <strong>主存块数量 = 主存总容量 ÷ 块大小</strong><strong>Cache 块数量 = Cache 总容量 ÷ 块大小</strong></p></li></ol><p><strong>示例</strong>：</p><ul><li>主存容量 <strong>1MB</strong>，块大小 <strong>16 字节</strong>： <code>1MB ÷ 16B = 65536块</code></li><li>Cache 容量 <strong>64KB</strong>，块大小 <strong>16 字节</strong>： <code>64KB ÷ 16B = 4096块</code></li></ul><h4 id="计算机的存储体系" tabindex="-1"><a class="header-anchor" href="#计算机的存储体系"><span>计算机的存储体系</span></a></h4><p>计算机中不同容量、不同速度、不同访问形式、不同用途的各种存储器形成的是一种层次结构的存储系统。所有的存储器设备按照一定的层次逻辑关系通过软硬件连接起来，并进行有效的管理，就形成了存储体系。不同层次上的存储器发挥着不同的作用。</p><p>一般计算机系统中主要有两种存储体系:</p><p>Cache 存储体系由 Cache 和主存储器构成，主要目的是提高存储器速度，对系统程序员以上均透明; 虚拟存储体系由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明。</p><h4 id="存储体系中的存储器" tabindex="-1"><a class="header-anchor" href="#存储体系中的存储器"><span>存储体系中的存储器</span></a></h4><p>按访问方式可分为按 <strong>地址访问的存储器</strong> 和 <strong>按内容访问的存储器</strong>;</p><p>按寻址方式分类可分为 <strong>随机存储器</strong>、<strong>顺序存储器</strong> 和 <strong>直接存储器</strong>。</p><ul><li><p>随机存储器(Random AccessMemory，<strong>RAM</strong>)指可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间是相同的。</p></li><li><p>顺序存储器(Sequentially AddressedMemory，SAM)指访问数据所需要的时间与数据所在的存储位置相关，磁带是典型的顺序存储器。</p></li><li><p>直接存储器(Direct AddressedMemory，<strong>DAM</strong>)是介于随机存取和顺序存取之间的一种寻址方式。磁盘是一种直接存取存储器，它对磁道的寻址是随机的，而在一个磁道内，则是顺序寻址。</p></li></ul><p>按照内容访问可分为相联存储器</p><ul><li>相联存储器是一种按内容访问的存储器。其工作原理就是把数据或数据的某一部分作为关键字，将该关键字与存储器中的每一单元进行比较，从而找出存储器中所有与关键字相同的数据字。</li></ul><h3 id="总线系统" tabindex="-1"><a class="header-anchor" href="#总线系统"><span>总线系统</span></a></h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h4><p>总线（Bus）是一组信号线组成的传输线束，它作为计算机各种功能部件之间传送信息的公共通信干线。根据计算机所传输的信息种类，总线可以分为数据总线、地址总线和控制总线。</p><ul><li><strong>数据总线（Data Bus）</strong>：用于在 CPU 与 RAM 之间来回传送需要处理或是需要储存的数据。它是双向的，意味着数据可以在两个方向上传输。</li><li><strong>地址总线（Address Bus）</strong>：用来指定在 RAM 之中储存的数据的地址。它是单向的，从 CPU 发出到内存或其他设备。</li><li><strong>控制总线（Control Bus）</strong>：将微处理器控制单元的信号传送到周边设备，如 USB Bus 和 1394 Bus 等。</li></ul><p><strong>总线的分类</strong></p><p>总线可以根据其所在位置、传输方式和工作模式进行分类：</p><ul><li><p><strong>按位置分</strong>：</p><ul><li>内部总线（片内总线）：存在于 CPU 芯片内部，用于寄存器之间和算术逻辑部件 ALU 与控制部件之间的数据传输。</li><li>系统总线（板级总线）：连接微机各插件板与系统板之间的总线，实现插件板一级的互联。</li><li>外部总线（通信总线）：连接计算机与其他外部设备或系统之间的总线。</li></ul></li><li><p><strong>按传输方式分</strong>：</p><ul><li>并行总线：多位数据同时通过多条线路传输，适合短距离高速数据传输。</li><li>串行总线：数据一位接一位地顺序传输，适用于长距离传输，成本较低且抗干扰能力强。</li></ul></li><li><p><strong>按工作模式分</strong>：</p><ul><li>单工：数据只能在一个方向上传输。</li><li>半双工：允许数据双向传输，但同一时间只能在一个方向上进行。</li><li>全双工：支持数据同时双向传输。</li></ul></li></ul><p><strong>总线性能指标</strong></p><p>了解总线的性能指标对于评估系统的效率至关重要。主要的性能指标包括：</p><ul><li><strong>带宽（Bandwidth）</strong>：指总线每秒可以传输的最大数据量，通常以位/秒（bps）或字节/秒（Bps）表示。</li><li><strong>总线速度（Bus Speed）</strong>：即总线的时钟频率，决定了每秒能进行多少次数据传输周期。</li><li><strong>总线协议（Bus Protocol）</strong>：定义了总线上的设备如何进行通信的具体规则。</li><li><strong>总线仲裁（Bus Arbitration）</strong>：当多个设备尝试同时访问总线时，决定哪个设备获得优先权的机制。</li></ul><p><strong>总线设计考虑因素</strong></p><p>在选择或设计总线时，需要综合考虑以下因素：</p><ul><li>数据传输速率的需求。</li><li>可靠性和稳定性，尤其是在高负载情况下。</li><li>成本效益分析，包括硬件成本和维护成本。</li><li>电磁兼容性（EMC），特别是在并行总线设计中尤为重要。</li></ul><h4 id="总线结构" tabindex="-1"><a class="header-anchor" href="#总线结构"><span>总线结构</span></a></h4><h5 id="单总线结构-single-bus-architecture" tabindex="-1"><a class="header-anchor" href="#单总线结构-single-bus-architecture"><span><strong>单总线结构（Single Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>所有设备共享一条单一总线（数据、地址、控制信号复用）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：简单、成本低、易于扩展。</li><li><strong>缺点</strong>：带宽瓶颈（多设备竞争）、延迟高。</li></ul></li><li><p><strong>应用场景</strong>：早期微型计算机（如 8 位 / 16 位系统）、嵌入式系统。</p></li></ul><h5 id="_2-双总线结构-dual-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_2-双总线结构-dual-bus-architecture"><span><strong>2. 双总线结构（Dual Bus Architecture）</strong></span></a></h5><ul><li><p>结构分为</p><p>系统总线（连接 CPU、内存）和 I/O 总线（连接外设）。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：分离高速与低速设备，减少冲突。</li><li><strong>缺点</strong>：需通过桥接器（如北桥芯片）中转，增加延迟。</li></ul></li><li><p><strong>应用场景</strong>：传统 x86 架构计算机（如 PCI 总线与 ISA 总线并存）。</p></li></ul><h5 id="_3-多总线结构-multi-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_3-多总线结构-multi-bus-architecture"><span><strong>3. 多总线结构（Multi-Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>多级总线分层连接，如高速总线（如 PCIe）连接 CPU 与显卡，低速总线（如 USB）连接外设。</p></li><li><p>特点</p><ul><li><strong>优点</strong>：优化带宽分配，支持高速设备（如 GPU、SSD）。</li><li><strong>缺点</strong>：复杂度高，需总线控制器协调。</li></ul></li><li><p><strong>应用场景</strong>：现代服务器、高性能计算机。</p></li></ul><h5 id="_4-层次化总线结构-hierarchical-bus-architecture" tabindex="-1"><a class="header-anchor" href="#_4-层次化总线结构-hierarchical-bus-architecture"><span><strong>4. 层次化总线结构（Hierarchical Bus Architecture）</strong></span></a></h5><ul><li><p>结构</p><p>总线按层次划分，如：</p><ol><li><strong>片内总线</strong>（SoC 内部，如 AMBA AHB/AXI）；</li><li><strong>系统总线</strong>（主板级，如 PCIe）；</li><li><strong>外部总线</strong>（外设级，如 USB）。</li></ol></li><li><p>特点</p><ul><li><strong>优点</strong>：分层管理，提升整体性能。</li><li><strong>缺点</strong>：依赖协议兼容性（如 PCIe 与 USB 的转换）。</li></ul></li><li><p><strong>应用场景</strong>：智能手机 SoC（如骁龙芯片）、个人计算机。</p></li></ul><h5 id="_5-专用总线结构" tabindex="-1"><a class="header-anchor" href="#_5-专用总线结构"><span><strong>5. 专用总线结构</strong></span></a></h5><ul><li><p>示例</p><ul><li><strong>内存总线</strong>：专用连接 CPU 与内存（如 DDR4/DDR5）；</li><li><strong>存储总线</strong>：连接存储控制器与硬盘（如 SATA、NVMe）。</li></ul></li><li><p>特点</p><ul><li><strong>优点</strong>：针对特定设备优化，高带宽、低延迟。</li><li><strong>缺点</strong>：通用性差。</li></ul><p><strong>总线结构的性能对比</strong></p><table><thead><tr><th><strong>结构类型</strong></th><th><strong>带宽</strong></th><th><strong>延迟</strong></th><th><strong>扩展性</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td>单总线</td><td>低</td><td>高</td><td>有限</td><td>嵌入式系统、早期微机</td></tr><tr><td>双总线</td><td>中</td><td>中</td><td>中等</td><td>传统 PC（已淘汰）</td></tr><tr><td>多总线</td><td>高</td><td>低</td><td>强</td><td>服务器、游戏 PC</td></tr><tr><td>层次化总线</td><td>极高</td><td>极低</td><td>极强</td><td>智能手机 SoC、高性能计算</td></tr></tbody></table></li></ul><h4 id="总线带宽计算" tabindex="-1"><a class="header-anchor" href="#总线带宽计算"><span>总线带宽计算</span></a></h4><p><strong>总线带宽 = 总线宽度 × 时钟频率</strong></p><p>假设我们有一个 32 位宽的总线，并且它的时钟频率是 200MHz，那么根据上述公式，我们可以这样计算总线带宽：</p><p>总线带宽 = 32 bits×200 MHz = 6400 Mbits/s</p><p>但是，因为数据传输率通常以字节（Byte）而非比特（bit）来表示，我们需要将结果转换成字节形式。由于 1 字节等于 8 比特，所以：</p><p>总线带宽 = 64008 MB/s = 800 MB/s</p><p>或者，如果我们想要将其转换为 GB/s，则需要进一步除以 1024：</p><p>总线带宽 = 8001024 GB/s≈0.78 GB/s</p><h3 id="输入输出系统" tabindex="-1"><a class="header-anchor" href="#输入输出系统"><span>输入输出系统</span></a></h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1"><span>概念</span></a></h4><ol><li><p><strong>输入输出定义</strong></p><ul><li><strong>输入</strong>：数据从外部设备传入计算机（如键盘、扫描仪）。</li><li><strong>输出</strong>：数据从计算机传出到外部设备（如显示器、打印机）。</li></ul></li><li><p><strong>输入输出系统组成</strong></p><ul><li><strong>外设</strong>：输入 / 输出设备（如磁盘、网卡）。</li><li><strong>I/O 接口</strong>：连接 CPU 与外设的桥梁，含数据、状态、控制寄存器。</li><li><strong>总线</strong>：系统总线（地址、数据、控制）用于传输信号。</li></ul></li></ol><h4 id="数据传送方式" tabindex="-1"><a class="header-anchor" href="#数据传送方式"><span>数据传送方式</span></a></h4><ol><li><p><strong>无条件传送</strong></p><ul><li>CPU 直接读写外设，无需状态查询。</li><li><strong>适用场景</strong>：简单外设（如开关、LED）。</li></ul></li><li><p><strong>查询传送</strong></p><ul><li>CPU 循环检测外设状态，就绪后传输数据。</li><li><strong>优点</strong>：实现简单；<strong>缺点</strong>：CPU 利用率低。</li></ul></li><li><p><strong>中断方式</strong></p><ul><li>外设主动向 CPU 发送中断请求，CPU 暂停当前任务处理中断。</li><li><strong>优点</strong>：CPU 利用率高；<strong>缺点</strong>：需处理中断上下文切换。</li></ul></li><li><p><strong>DMA（直接内存访问）</strong></p><ul><li>外设直接访问内存，无需 CPU 干预。</li><li><strong>优点</strong>：高速传输，适合大块数据（如磁盘读写）；<strong>缺点</strong>：硬件成本高。</li><li><strong>常考对比</strong>：DMA 与中断的区别（CPU 是否参与数据传输）。</li></ul></li></ol><h4 id="中断嵌套" tabindex="-1"><a class="header-anchor" href="#中断嵌套"><span>中断嵌套</span></a></h4><p>当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为中断嵌套。</p><p><strong>实现中断嵌套用后进先出的栈来保护断点和现场最有效。</strong></p><h3 id="指令系统和计算机体系结构" tabindex="-1"><a class="header-anchor" href="#指令系统和计算机体系结构"><span>指令系统和计算机体系结构</span></a></h3><h4 id="程序的局部性" tabindex="-1"><a class="header-anchor" href="#程序的局部性"><span>程序的局部性</span></a></h4><p><strong>一、核心概念</strong></p><p>程序的局部性原理是指 <strong>程序在执行时倾向于访问 *<em>*</em> 近期使用过的数据或指令</strong>，以及 <strong>邻近的数据或指令</strong>。这一特性是计算机系统设计（如缓存、虚拟内存）的基础，也是程序优化的重要依据。</p><p><strong>二、局部性分类</strong></p><ol><li><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据或指令被访问，那么在 <strong>不久的将来</strong> 很可能再次被访问。</li><li>示例 <ul><li>循环中的变量（如 <code>for (int i=0; i&lt;1000; i++)</code> 中的 <code>i</code>）。</li><li>函数调用中的局部变量（多次被使用）。</li></ul></li></ul></li><li><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><p><strong>定义</strong>：如果一个数据或指令被访问，那么与其 <strong>相邻的内存区域</strong> 的数据或指令也可能很快被访问。</p></li><li><p>示例</p><ul><li>连续存储的数组元素（如 <code>arr[0], arr[1], arr[2]</code>）。</li><li>代码中的顺序执行（如连续的指令块）。</li></ul></li></ul></li></ol><h5 id="精简指令系统和复杂指令系统" tabindex="-1"><a class="header-anchor" href="#精简指令系统和复杂指令系统"><span>精简指令系统和复杂指令系统</span></a></h5><ol><li><p><strong>RISC（精简指令系统）</strong></p><ul><li><strong>设计理念</strong>：简化指令集，通过减少指令种类和复杂度提升执行效率。</li><li><strong>典型代表</strong>：ARM、MIPS、RISC-V。</li></ul></li><li><p><strong>CISC（复杂指令系统）</strong></p><ul><li><p><strong>设计理念</strong>：提供丰富复杂的指令，通过单条指令完成复杂操作以减少代码量。</p></li><li><p><strong>典型代表</strong>：x86（如 Intel/AMD 处理器）。</p></li></ul></li></ol><table><thead><tr><th><strong>对比项</strong></th><th style="text-align:center;"><strong>RISC</strong></th><th><strong>CISC</strong></th></tr></thead><tbody><tr><td><strong>指令数量</strong></td><td style="text-align:center;">少（约 100 条以内）</td><td>多（可达数百条）</td></tr><tr><td><strong>指令长度</strong></td><td style="text-align:center;">固定（便于流水线处理）</td><td>可变（复杂指令长度不同）</td></tr><tr><td><strong>执行周期</strong></td><td style="text-align:center;">单周期执行</td><td>多周期执行</td></tr><tr><td><strong>内存访问</strong></td><td style="text-align:center;">仅 LOAD/STORE 指令访问内存</td><td>指令可直接操作内存</td></tr><tr><td><strong>流水线效率</strong></td><td style="text-align:center;">高（指令简单，并行性强）</td><td>低（指令复杂，易阻塞流水线）</td></tr><tr><td><strong>硬件复杂度</strong></td><td style="text-align:center;">低（无需微程序控制）</td><td>高（需微程序解析复杂指令）</td></tr><tr><td><strong>编译器依赖</strong></td><td style="text-align:center;">高（依赖编译器优化）</td><td>低（指令功能强，编程灵活）</td></tr></tbody></table><h4 id="流水线概念以及常见计算" tabindex="-1"><a class="header-anchor" href="#流水线概念以及常见计算"><span>流水线概念以及常见计算</span></a></h4><p><strong>一、吞吐率定义</strong></p><ul><li><strong>概念</strong>：单位时间内完成的指令数量（或任务数），衡量流水线的处理效率。</li><li><strong>公式</strong>： <strong>吞吐率（TP）= 指令数（n） / 总执行时间（T）</strong> 单位：指令数 / 时间单位（如条 / 秒、条 /ns）。</li></ul><p><strong>二、流水线吞吐率计算</strong></p><ol><li><p><strong>最大吞吐率（理想情况）</strong></p><ul><li>当流水线完全填满后，每周期完成一条指令。<strong>最长执行时间的倒数</strong></li><li><strong>公式</strong>： <strong>最大吞吐率（TP_max）= 1 / 最长阶段时间（Δt_max）</strong></li><li><strong>示例</strong>：最长阶段时间为 3ns → TP_max ≈ 0.33 条 /ns。</li></ul></li><li><p><strong>实际吞吐率（考虑指令数）</strong></p><ul><li><strong>公式</strong>： <strong>TP = n / [ (k + n -1) × Δt_max ]</strong> （k 为阶段数，n 为指令数）</li><li><strong>示例</strong>：k = 5，n = 100，Δt_max = 3ns → TP = 100 / 312 ≈ 0.32 条 /ns。</li></ul></li></ol><h4 id="vliw-超长指令字" tabindex="-1"><a class="header-anchor" href="#vliw-超长指令字"><span>VLIW（超长指令字）</span></a></h4><p>一种非常长的指令组合，把许多条指令连在一起增加运算速度。</p><h4 id="寻址方式" tabindex="-1"><a class="header-anchor" href="#寻址方式"><span>寻址方式</span></a></h4><p>采用不同寻址方式的目的是为了扩大寻址空间提高编程灵活性</p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>立即寻址</strong></td><td>操作数直接包含在指令中</td><td><code>ADD R0, #5</code>（R0 += 5）</td><td>无需内存访问，速度快，但操作数范围受限（受指令长度限制）。</td></tr><tr><td><strong>直接寻址</strong></td><td>指令中包含内存地址</td><td><code>LOAD R1, [0x1000]</code>（R1 = 内存 0x1000）</td><td>地址固定，适合访问静态数据，但地址空间有限（需完整地址位）。</td></tr><tr><td><strong>寄存器寻址</strong></td><td>操作数存于寄存器中</td><td><code>ADD R0, R1</code>（R0 += R1）</td><td>速度最快，RISC 架构核心方式（如 ARM、RISC-V）。</td></tr><tr><td><strong>寄存器间接寻址</strong></td><td>寄存器存储内存地址</td><td><code>LOAD R2, [R3]</code>（R2 = 内存 [R3]）</td><td>灵活访问动态数据，适合数组、指针操作。</td></tr><tr><td><strong>基址寻址</strong></td><td>基址寄存器 + 偏移量确定地址</td><td><code>LOAD R4, [R5+0x20]</code>（R4 = 内存 [R5+32]）</td><td>简化数组、结构体访问，支持内存分段管理。</td></tr><tr><td><strong>变址寻址</strong></td><td>变址寄存器 + 偏移量确定地址</td><td><code>LOAD R6, [0x1000+R7]</code>（R6 = 内存 [2560 + R7]）</td><td>适合循环遍历数组，偏移量固定，寄存器动态调整。</td></tr><tr><td><strong>相对寻址</strong></td><td>当前指令地址 + 偏移量确定地址</td><td><code>JMP 0x10</code>（跳转到当前地址 + 16）</td><td>常用于分支指令，节省地址空间（只需偏移量）。</td></tr></tbody></table><p><strong>典型应用场景</strong></p><ol><li><strong>立即寻址</strong>：初始化常量、简单运算。</li><li><strong>寄存器间接寻址</strong>：动态数据访问（如链表、堆内存）。</li><li><strong>基址 + 变址寻址</strong>：二维数组、结构体成员访问。</li><li><strong>相对寻址</strong>：程序跳转（如函数调用、条件分支）。</li></ol><h4 id="寻址范围计算" tabindex="-1"><a class="header-anchor" href="#寻址范围计算"><span>寻址范围计算</span></a></h4><p>范围 = 内存容量/字节长度</p><h4 id="flynn-分类法" tabindex="-1"><a class="header-anchor" href="#flynn-分类法"><span>flynn 分类法</span></a></h4><p><strong>Flynn 分类法定义</strong></p><ul><li><p><strong>提出背景</strong>：由 Michael J. Flynn 于 1966 年提出，用于 <strong>根据指令流（Instruction Stream）和数据流（Data Stream）的并行性</strong> 对计算机体系结构进行分类。</p></li><li><p>核心维度：</p><ol><li><strong>指令流并行性</strong>：是否同时执行多条指令。</li><li><strong>数据流并行性</strong>：是否同时处理多个数据项。</li></ol><h4 id="flynn-分类法四大类型" tabindex="-1"><a class="header-anchor" href="#flynn-分类法四大类型"><span><strong>Flynn 分类法四大类型</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>全称</strong></th><th><strong>指令流</strong></th><th><strong>数据流</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>SISD</strong></td><td>单指令流单数据流</td><td>单指令</td><td>单数据</td><td>传统串行计算机，无并行处理能力。</td><td>早期个人计算机（如 8086）</td></tr><tr><td><strong>SIMD</strong></td><td>单指令流多数据流</td><td>单指令</td><td>多数据</td><td>一条指令操作多个数据（数据级并行）。</td><td>GPU、向量处理器（如 Intel AVX）</td></tr><tr><td><strong>MISD</strong></td><td>多指令流单数据流</td><td>多指令</td><td>单数据</td><td>理论上存在，实际应用极少（可能用于容错处理）。</td><td>研究原型（如某些纠错系统）</td></tr><tr><td><strong>MIMD</strong></td><td>多指令流多数据流</td><td>多指令</td><td>多数据</td><td>多条指令独立操作多个数据（任务级并行）。</td><td>多核 CPU、分布式计算集群</td></tr></tbody></table></li></ul><h3 id="系统性能评测和可靠性基础" tabindex="-1"><a class="header-anchor" href="#系统性能评测和可靠性基础"><span>系统性能评测和可靠性基础</span></a></h3><h4 id="系统可靠度计算" tabindex="-1"><a class="header-anchor" href="#系统可靠度计算"><span>系统可靠度计算</span></a></h4><p>可靠度表示为 R</p><p><strong>串联</strong>: R 相乘</p><p><strong>示例</strong>：R1 = 0.9, <em>R</em> 2 = 0.95, <em>R</em> 3 = 0.98。</p><p><em>R</em> 串联 = 0.9×0.95×0.98 = 0.8379(83.79%)</p><p><strong>并联:</strong></p><p>两个并联为 1-(1-R)²</p><p>R = 0.9</p><p>R 并联 = 1−(0.1×0.1)= 0.99(99%)</p><p><img src="/assets/image-20250405110413577-DyhoXqts.png" alt="image-20250405110413577"></p><p>可靠度为（1-（1-R）³）（1-（1-R）²）</p><h2 id="程序语言" tabindex="-1"><a class="header-anchor" href="#程序语言"><span>程序语言</span></a></h2><h3 id="程序设计语言基础概念" tabindex="-1"><a class="header-anchor" href="#程序设计语言基础概念"><span>程序设计语言基础概念</span></a></h3><h4 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念"><span>核心概念</span></a></h4><ol><li><p><strong>低级语言 vs 高级语言</strong></p><ul><li><strong>低级语言</strong>：机器语言（二进制指令）、汇编语言（符号指令），执行效率高但开发效率低。</li><li><strong>高级语言</strong>：Java、C、Python 等，接近自然语言，开发效率高但需翻译（编译 / 解释）。</li></ul></li><li><p><strong>编译程序 vs 解释程序</strong></p><ul><li><strong>编译程序</strong>：一次性生成目标程序（如.exe 文件），执行效率高，不可调试。</li><li><strong>解释程序</strong>：边翻译边执行，开发灵活但效率低（如 Python、JavaScript）。</li></ul></li><li><p><strong>语言三要素</strong></p><ul><li><p><strong>语法</strong>：结构规则（如括号匹配、分号结尾）。</p></li><li><p><strong>语义</strong>：逻辑含义（如变量类型是否匹配）。</p></li><li><p><strong>语用</strong>：符号与使用者的关系（如注释、代码规范）。</p></li></ul></li></ol><h4 id="语言处理程序基础" tabindex="-1"><a class="header-anchor" href="#语言处理程序基础"><span>语言处理程序基础</span></a></h4><ul><li><strong>词法分析</strong>：识别单词符号（如关键字、标识符）。</li><li><strong>语法分析</strong>：检查语法结构（如表达式是否合法）。</li><li><strong>语义分析</strong>：类型检查（如整数与字符串相加错误）。</li><li><strong>中间代码生成</strong>：转换为与机器无关的代码（如逆波兰式、四元式）。</li><li><strong>代码优化</strong>：提升执行效率（如循环展开、冗余删除）。</li><li><strong>目标代码生成</strong>：输出机器语言或汇编代码。</li></ul><h4 id="程序设计语言基本成分" tabindex="-1"><a class="header-anchor" href="#程序设计语言基本成分"><span>程序设计语言基本成分</span></a></h4><ol><li><p><strong>数据成分</strong></p><ul><li><strong>常量 / 变量</strong>：全局量（静态存储） vs 局部量（动态存储）。</li><li><strong>数据类型</strong>：基本类型（int、char）、构造类型（数组、结构体）、抽象类型（类）。</li></ul></li><li><p><strong>控制成分</strong></p><ul><li><strong>条件语句</strong>：<code>if-else</code>、<code>switch-case</code>。</li><li><strong>循环语句</strong>：<code>for</code>、<code>while</code>、<code>do-while</code>。</li><li><strong>函数调用</strong>: <ul><li><strong>值调用</strong>：形参修改不影响实参。</li><li><strong>引用调用</strong>：形参修改直接影响实参（如 C++ 的指针）。</li></ul></li></ul></li><li><p><strong>运算成分</strong></p><ul><li><p><strong>运算符优先级</strong>：如 <code>*</code> 高于 <code>+</code>。</p></li><li><p><strong>逻辑运算</strong>：<code>&amp;&amp;</code>（短路与）、<code>||</code>（短路或）、<code>!</code>。</p></li></ul></li></ol><h4 id="核心传递方式对比-软考高频" tabindex="-1"><a class="header-anchor" href="#核心传递方式对比-软考高频"><span><strong>核心传递方式对比（软考高频）</strong></span></a></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>定义</strong></th><th><strong>语言示例</strong></th><th><strong>是否修改实参</strong></th><th><strong>常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>值调用</strong></td><td>传递参数副本，函数内修改不影响实参。</td><td>C 的普通参数、Java 基本类型</td><td>❌ 否</td><td>交换函数无效（如 <code>swap(int a, int b)</code> 无法交换实参）。</td></tr><tr><td><strong>引用调用</strong></td><td>传递实参地址（或别名），函数内修改直接影响实参。</td><td>C++ 引用（<code>&amp;</code>）、C# <code>ref</code>/<code>out</code></td><td>✅ 是</td><td>Java 对象引用是 “值传递的引用”：可修改对象属性，但无法改变引用指向（如无法交换两个对象）。</td></tr><tr><td><strong>指针传递</strong></td><td>传递指针变量（地址的副本），通过解引用修改实参。</td><td>C 的指针（<code>int*</code>）</td><td>✅ 是</td><td>区分 “传递指针” 与 “传递指针指向的值”：<code>func(int* p)</code> 可改 <code>*p</code>，但无法改 <code>p</code> 本身（如交换指针无效）。</td></tr><tr><td><strong>传名调用</strong></td><td>参数在调用处替换为表达式，可能多次求值（已过时，软考仅考概念）。</td><td>Algol、早期 Pascal</td><td>✅ 可能</td><td>副作用：表达式含自增（如 <code>a++</code>）时，多次求值导致结果不可控。</td></tr></tbody></table><p><strong>典型语言实现与常考细节</strong></p><ol><li><strong>C 语言</strong><ul><li><strong>值调用</strong>：默认方式，如 <code>void f(int x) { x=5; }</code>，调用后实参不变。</li><li><strong>指针传递</strong>：需显式传递地址，如 <code>void f(int* x) { *x=5; }</code>，调用 <code>f(&amp;a)</code> 修改 <code>a</code>。</li><li><strong>常考题</strong>：交换函数必须用指针，否则无效。</li></ul></li><li><strong>C++</strong><ul><li><strong>引用调用</strong>：<code>void f(int&amp; x) { x=5; }</code>，实参直接被修改。</li><li><strong>区别指针</strong>：引用必须初始化，且语法更简洁（无需 <code>*</code>）。</li></ul></li><li><strong>Java</strong><ul><li><strong>基本类型</strong>：值调用，如 <code>void f(int x)</code> 无法修改实参。</li><li><strong>对象类型</strong>：传递对象引用的副本（值调用的引用），可修改对象属性（如 <code>obj.name=&quot;new&quot;</code>），但无法改变引用指向（如无法通过函数让 <code>obj</code> 指向新对象）。</li><li><strong>常考题</strong>：判断 “Java 的对象传递是引用调用” 是否正确（错误，本质是值传递的引用）。</li></ul></li><li><strong>C#</strong><ul><li><strong><code>ref</code></strong>：引用调用，实参需初始化，如 <code>void f(ref int x) { x=5; }</code>。</li><li><strong><code>out</code></strong>：强制函数内赋值，用于 “输出参数”，如 <code>void f(out int x) { x=5; }</code>。</li></ul></li><li><strong>Python</strong><ul><li><strong>可变对象（列表、字典）</strong>：值调用传递对象引用，可修改内容（如 <code>lst.append(3)</code>），但无法重新赋值（如 <code>lst = [1,2]</code> 不影响实参）。</li><li><strong>不可变对象（整数、字符串）</strong>：值调用，修改无效。</li></ul></li></ol><h4 id="语言分类以及特点" tabindex="-1"><a class="header-anchor" href="#语言分类以及特点"><span>语言分类以及特点</span></a></h4><table><thead><tr><th><strong>分类</strong></th><th><strong>代表语言</strong></th><th><strong>核心特点</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><strong>命令式语言</strong></td><td>C、Java、C#、C++</td><td>强调算法步骤，支持变量和控制流（顺序、分支、循环），分面向过程和面向对象。</td><td>C：系统开发、嵌入式；Java/C#：企业级应用、Android 开发；C++：游戏引擎、桌面软件。</td></tr><tr><td><strong>函数式语言</strong></td><td>Haskell、Lisp、Scala</td><td>纯函数、不可变性、惰性求值，强调数学计算逻辑。</td><td>Haskell：金融计算；Lisp：早期 AI；Scala：大数据处理（Spark）。</td></tr><tr><td><strong>逻辑式语言</strong></td><td>Prolog</td><td>基于一阶逻辑，声明性编程，自动推理。</td><td>专家系统、自然语言处理、数据库查询优化。</td></tr><tr><td><strong>脚本语言</strong></td><td>Python、JavaScript、PHP</td><td>动态类型、语法简洁、解释执行，开发效率高。</td><td>Python：数据分析、AI；JavaScript：Web 全栈；PHP：中小型 Web 应用。</td></tr><tr><td><strong>科学计算语言</strong></td><td>Fortran、MATLAB</td><td>高效数值计算，支持矩阵运算和可视化。</td><td>Fortran：工程模拟；MATLAB：信号处理、控制系统设计。</td></tr><tr><td><strong>现代语言</strong></td><td>Go、Swift、Rust</td><td>高性能、安全性、简洁语法，支持并发或特定场景优化。</td><td>Go：云服务（Docker）；Swift：iOS 开发；Rust：区块链、内存安全服务端。</td></tr><tr><td><strong>其他重要语言</strong></td><td>SQL</td><td>非过程化，面向数据操作，声明式查询。</td><td>数据库管理、数据检索与分析。</td></tr></tbody></table><h4 id="错误类型分类" tabindex="-1"><a class="header-anchor" href="#错误类型分类"><span>错误类型分类</span></a></h4><table><thead><tr><th><strong>错误类型</strong></th><th><strong>定义</strong></th><th><strong>典型示例</strong></th><th><strong>语言示例</strong></th><th><strong>软考常考陷阱</strong></th></tr></thead><tbody><tr><td><strong>语法错误</strong></td><td>违反编程语言的语法规则，无法通过编译。</td><td>缺少分号、括号不匹配、关键字拼写错误</td><td>C、Java、Python 编译阶段报错</td><td>注意中文符号（如 “；” 代替 “;”）导致的隐藏错误。</td></tr><tr><td><strong>类型错误</strong></td><td>操作符与操作数类型不匹配，编译阶段检查。</td><td>字符串与整数相加、数组越界</td><td>C 的 <code>int + char</code>、Java 的 <code>String s = 123</code></td><td>注意自动类型转换（如 C 的 <code>char</code> 转 <code>int</code>）可能掩盖类型错误。</td></tr><tr><td><strong>语义错误</strong></td><td>语法正确但逻辑含义错误，导致程序行为不符合预期。</td><td>条件判断错误、算法逻辑错误</td><td>错误的循环终止条件、错误的公式计算</td><td>软考常考 “逻辑错误” 与 “运行时错误” 的区分：逻辑错误可能在运行时才暴露。</td></tr><tr><td><strong>运行时错误</strong></td><td>程序运行期间发生的错误，通常导致程序崩溃或异常。</td><td>除零错误、空指针解引用、数组越界</td><td>C 的 <code>NULL指针解引用</code>、Java 的 <code>NullPointerException</code></td><td>注意 Java 的 “受检异常” 与 “非受检异常” 区别（如 <code>IOException</code> 需显式处理）。</td></tr><tr><td><strong>链接错误</strong></td><td>编译通过但链接阶段找不到符号（如未定义的函数或变量）。</td><td>函数声明与实现不匹配、库文件缺失</td><td>C 的 <code>undefined reference to &#39;func&#39;</code></td><td>软考可能结合编译流程考查链接错误的原因（如函数名大小写不一致）。</td></tr><tr><td><strong>逻辑错误</strong></td><td>算法设计错误，导致结果不正确但程序不崩溃。</td><td>排序算法错误、错误的业务逻辑</td><td>冒泡排序中的循环次数错误</td><td>逻辑错误是软考重点考查对象，需通过测试用例发现（如错误的闰年判断条件）。</td></tr></tbody></table><h4 id="典型错误类型解析与常考细节" tabindex="-1"><a class="header-anchor" href="#典型错误类型解析与常考细节"><span><strong>典型错误类型解析与常考细节</strong></span></a></h4><ol><li><p><strong>语法错误</strong></p><ul><li><p><strong>特点</strong>：编译阶段直接报错，必须修复才能运行。</p></li><li><p>示例</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 正确</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 缺少分号（语法错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：混淆 “语法错误” 与 “语义错误”，例如 <code>if (a = 0)</code> 是语法正确但语义错误（应为 <code>a == 0</code>）。</p></li></ul></li><li><p><strong>运行时错误</strong></p><ul><li><p>分类</p><ul><li><strong>异常</strong>：可捕获处理（如 Java 的 <code>try-catch</code>）。</li><li><strong>崩溃</strong>：不可恢复（如 C 的除零错误直接终止程序）。</li></ul></li><li><p>示例</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 数组越界（运行时错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考常考</strong>：Java 的 <code>ArrayIndexOutOfBoundsException</code> 属于运行时错误，而 C 的数组越界可能导致未定义行为。</p></li></ul></li><li><p><strong>逻辑错误</strong></p><ul><li><p><strong>隐蔽性</strong>：程序正常运行但结果错误，需通过测试发现。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">def</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> is_leap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">year</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> year </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">%</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 错误，未处理整百年（软考经典逻辑错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>软考重点</strong>：算法设计题中常见，如错误的循环条件导致结果偏差。</p></li></ul></li><li><p><strong>类型错误</strong></p><ul><li><p><strong>静态类型语言</strong>（如 C、Java）：编译阶段检查。</p></li><li><p><strong>动态类型语言</strong>（如 Python）：运行时检查。</p></li><li><p>示例</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # 运行时类型错误（Python）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>软考陷阱</strong>：Java 的自动拆箱 / 装箱可能掩盖类型错误（如 <code>Integer i = null; int j = i;</code> 导致 <code>NullPointerException</code>）。</p></li></ul></li></ol><h3 id="编译、解释系统" tabindex="-1"><a class="header-anchor" href="#编译、解释系统"><span>编译、解释系统</span></a></h3><h4 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h4><p><strong>编译是将高级程序设计语言编写的源程序转化为目标机器可执行的机器语言程序的过程</strong>。</p><ul><li><strong>词法分析</strong>：编译的第一个阶段，使用有限自动机实现。从左到右扫描源程序字符流，依据词法规则将其识别为一个个单词，如关键字、标识符、常量、运算符等。</li><li><strong>语法分析</strong>：基于词法分析得到的单词序列，依据语法规则，使用多种方法如 <strong>自顶向下</strong>（递归下降分析法和预测分析法）<strong>和自底向上</strong> 等（移进-归约分析法），构建语法树，检查源程序的语法结构是否正确。</li><li><strong>语义分析</strong>：在语法分析基础上，对语法树进行遍历，依据语义规则检查源程序语义的正确性，如类型检查、变量声明与使用一致性检查等，并进行必要的语义处理，如生成中间代码。</li><li><strong>中间代码生成</strong>：是编译程序的重要阶段，将源程序转换为一种中间表示形式，<strong>方便进行与目标机器无关的优化和生成目标代码</strong>，常采用规定的表示形式有 <strong>三地址码、四元式、后缀式、语法树</strong> 等。</li><li><strong>代码优化</strong>：对中间代码进行等价变换，依据优化原则和技术，如常量折叠、公共子表达式删除等，提高目标代码的执行效率。</li><li><strong>目标代码生成</strong>：根据目标机器的指令集和体系结构，将优化后的中间代码转换为目标机器可执行的机器语言代码，涉及寄存器分配、指令选择等工作。</li></ul><p>常见的中间代码形式。</p><h4 id="编译语言和解释语言" tabindex="-1"><a class="header-anchor" href="#编译语言和解释语言"><span>编译语言和解释语言</span></a></h4><p><strong>编译语言</strong></p><ul><li><strong>简介</strong>：编写的源代码通过编译器一次性翻译成目标机器的机器码，生成可执行文件，执行时直接运行可执行文件。</li><li><strong>举例</strong>：C、C++、Java（Java 有编译过程，生成字节码，在虚拟机上运行，也可看作特殊的编译语言）等。</li></ul><p><strong>解释语言</strong></p><ul><li><p><strong>简介</strong>：源代码由解释器逐行解释并执行，不生成目标机器码，边解释边执行。</p></li><li><p><strong>举例</strong>：Python、JavaScript、Ruby 等。</p><p><strong>对比</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>解释型语言</strong></th><th><strong>编译型语言</strong></th><th><strong>软考常考点</strong></th></tr></thead><tbody><tr><td><strong>翻译方式</strong></td><td>逐行翻译并立即执行</td><td>一次性整体翻译为目标代码</td><td>翻译方式的差异（逐行 vs 整体）</td></tr><tr><td><strong>运行过程</strong></td><td>源代码 → 解释器 → 执行</td><td>源代码 → 编译器 → 可执行文件 → 执行</td><td>运行阶段的步骤（是否生成中间文件）</td></tr><tr><td><strong>语法检查</strong></td><td>运行时检查（错误即时反馈）</td><td>编译时检查（生成错误报告）</td><td>错误检测的时机（运行时 vs 编译时）</td></tr><tr><td><strong>开发效率</strong></td><td>高（修改后立即生效）</td><td>低（需重新编译）</td><td>开发效率与调试便利性</td></tr><tr><td><strong>执行速度</strong></td><td>慢（逐行解释）</td><td>快（直接执行机器码）</td><td>执行效率对比（软考高频考点）</td></tr><tr><td><strong>跨平台性</strong></td><td>好（只需解释器）</td><td>差（需编译不同平台版本）</td><td>跨平台能力的优劣</td></tr><tr><td><strong>典型语言</strong></td><td>Python、PHP、JavaScript、BASIC</td><td>C、C++、Java（编译为字节码后由 JVM 解释）</td><td>语言分类（如 Java 的特殊性：编译 + 解释）</td></tr><tr><td><strong>代码安全性</strong></td><td>伪码易被反编译</td><td>机器码难逆向</td><td>安全性对比（需注意 Java 的字节码也可能被反编译）</td></tr><tr><td><strong>中间代码</strong></td><td>可能生成中间码（如字节码）但不保存</td><td>生成目标代码（如机器码、汇编）并保存</td><td>是否生成独立的中间文件</td></tr></tbody></table></li></ul><h3 id="文法分析" tabindex="-1"><a class="header-anchor" href="#文法分析"><span>文法分析</span></a></h3><h4 id="_1-文法的定义与分类" tabindex="-1"><a class="header-anchor" href="#_1-文法的定义与分类"><span>1. 文法的定义与分类</span></a></h4><ul><li><strong>文法</strong>：形式化描述语言的规则集合，由四元组 <em>G</em> =(<em>V</em> <em>N</em>, <em>V</em> <em>T</em>, <em>P</em>, <em>S</em>) 表示： <ul><li><em>V</em> <em>N</em>：非终结符集（如 <em>S</em>, <em>A</em>, <em>B</em>）。</li><li><em>V</em> <em>T</em>：终结符集（如 <em>a</em>, <em>b</em>,+）。</li><li><em>P</em>：产生式规则（如 <em>S</em> → <em>a</em> <em>S</em> <em>b</em>）。</li><li><em>S</em>：开始符号。</li></ul></li><li><strong>文法类型（乔姆斯基分类）</strong>： <ul><li><strong>0 型（无限制文法）</strong>：无约束条件，等价于图灵机。</li><li><strong>1 型（上下文有关文法）</strong>：产生式形如 <em>α</em> → <em>β</em>，其中 ∣ <em>α</em> ∣≤∣ <em>β</em> ∣。</li><li><strong>2 型（上下文无关文法）</strong>：产生式形如 <em>A</em> → <em>β</em>，非终结符可替换为任意符号串。</li><li><strong>3 型（正规文法）</strong>：产生式形如 <em>A</em> → <em>a</em> <em>B</em> 或 <em>A</em> → <em>a</em>，对应有限自动机。</li></ul></li></ul><h4 id="_2-推导与归约" tabindex="-1"><a class="header-anchor" href="#_2-推导与归约"><span>2. 推导与归约</span></a></h4><ul><li><strong>推导</strong>：从开始符号出发，通过产生式规则生成句子的过程（如 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> ⇒ <em>aabb</em>）。</li><li><strong>最左（右）推导</strong>：每次替换最左（右）非终结符。</li><li><strong>归约</strong>：推导的逆过程，从句子反向构造语法树。</li></ul><h4 id="_3-语法树与短语" tabindex="-1"><a class="header-anchor" href="#_3-语法树与短语"><span>3. 语法树与短语</span></a></h4><ul><li><strong>语法树</strong>：可视化推导过程的树形结构。</li><li><strong>短语</strong>：某个非终结符可推导出的符号串（如在 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em> ⇒ <em>aa</em> <em>S</em> <em>bb</em> 中，<em>a</em> <em>S</em> 是相对于 <em>S</em> 的短语）。</li><li><strong>句柄</strong>：最左直接短语，用于自底向上分析（如 LR 分析）。</li></ul><h4 id="_4-语法分析方法" tabindex="-1"><a class="header-anchor" href="#_4-语法分析方法"><span>4. 语法分析方法</span></a></h4><ul><li>自顶向下分析：LL (1)、递归下降分析。 <ul><li><strong>LL(1)</strong>：第一个 L 表示从左到右扫描，第二个 L 表示最左推导，1 表示向前看一个符号。</li><li><strong>条件</strong>：无左递归、无回溯、First 和 Follow 集不相交。</li></ul></li><li>自底向上分析：LR(0)、SLR(1)、LR(1)、LALR(1)。 <ul><li><strong>LR 分析</strong>：L 表示从左到右扫描，R 表示最右推导的逆过程。</li></ul></li></ul><h4 id="软考常考题目解析" tabindex="-1"><a class="header-anchor" href="#软考常考题目解析"><span>软考常考题目解析</span></a></h4><h6 id="_1-文法分类题" tabindex="-1"><a class="header-anchor" href="#_1-文法分类题"><span>1. <strong>文法分类题</strong></span></a></h6><p><strong>题目</strong>：判断以下文法类型：<em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em><strong>分析</strong>：</p><ul><li>产生式形式为 <em>A</em> → <em>β</em>，符合上下文无关文法（2 型）。</li><li>无法转换为正规文法（3 型），因存在递归嵌套。 <strong>答案</strong>：上下文无关文法。</li></ul><h5 id="_2-first-和-follow-集计算" tabindex="-1"><a class="header-anchor" href="#_2-first-和-follow-集计算"><span>2. <strong>First 和 Follow 集计算</strong></span></a></h5><p><strong>题目</strong>：文法 <em>G</em> =(<em>S</em>, <em>A</em>, <em>a</em>, <em>b</em>, <em>P</em>, <em>S</em>)，其中 <em>P</em> 为：<em>S</em> → <em>a</em> <em>A</em> <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em> 求 First (S)、First (A)、Follow (S)、Follow (A)。 <strong>解答</strong>：</p><ul><li><p><strong>First(S)</strong>：由 <em>S</em> → <em>a</em> <em>A</em>，First(S) = {a}。</p></li><li><p><strong>First(A)</strong>：由 <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，First(A) = {b, ε}。</p></li><li><p>Follow(S)</p><p>：</p><ul><li>S 是开始符号，初始 Follow (S) = {#}。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号。</li><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号，而 A 可推导出 ε，因此 Follow (S) = Follow (S) ∪ Follow (A)。</li><li>最终 Follow (S) = {#, b}。</li></ul></li><li><p>Follow(A)</p><p>：</p><ul><li>由 <em>S</em> → <em>a</em> <em>A</em>，A 后可能有 Follow (S) 中的符号（即 {#, b}）。</li><li>由 <em>A</em> → <em>b</em> <em>S</em>，S 后可能有 Follow (A) 中的符号，但 S 的 Follow 集包含 {#, b}，因此 Follow (A) = {#, b}。</li></ul></li></ul><h5 id="_3-ll-1-文法判定" tabindex="-1"><a class="header-anchor" href="#_3-ll-1-文法判定"><span>3. <strong>LL (1) 文法判定</strong></span></a></h5><p><strong>题目</strong>：判断文法 <em>S</em> → <em>a</em> <em>S</em> <em>b</em> ∣ <em>ab</em> 是否为 LL (1)。 <strong>分析</strong>：</p><ul><li><p><strong>First(S)</strong>：{a}（两个产生式的 First 集相同，无冲突）。</p></li><li><p><strong>Follow(S)</strong>：{b, #}（由推导 <em>S</em> ⇒ <em>a</em> <em>S</em> <em>b</em>，S 后可能有 b 或结束符 #）。</p></li><li><p>条件</p><p>：所有产生式的 First 集不相交，且 First 集与 Follow 集无交集。</p><ul><li>此处两个产生式的 First 集均为 {a}，无冲突，且 First (S) 与 Follow (S) 无交集。 <strong>结论</strong>：是 LL (1) 文法。</li></ul></li></ul><h5 id="_4-lr-分析表构造" tabindex="-1"><a class="header-anchor" href="#_4-lr-分析表构造"><span>4. <strong>LR 分析表构造</strong></span></a></h5><p><strong>题目</strong>：对文法 <em>S</em> → <em>a</em> <em>A</em>, <em>A</em> → <em>b</em> <em>S</em> ∣ <em>ϵ</em>，构造 LR (0) 分析表。 <strong>步骤</strong>：</p><ol><li><p><strong>拓广文法</strong>：添加 <em>S</em>′→ <em>S</em>。</p></li><li><p>构造项目集</p><p>：</p><ul><li><em>I</em> 0: <em>S</em>′→⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 1: <em>S</em>′→ <em>S</em> ⋅（接受状态）</li><li><em>I</em> 2: <em>S</em> → <em>a</em> ⋅ <em>A</em>, <em>A</em> →⋅ <em>b</em> <em>S</em> ∣⋅ <em>ϵ</em></li><li><em>I</em> 3: <em>A</em> → <em>b</em> ⋅ <em>S</em>, <em>S</em> →⋅ <em>a</em> <em>A</em></li><li><em>I</em> 4: <em>A</em> → <em>ϵ</em> ⋅（归约状态）</li></ul></li><li><p><strong>转移函数</strong>：根据符号跳转（如 <em>I</em> 0 输入 a 转移到 <em>I</em> 2）。</p></li><li><p>分析表</p><p>：</p><ul><li><em>I</em> 0：action [a] = s2（移进）。</li><li><em>I</em> 2：action [b] = s3（移进），action [ε] = r2（归约）。</li><li><em>I</em> 4：goto [A] = I_1（归约后转到 S 的状态）。 <strong>答案</strong>：分析表需完整列出所有状态和符号的 action/goto 项。</li></ul></li></ol><h3 id="有限自动机" tabindex="-1"><a class="header-anchor" href="#有限自动机"><span>有限自动机</span></a></h3><h4 id="核心知识点" tabindex="-1"><a class="header-anchor" href="#核心知识点"><span><strong>核心知识点</strong></span></a></h4><ol><li><strong>定义与五元组</strong> 有限自动机是一个五元组：<code>M = (Q, Σ, δ, q₀, F)</code>，其中： <ul><li><strong>Q</strong>：有限状态集；</li><li><strong>Σ</strong>：输入字母表；</li><li><strong>δ</strong>：转移函数（DFA 为单值映射，NFA 为多值映射或含 ε 转移）；</li><li><strong>q₀</strong>：初始状态；</li><li><strong>F</strong>：终止状态集。</li></ul></li><li><strong>类型</strong><ul><li><strong>确定有限自动机（DFA）</strong>：每个状态对每个输入有唯一转移。</li><li><strong>非确定有限自动机（NFA）</strong>：允许 ε 转移和多值转移，可通过 ε- 闭包简化为 DFA。</li></ul></li><li><strong>语言识别</strong> 输入字符串被接受的条件是：从初始状态出发，按转移规则遍历字符后到达终止状态。</li><li><strong>正则表达式与自动机的转换</strong><ul><li><strong>正则式 →NFA</strong>：通过 Thompson 算法构造。</li><li><strong>NFA→DFA</strong>：通过子集构造法（如 ε- 闭包计算）。</li><li><strong>DFA 最小化</strong>：通过等价类划分（如 Hopcroft 算法）。</li></ul></li></ol><h4 id="软考常考点" tabindex="-1"><a class="header-anchor" href="#软考常考点"><span><strong>软考常考点</strong></span></a></h4><ol><li><p><strong>DFA 与 NFA 的区别</strong></p><ul><li>重点：DFA 转移唯一，NFA 允许多转移和 ε 动作。</li><li>题型示例：判断给定自动机是 DFA 还是 NFA。</li></ul></li><li><p><strong>状态转移图分析</strong></p><ul><li>常考：根据状态转移图，选择自动机接受的字符串（如以特定模式结尾）。</li><li>解题技巧：模拟路径，关注终止状态条件。</li></ul></li><li><p><strong>正则式与自动机的转换</strong></p><ul><li>软考高频考点：将正则式转换为 NFA，或根据自动机图写出对应的正则式。</li></ul></li><li><p><strong>ε- 闭包与子集构造法</strong></p><ul><li>常考步骤：计算 NFA 的 ε- 闭包，将其转换为等价 DFA。</li></ul></li><li><p><strong>DFA 最小化</strong></p><ul><li>步骤：划分状态等价类，合并不可区分状态。</li></ul></li></ol><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h2><h3 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理"><span>进程管理</span></a></h3><h4 id="进程与线程基础" tabindex="-1"><a class="header-anchor" href="#进程与线程基础"><span><strong>进程与线程基础</strong></span></a></h4><p><strong>1. 进程定义</strong></p><ul><li>进程是<strong>程序的一次执行过程</strong>，是操作系统资源分配的基本单位。</li><li>包含：程序段、数据段、进程控制块（PCB，记录进程状态和资源信息）。</li></ul><p><strong>2. 进程特征</strong></p><ul><li><strong>动态性</strong>：进程有生命周期（创建、运行、终止）。</li><li><strong>并发性</strong>：多个进程可同时执行（宏观并行，微观交替）。</li><li><strong>独立性</strong>：进程独立获得资源和调度。</li><li><strong>异步性</strong>：进程按不可预知的速度推进。</li></ul><p><strong>3. 线程（轻量级进程）</strong></p><ul><li><p>线程是<strong>CPU 调度的基本单位</strong>，共享进程资源（如内存、文件句柄）。</p></li><li><p>分类：</p><ul><li><strong>用户线程</strong>：由用户空间库管理，操作系统不可见（优点：切换快，缺点：一个线程阻塞可能导致进程阻塞）。</li><li><strong>内核线程</strong>：由操作系统内核管理，线程调度由内核完成（优点：支持多处理器并发，缺点：切换开销略高）。</li></ul></li><li><p>进程 vs 线程：</p><table><thead><tr><th><strong>对比项</strong></th><th><strong>进程</strong></th><th><strong>线程</strong></th></tr></thead><tbody><tr><td>资源分配单位</td><td>是</td><td>否（共享进程资源）</td></tr><tr><td>调度单位</td><td>是（旧系统）</td><td>是（现代系统）</td></tr><tr><td>上下文切换开销</td><td>高（需切换内存空间等资源）</td><td>低（仅切换寄存器、栈等）</td></tr></tbody></table></li></ul><h4 id="进程状态与转换" tabindex="-1"><a class="header-anchor" href="#进程状态与转换"><span><strong>进程状态与转换</strong></span></a></h4><p><strong>1. 三态模型（基础状态）</strong></p><table><thead><tr><th><strong>状态</strong></th><th><strong>说明</strong></th><th><strong>转换条件</strong></th></tr></thead><tbody><tr><td><strong>运行态</strong></td><td>进程正在 CPU 上执行（单 CPU 下同一时刻仅一个进程处于此状态）。</td><td>从就绪态被调度选中。</td></tr><tr><td><strong>就绪态</strong></td><td>进程具备执行条件，等待 CPU 调度。</td><td>进程创建后；运行态进程因时间片用完或被更高优先级进程抢占。</td></tr><tr><td><strong>阻塞态</strong></td><td>进程因等待某事件（如 I/O 完成、资源获取）暂时无法执行。</td><td>等待的事件发生（如 I/O 完成），重新回到就绪态。</td></tr></tbody></table><p><strong>2. 五态模型（扩展状态）</strong></p><ul><li><strong>新建态</strong>：进程正在被创建，尚未加入就绪队列。</li><li><strong>终止态</strong>：进程执行结束或异常终止，等待操作系统回收资源。</li></ul><p><strong>3. 状态转换核心逻辑</strong></p><ul><li><strong>阻塞→就绪</strong>：等待的事件完成（如 I/O 操作结束）。</li><li><strong>运行→阻塞</strong>：进程主动请求等待事件（如调用 I/O 函数）。</li><li><strong>运行→就绪</strong>：时间片耗尽（抢占式调度）或主动让出 CPU（非抢占式）。</li></ul><h4 id="进程调度算法" tabindex="-1"><a class="header-anchor" href="#进程调度算法"><span><strong>进程调度算法</strong></span></a></h4><p><strong>1. 调度目标</strong></p><ul><li>公平性：各进程获得合理的 CPU 时间。</li><li>效率：减少上下文切换开销，提高 CPU 利用率。</li><li>响应时间：交互式任务需快速响应（如时间片轮转算法）。</li></ul><p><strong>2. 常见算法分类</strong></p><table><thead><tr><th><strong>算法类型</strong></th><th><strong>算法名称</strong></th><th><strong>核心思想</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>先来先服务（FCFS）</strong></td><td>非抢占式</td><td>按进程到达顺序调度，先就绪先执行。</td><td>实现简单，公平。</td><td>长任务可能导致短任务等待（“饥饿”）。</td><td>批处理系统</td></tr><tr><td><strong>短作业优先（SJF）</strong></td><td>非抢占式 / 抢占式（短剩余时间优先）</td><td>优先调度预计运行时间最短的进程。</td><td>平均等待时间最短。</td><td>需预知作业运行时间（实际难实现）。</td><td>批处理系统</td></tr><tr><td><strong>时间片轮转（RR）</strong></td><td>抢占式</td><td>将 CPU 时间划分为固定时间片，进程轮流执行，时间片用完则切换。</td><td>响应时间均衡，适合交互式任务。</td><td>时间片过短会增加切换开销。</td><td>分时系统（如 Linux）</td></tr><tr><td><strong>优先级调度</strong></td><td>抢占式 / 非抢占式</td><td>为进程分配优先级，优先调度高优先级进程（可解决 “饥饿”，如动态调整优先级）。</td><td>灵活控制任务优先级。</td><td>低优先级进程可能长期等待（需避免饥饿）。</td><td>实时系统、多任务系统</td></tr><tr><td><strong>高响应比优先（HRRN）</strong></td><td>非抢占式</td><td>响应比 =（等待时间 + 运行时间）/ 运行时间，优先选择响应比高的进程。</td><td>兼顾公平性与效率。</td><td>每次调度需计算响应比，开销略高。</td><td>批处理系统</td></tr></tbody></table><h4 id="进程同步与互斥" tabindex="-1"><a class="header-anchor" href="#进程同步与互斥"><span><strong>进程同步与互斥</strong></span></a></h4><p><strong>1. 核心问题</strong></p><ul><li><strong>临界资源</strong>：一次仅允许一个进程访问的资源（如打印机、共享变量）。</li><li><strong>临界区</strong>：访问临界资源的代码段。</li><li><strong>目标</strong>：确保多个进程互斥访问临界区，避免数据不一致（如银行账户余额同时读写）。</li></ul><p><strong>2. 解决方法</strong></p><ul><li><strong>信号量机制（PV 操作）</strong>： <ul><li><strong>信号量 S</strong>：一个整数变量，代表可用资源数（S≥0 时表示可用资源数，S&lt;0 时绝对值表示等待队列中的进程数）。</li><li><strong>P 操作（申请资源）</strong>：S 减 1，若 S&lt;0 则进程阻塞，加入等待队列。</li><li><strong>V 操作（释放资源）</strong>：S 加 1，若 S≤0 则唤醒等待队列中的一个进程。</li><li><strong>例子</strong>：互斥访问临界区（初始 S=1，P/V 操作包裹临界区）。</li></ul></li><li><strong>经典问题</strong>： <ul><li><strong>生产者 - 消费者问题</strong>：通过信号量实现缓冲区的互斥与同步（空缓冲区数、满缓冲区数、互斥信号量）。</li><li><strong>读者 - 写者问题</strong>：允许多个读者同时读，但写者需互斥（区分 “读者优先” 和 “写者优先” 策略）。</li></ul></li></ul><p><strong>3. 进程通信（IPC）方式</strong></p><ul><li><strong>共享内存</strong>：多个进程直接访问同一块内存区域（最快，但需手动同步）。</li><li><strong>消息传递</strong>：通过消息队列或管道（如无名管道、命名管道）交换数据（安全，无需手动同步）。</li><li><strong>信号量与信号</strong>：信号量用于同步，信号（如 Ctrl+C）用于通知进程事件（如终止、暂停）。</li></ul><h4 id="死锁问题" tabindex="-1"><a class="header-anchor" href="#死锁问题"><span><strong>死锁问题</strong></span></a></h4><p><strong>1. 死锁定义</strong></p><ul><li>多个进程因竞争资源或相互等待对方释放资源，导致所有进程无法继续执行的状态。</li></ul><p><strong>2. 死锁必要条件（四缺一则无死锁）</strong></p><ul><li><strong>互斥条件</strong>：资源一次只能被一个进程占用。</li><li><strong>请求与保持条件</strong>：进程已持有资源，同时请求其他资源（且不释放已持有资源）。</li><li><strong>不可剥夺条件</strong>：资源只能被进程主动释放，不能被强制剥夺。</li><li><strong>循环等待条件</strong>：进程间形成资源等待环（A 等 B 的资源，B 等 A 的资源）。</li></ul><p><strong>3. 死锁处理策略</strong></p><table><thead><tr><th><strong>策略</strong></th><th><strong>核心思想</strong></th><th><strong>典型方法</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>死锁预防</strong></td><td>破坏死锁必要条件（至少破坏一个）。</td><td>如禁止 “请求与保持”（进程启动时申请所有资源）、资源按序分配（破坏循环等待）。</td><td>简单，但可能浪费资源（如提前申请未使用的资源）。</td></tr><tr><td><strong>死锁避免</strong></td><td>在资源分配前预判是否可能导致死锁，避免进入不安全状态。</td><td><strong>银行家算法</strong>：计算进程的最大需求、已分配资源、剩余资源，判断分配是否安全（存在安全序列则分配）。</td><td>效率较高，但需知道进程的最大资源需求（实际难满足）。</td></tr><tr><td><strong>死锁检测与解除</strong></td><td>定期检测是否存在死锁，若存在则通过剥夺资源或终止进程解除。</td><td>构建资源分配图，检测环是否存在；解除时优先终止优先级低或消耗资源少的进程。</td><td>允许死锁发生，适用于死锁不频繁的场景，但解除代价高（可能丢失进程数据）。</td></tr></tbody></table><p><strong>4. 银行家算法示例</strong></p><ul><li><p><strong>数据结构</strong>：最大需求矩阵 Max、已分配矩阵 Allocation、需求矩阵 Need（Need=Max-Allocation）、可用资源向量 Available。</p></li><li><p><strong>安全检查</strong>：尝试为每个进程分配其所需资源，若能找到一个安全序列（所有进程均可执行完毕），则当前状态安全，否则不安全（拒绝分配）。</p><hr></li></ul><h3 id="文件管理" tabindex="-1"><a class="header-anchor" href="#文件管理"><span>文件管理</span></a></h3><p><strong>文件系统的作用</strong></p><ul><li>实现<strong>按名存取</strong>：用户通过文件名访问文件，无需关心物理存储位置。</li><li>管理<strong>磁盘空间</strong>：分配 / 回收空闲块，记录文件的物理位置（如 FAT 表、inode）。</li><li>提供<strong>安全与共享机制</strong>：权限控制（如 UNIX 的 rwx）、文件共享（硬链接 / 软链接）。</li><li>支持<strong>数据持久化</strong>：将数据长期存储在磁盘等非易失性介质中。</li></ul><h4 id="文件的逻辑结构" tabindex="-1"><a class="header-anchor" href="#文件的逻辑结构"><span><strong>文件的逻辑结构</strong></span></a></h4><p><strong>1. 记录式文件</strong></p><ul><li><strong>定长记录文件</strong>：所有记录长度相同，支持随机访问（如数据库表）。</li><li><strong>变长记录文件</strong>：记录长度可变，需索引表辅助定位（如日志文件）。</li></ul><p><strong>2. 流式文件</strong></p><ul><li>无结构的字节流，按顺序访问（如文本文件、视频文件）。</li><li>优点：简单灵活，适用于连续读写场景。</li></ul><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>定长记录文件</strong></td><td>记录长度固定，随机访问高效</td><td>数据库、学生信息表</td></tr><tr><td><strong>变长记录文件</strong></td><td>记录长度可变，需索引表定位</td><td>日志、邮件系统</td></tr><tr><td><strong>流式文件</strong></td><td>无结构字节流，顺序访问为主</td><td>文本、多媒体文件</td></tr></tbody></table><h4 id="文件的物理结构" tabindex="-1"><a class="header-anchor" href="#文件的物理结构"><span><strong>文件的物理结构</strong></span></a></h4><p><strong>1. 连续分配</strong></p><ul><li><strong>原理</strong>：文件数据存放在连续的磁盘块中。</li><li><strong>优点</strong>：顺序访问速度快，支持随机访问。</li><li><strong>缺点</strong>：易产生外部碎片，文件扩展困难。</li></ul><p><strong>2. 链式分配</strong></p><ul><li><strong>隐式链接</strong>：每个块包含指向下一块的指针，仅支持顺序访问（如 FAT32 早期版本）。</li><li><strong>显式链接</strong>：指针集中存储在 FAT 表中，支持随机访问（如 FAT32）。</li><li><strong>优点</strong>：无外部碎片，动态扩展方便。</li><li><strong>缺点</strong>：随机访问需遍历指针，FAT 表占用内存。</li></ul><p><strong>3. 索引分配</strong></p><ul><li><strong>原理</strong>：文件数据块地址存放在索引块中，支持随机访问。</li><li><strong>多层索引</strong>：通过多级索引块管理大文件（如 EXT4 的 extent 结构）。</li><li><strong>混合索引</strong>：小文件直接存储地址，大文件使用索引（如 UNIX 的 inode）。</li><li><strong>优点</strong>：高效随机访问，支持大文件。</li><li><strong>缺点</strong>：索引块占用额外空间。</li></ul><table><thead><tr><th><strong>类型</strong></th><th><strong>访问方式</strong></th><th><strong>碎片问题</strong></th><th><strong>扩展性</strong></th><th><strong>典型系统</strong></th></tr></thead><tbody><tr><td><strong>连续分配</strong></td><td>随机 / 顺序</td><td>外部碎片</td><td>差</td><td>早期 DOS</td></tr><tr><td><strong>链式分配</strong></td><td>顺序为主</td><td>无</td><td>好</td><td>FAT32、早期 Linux</td></tr><tr><td><strong>索引分配</strong></td><td>随机 / 顺序</td><td>无</td><td>好</td><td>NTFS、EXT4</td></tr></tbody></table><h4 id="目录结构与路径" tabindex="-1"><a class="header-anchor" href="#目录结构与路径"><span><strong>目录结构与路径</strong></span></a></h4><p><strong>1. 目录结构类型</strong></p><ul><li><strong>单级目录</strong>：所有文件存放在同一目录，不支持重名（仅适用于简单系统）。</li><li><strong>树形目录</strong>：分层结构（根目录→子目录→文件），支持重名文件（如 Linux、Windows）。</li><li><strong>非循环图目录</strong>：允许文件或目录被多个父目录引用（如硬链接 / 软链接）。</li></ul><p><strong>2. 文件路径</strong></p><ul><li><strong>绝对路径</strong>：从根目录开始（如<code>/home/user/file.txt</code>）。</li><li><strong>相对路径</strong>：从当前目录开始（如<code>./doc/report.pdf</code>）。</li></ul><p><strong>3. 硬链接与软链接</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>原理</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>硬链接</strong></td><td>多个文件名指向同一 inode，共享数据块</td><td>不可跨分区，删除原文件不影响链接，链接计数需减至 0 才真正删除。</td></tr><tr><td><strong>软链接</strong></td><td>类似快捷方式，存储原文件路径</td><td>可跨分区，原文件删除后链接失效，访问需解析路径（可能增加 I/O 开销）。</td></tr></tbody></table><h4 id="文件系统类型与核心机制" tabindex="-1"><a class="header-anchor" href="#文件系统类型与核心机制"><span><strong>文件系统类型与核心机制</strong></span></a></h4><p><strong>1. 常见文件系统</strong></p><table><thead><tr><th><strong>文件系统</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>FAT32</strong></td><td>简单、兼容性强，单个文件≤4GB</td><td>U 盘、嵌入式设备</td></tr><tr><td><strong>NTFS</strong></td><td>支持大文件、加密、压缩、权限控制</td><td>Windows 系统盘</td></tr><tr><td><strong>EXT4</strong></td><td>高性能、日志功能、支持 extent 结构</td><td>Linux 系统盘</td></tr><tr><td><strong>exFAT</strong></td><td>跨平台、支持大文件（&gt;4GB）</td><td>移动硬盘、闪存设备</td></tr></tbody></table><p><strong>2. 索引节点（inode）</strong></p><ul><li><strong>作用</strong>：存储文件元数据（大小、权限、数据块地址等），不包含文件名。</li><li><strong>特点</strong>：每个文件唯一对应一个 inode，文件名存放在目录项中。</li></ul><p><strong>3. 空闲块管理</strong></p><ul><li><strong>位示图</strong>：用二进制位表示磁盘块是否空闲（如 1 表示占用，0 表示空闲）。</li><li><strong>成组链接法</strong>：将空闲块分组管理，兼顾效率与可靠性（如 Linux 的 ext 系列）。</li></ul><h4 id="文件权限与安全" tabindex="-1"><a class="header-anchor" href="#文件权限与安全"><span><strong>文件权限与安全</strong></span></a></h4><p><strong>1. UNIX 权限模型（rwx）</strong></p><ul><li><strong>权限类型</strong>：读（r）、写（w）、执行（x）。</li><li><strong>用户分类</strong>：所有者（u）、所属组（g）、其他用户（o）。</li><li><strong>示例</strong>：<code>rwxr-xr-x</code> 表示所有者可读写执行，组和其他用户可读执行。</li></ul><p><strong>2. 权限设置命令</strong></p><ul><li><strong>chmod</strong>：修改文件权限（如<code>chmod 755 file.txt</code>）。</li><li><strong>umask</strong>：设置新建文件 / 目录的默认权限（如默认<code>umask 022</code>，目录权限 755，文件权限 644）。</li></ul><p><strong>3. 目录权限</strong></p><ul><li><strong>执行权限（x）</strong>：访问目录下的文件或子目录的前提。</li><li><strong>写权限（w）</strong>：允许在目录中创建、删除文件（需同时具备 x 权限）。</li></ul><h4 id="磁盘调度与访问优化" tabindex="-1"><a class="header-anchor" href="#磁盘调度与访问优化"><span><strong>磁盘调度与访问优化</strong></span></a></h4><p><strong>1. 磁盘访问时间</strong></p><ul><li><strong>寻道时间</strong>：磁头移动到目标磁道的时间（占主导）。</li><li><strong>旋转延迟</strong>：目标扇区旋转到磁头下方的时间。</li><li><strong>传输时间</strong>：数据读写时间。</li></ul><p><strong>2. 调度算法</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>策略</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>FCFS</strong></td><td>按请求顺序处理</td><td>公平但延迟高</td></tr><tr><td><strong>SSTF</strong></td><td>优先处理最近磁道请求</td><td>减少寻道时间，可能饥饿</td></tr><tr><td><strong>SCAN（电梯调度）</strong></td><td>磁头单向移动，依次处理请求</td><td>均衡性能，避免饥饿</td></tr><tr><td><strong>CSCAN</strong></td><td>磁头单向移动，到达尽头后跳转至起点继续</td><td>消除 SCAN 的反向延迟</td></tr></tbody></table><h4 id="文件操作与系统调用" tabindex="-1"><a class="header-anchor" href="#文件操作与系统调用"><span><strong>文件操作与系统调用</strong></span></a></h4><p><strong>1. 核心操作流程</strong></p><ul><li>打开文件（open）： <ol><li>检查权限，读取目录项获取 inode。</li><li>将 inode 信息存入内存打开文件表，返回文件描述符。</li></ol></li><li>读取文件（read）： <ol><li>根据文件描述符找到 inode，定位数据块地址。</li><li>从磁盘读取数据到内存缓冲区。</li></ol></li><li>写入文件（write）： <ol><li>分配空闲块，更新 inode 数据块地址。</li><li>将内存数据写入磁盘。</li></ol></li><li>关闭文件（close）： <ol><li>同步缓存数据到磁盘。</li><li>释放内存中的打开文件表项。</li></ol></li></ul><p><strong>2. 系统调用示例</strong></p><table><thead><tr><th><strong>调用</strong></th><th><strong>功能</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td><code>open()</code></td><td>创建或打开文件</td><td>路径、打开模式（如只读、读写）</td></tr><tr><td><code>read()</code></td><td>从文件读取数据</td><td>文件描述符、缓冲区、读取长度</td></tr><tr><td><code>write()</code></td><td>向文件写入数据</td><td>文件描述符、缓冲区、写入长度</td></tr><tr><td><code>lseek()</code></td><td>设置文件偏移量</td><td>文件描述符、偏移量、起始位置（如开头、当前位置）</td></tr></tbody></table><h3 id="存储管理" tabindex="-1"><a class="header-anchor" href="#存储管理"><span>存储管理</span></a></h3><h4 id="存储管理基础" tabindex="-1"><a class="header-anchor" href="#存储管理基础"><span><strong>存储管理基础</strong></span></a></h4><p><strong>1. 内存管理目标</strong></p><ul><li><strong>高效利用内存</strong>：减少碎片（内部 / 外部），提升资源利用率。</li><li><strong>进程隔离</strong>：确保进程只能访问自己的内存空间（如基址寄存器 + 界限寄存器保护）。</li><li><strong>虚拟内存扩展</strong>：通过硬盘模拟更大内存空间，支持大程序运行。</li><li><strong>快速访问</strong>：通过 TLB（快表）加速地址转换。</li></ul><p><strong>2. 地址重定位</strong></p><ul><li><strong>静态重定位</strong>：程序装入时一次性完成逻辑地址到物理地址的转换（无需硬件支持）。</li><li><strong>动态重定位</strong>：程序运行时由 MMU（内存管理单元）动态转换地址（需基址寄存器支持）。</li></ul><p><strong>3. 内存保护机制</strong></p><ul><li>基址寄存器 + 界限寄存器： <ul><li>基址寄存器存储进程起始物理地址，界限寄存器存储最大逻辑地址。</li><li>访问地址需满足：基址 ≤ 物理地址 &lt; 基址 + 界限，否则触发越界中断。</li></ul></li></ul><h4 id="内存分配方式" tabindex="-1"><a class="header-anchor" href="#内存分配方式"><span><strong>内存分配方式</strong></span></a></h4><p><strong>1. 连续分配</strong></p><ul><li><strong>单一连续分配</strong>：内存分为系统区和用户区，仅支持单进程（如早期 DOS）。 <ul><li><strong>优点</strong>：实现简单，无外部碎片。</li><li><strong>缺点</strong>：内存利用率低，多进程支持差。</li></ul></li><li><strong>固定分区分配</strong>：将内存划分为大小固定的分区，每个分区装入一个进程。 <ul><li><strong>优点</strong>：支持多进程，无外部碎片。</li><li><strong>缺点</strong>：内部碎片严重（分区大小与进程不匹配）。</li></ul></li><li><strong>动态分区分配</strong>：根据进程需求动态划分内存（如首次适应、最佳适应算法）。 <ul><li><strong>优点</strong>：按需分配，减少内部碎片。</li><li><strong>缺点</strong>：易产生外部碎片，需合并空闲块。</li></ul></li></ul><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>首次适应</strong></td><td>从低地址开始查找第一个足够大的空闲块</td><td>简单，保留高地址大空闲块；低地址碎片多，查找时间长。</td></tr><tr><td><strong>最佳适应</strong></td><td>选择与需求最接近的空闲块</td><td>减少大材小用；产生大量难以利用的微小碎片。</td></tr><tr><td><strong>最坏适应</strong></td><td>选择最大的空闲块分配</td><td>减少碎片，但大内存块快速被分割。</td></tr></tbody></table><h4 id="虚拟内存技术" tabindex="-1"><a class="header-anchor" href="#虚拟内存技术"><span><strong>虚拟内存技术</strong></span></a></h4><p><strong>1. 分页存储管理</strong></p><ul><li><strong>原理</strong>：将程序与内存划分为固定大小的页（如 4KB），页表记录页号与物理页框的映射关系。</li><li><strong>逻辑地址</strong>：页号 + 页内偏移（如 32 位地址：10 位页号 + 22 位页内偏移）。</li><li><strong>物理地址</strong>：页框号 + 页内偏移。</li><li><strong>优点</strong>：无外部碎片，支持离散存储。</li><li><strong>缺点</strong>：页表占用内存（多级页表可解决），可能产生抖动。</li></ul><p><strong>2. 分段存储管理</strong></p><ul><li><strong>原理</strong>：按程序逻辑分段（如代码段、数据段），段表记录段基址与段长。</li><li><strong>逻辑地址</strong>：段号 + 段内偏移。</li><li><strong>优点</strong>：支持逻辑模块化，方便共享与保护。</li><li><strong>缺点</strong>：易产生外部碎片，内存利用率低。</li></ul><p><strong>3. 段页式存储管理</strong></p><ul><li><strong>原理</strong>：先分段，再分页（如 Linux 内核）。</li><li><strong>逻辑地址</strong>：段号 + 段内页号 + 页内偏移。</li><li><strong>优点</strong>：结合分段与分页的优势，空间浪费小。</li><li><strong>缺点</strong>：地址转换需三次内存访问（段表→页表→物理地址），开销较大。</li></ul><table><thead><tr><th><strong>类型</strong></th><th><strong>地址结构</strong></th><th><strong>碎片问题</strong></th><th><strong>共享支持</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>分页</strong></td><td>页号 + 页内偏移</td><td>无外部碎片</td><td>差</td><td>通用操作系统（如 Windows）</td></tr><tr><td><strong>分段</strong></td><td>段号 + 段内偏移</td><td>外部碎片</td><td>好</td><td>模块化程序设计</td></tr><tr><td><strong>段页式</strong></td><td>段号 + 段内页号 + 页内偏移</td><td>无外部碎片</td><td>好</td><td>大型系统（如 UNIX）</td></tr></tbody></table><h4 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法"><span><strong>页面置换算法</strong></span></a></h4><p><strong>1. 算法目标</strong></p><ul><li>减少缺页中断次数，提升内存访问效率。</li><li>依据程序局部性原理（时间局部性、空间局部性）预测未来访问模式。</li></ul><p><strong>2. 常见算法对比</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>缺页率</strong></th></tr></thead><tbody><tr><td><strong>FIFO</strong></td><td>淘汰最早进入内存的页面</td><td>实现简单</td><td>可能产生 “抖动”（Belady 现象）</td><td>高</td></tr><tr><td><strong>LRU</strong></td><td>淘汰最近最久未使用的页面</td><td>缺页率低，接近 OPT</td><td>需维护访问时间戳，硬件开销大</td><td>低</td></tr><tr><td><strong>OPT</strong></td><td>淘汰未来最长时间不访问的页面（理论最优）</td><td>缺页率最低</td><td>无法实现（需预知未来访问序列）</td><td>最低</td></tr><tr><td><strong>Clock</strong></td><td>维护环形链表，淘汰未被访问的页面（二次机会算法优化）</td><td>开销低，接近 LRU</td><td>性能略逊于 LRU</td><td>中</td></tr></tbody></table><p><strong>3. 示例：页面访问序列 1→2→3→4→1→2→5→1→2→3→4→5（内存容量 3 页）</strong></p><ul><li><strong>FIFO</strong>：缺页 9 次（1→2→3→4→1→2→5→3→4→5）。</li><li><strong>LRU</strong>：缺页 7 次（1→2→3→4→1→2→5→1→2→3→4→5）。</li></ul><h4 id="内存优化与扩展" tabindex="-1"><a class="header-anchor" href="#内存优化与扩展"><span><strong>内存优化与扩展</strong></span></a></h4><p><strong>1. 多级页表</strong></p><ul><li><strong>原理</strong>：将页表分页存储（如二级页表），仅加载当前需要的页表项到内存。</li><li><strong>优点</strong>：减少页表占用内存（如 32 位系统单级页表需 4MB，二级页表仅需 KB 级）。</li><li><strong>缺点</strong>：地址转换需多次内存访问（通过 TLB 缓解）。</li></ul><p><strong>2. 快表（TLB）</strong></p><ul><li><strong>作用</strong>：缓存最近使用的页表项，加速地址转换（命中率高达 90% 以上）。</li><li><strong>机制</strong>：CPU 先查 TLB，未命中则查内存页表，并将结果存入 TLB。</li></ul><p><strong>3. 内存抖动（颠簸）</strong></p><ul><li><strong>定义</strong>：频繁的页面换入换出导致系统性能急剧下降。</li><li><strong>原因</strong>：内存分配不足或置换算法不当（如 FIFO 未考虑局部性）。</li><li><strong>解决</strong>：增加物理内存、优化置换算法（如使用 LRU）、调整进程优先级。</li></ul><h4 id="内存分配策略与安全" tabindex="-1"><a class="header-anchor" href="#内存分配策略与安全"><span><strong>内存分配策略与安全</strong></span></a></h4><p><strong>1. 空闲块管理</strong></p><ul><li><strong>位示图</strong>：用二进制位表示磁盘块是否空闲（如 1 表示占用，0 表示空闲）。</li><li><strong>成组链接法</strong>：将空闲块分组管理，兼顾效率与可靠性（如 Linux 的 ext 系列）。</li></ul><p><strong>2. 内存安全机制</strong></p><ul><li><strong>访问权限控制</strong>：通过页表项或段表项标记读写、执行权限（如 X86 的 PTE 标志位）。</li><li><strong>地址空间随机化</strong>：随机化进程内存布局，防止缓冲区溢出攻击。</li></ul><h3 id="设备管理" tabindex="-1"><a class="header-anchor" href="#设备管理"><span>设备管理</span></a></h3><h4 id="设备管理基础" tabindex="-1"><a class="header-anchor" href="#设备管理基础"><span><strong>设备管理基础</strong></span></a></h4><p><strong>1. 设备分类</strong></p><table><thead><tr><th><strong>分类标准</strong></th><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>传输速率</strong></td><td>低速设备</td><td>每秒传输字节数≤1KB（需 CPU 频繁干预）</td><td>键盘、鼠标</td></tr><tr><td></td><td>中速设备</td><td>每秒传输 KB~MB 级（中断驱动为主）</td><td>打印机、扫描仪</td></tr><tr><td></td><td>高速设备</td><td>每秒传输 MB 级以上（DMA / 通道控制）</td><td>磁盘、网卡</td></tr><tr><td><strong>功能</strong></td><td>存储设备</td><td>存储数据（非易失性）</td><td>硬盘、U 盘</td></tr><tr><td></td><td>输入 / 输出设备</td><td>实现人机交互或数据传输</td><td>显示器、声卡</td></tr><tr><td><strong>共享属性</strong></td><td>独占设备</td><td>同一时刻仅允许一个进程使用（需互斥）</td><td>打印机、磁带机</td></tr><tr><td></td><td>共享设备</td><td>多个进程可交替使用（分时复用）</td><td>磁盘、网卡</td></tr><tr><td></td><td>虚拟设备</td><td>通过 SPOOLing 技术将独占设备虚拟为共享设备（如虚拟打印机）</td><td>虚拟串口、虚拟光驱</td></tr></tbody></table><p><strong>2. 设备管理目标</strong></p><ul><li><strong>高效利用</strong>：减少 CPU 等待时间（如 DMA 技术），提升 I/O 吞吐量。</li><li><strong>透明访问</strong>：实现设备独立性（用户通过逻辑设备名访问，屏蔽物理差异）。</li><li><strong>安全可靠</strong>：控制设备访问权限，处理设备故障（如错误重试、设备切换）。</li></ul><h4 id="i-o-控制方式" tabindex="-1"><a class="header-anchor" href="#i-o-控制方式"><span><strong>I/O 控制方式</strong></span></a></h4><p><strong>1. 程序查询方式</strong></p><ul><li><strong>原理</strong>：CPU 不断轮询设备状态寄存器，直到设备准备好数据。</li><li>流程： <ol><li>发送 I/O 请求，CPU 进入循环查询状态。</li><li>设备完成操作后设置状态为 “就绪”，CPU 读取数据。</li></ol></li><li><strong>优点</strong>：实现简单，无需硬件支持。</li><li><strong>缺点</strong>：CPU 利用率极低（忙等），仅适用于低速设备。</li></ul><p><strong>2. 中断驱动方式</strong></p><ul><li><strong>原理</strong>：设备完成操作后主动向 CPU 发送中断信号，CPU 暂停当前任务处理 I/O。</li><li>流程： <ol><li>发送 I/O 请求，CPU 继续执行其他任务。</li><li>设备完成后触发中断，CPU 执行中断处理程序（如读取数据）。</li></ol></li><li><strong>优点</strong>：CPU 无需忙等，利用率提升。</li><li><strong>缺点</strong>：一次中断处理一次数据（如单个字节），高频中断增加 CPU 开销（适用于中速设备）。</li></ul><p><strong>3. DMA（直接内存访问）方式</strong></p><ul><li><p><strong>原理</strong>：通过 DMA 控制器（DMAC）直接控制内存与设备的数据传输，无需 CPU 干预。</p></li><li><p>流程</p><p>：</p><ol><li>CPU 发送 DMA 请求，配置传输参数（地址、长度）。</li><li>DMAC 负责数据读写，完成后触发中断通知 CPU。</li></ol></li><li><p><strong>优点</strong>：支持批量数据传输（如磁盘块），大幅减少 CPU 干预。</p></li><li><p><strong>缺点</strong>：需专用硬件（DMAC），适用于高速设备（如硬盘、网卡）。</p></li></ul><p><strong>4. 通道方式（高级 DMA）</strong></p><ul><li><strong>原理</strong>：独立的通道处理器（CHP）控制多台设备的 I/O，支持复杂 I/O 逻辑（如协议转换）。</li><li><strong>优点</strong>：CPU 仅需发送通道程序指令，通道自行管理多设备并发。</li><li><strong>适用场景</strong>：大型主机系统（如 IBM 大型机），处理高速、多设备并发 I/O。</li></ul><table><thead><tr><th><strong>控制方式</strong></th><th><strong>CPU 干预程度</strong></th><th><strong>数据传输单位</strong></th><th><strong>中断频率</strong></th><th><strong>典型设备</strong></th></tr></thead><tbody><tr><td>程序查询</td><td>高（忙等）</td><td>单个字节 / 字符</td><td>无</td><td>键盘、传感器</td></tr><tr><td>中断驱动</td><td>中（响应中断）</td><td>单个字节 / 字符</td><td>高</td><td>打印机、扫描仪</td></tr><tr><td>DMA</td><td>低（初始化后释放）</td><td>数据块（如扇区）</td><td>低（一次传输一整块）</td><td>磁盘、U 盘</td></tr><tr><td>通道</td><td>极低（仅发指令）</td><td>多数据块 / 流</td><td>极低</td><td>高速外设集群</td></tr></tbody></table><h4 id="设备驱动程序与中断处理" tabindex="-1"><a class="header-anchor" href="#设备驱动程序与中断处理"><span><strong>设备驱动程序与中断处理</strong></span></a></h4><p><strong>1. 设备驱动程序（Driver）</strong></p><ul><li><strong>作用</strong>：屏蔽硬件细节，为操作系统和应用程序提供统一接口（如<code>read()</code>/<code>write()</code>）。</li><li>功能： <ul><li>初始化设备（如显卡自检）。</li><li>处理设备打开 / 关闭请求（如挂载 U 盘）。</li><li>数据传输（将用户数据转换为设备特定格式）。</li><li>错误处理（如磁盘扇区坏块重试）。</li></ul></li></ul><p><strong>2. 中断处理流程</strong></p><ol><li><strong>中断响应</strong>：CPU 检测到中断信号，暂停当前程序，保存现场（寄存器值、程序计数器）。</li><li><strong>中断识别</strong>：通过中断向量表（IVT）找到对应中断处理程序（如键盘中断号 0x09）。</li><li><strong>中断处理</strong>：执行驱动程序的中断服务例程（ISR），如读取设备数据到缓冲区。</li><li><strong>中断返回</strong>：恢复现场，继续执行被中断的程序。</li></ol><p><strong>3. 中断类型</strong></p><ul><li><strong>硬件中断</strong>：由设备触发（如 I/O 完成、时钟中断），分为可屏蔽中断（如打印机中断）和不可屏蔽中断（如电源故障）。</li><li><strong>软件中断</strong>：由程序指令触发（如系统调用<code>int 80h</code>），用于请求操作系统服务。</li></ul><h4 id="四、磁盘调度算法-核心考点" tabindex="-1"><a class="header-anchor" href="#四、磁盘调度算法-核心考点"><span><strong>四、磁盘调度算法（核心考点）</strong></span></a></h4><p><strong>1. 磁盘结构与访问时间</strong></p><ul><li><strong>寻道时间</strong>：磁头移动到目标磁道的时间（占总时间 60%~80%）。</li><li><strong>旋转延迟</strong>：目标扇区旋转到磁头下方的时间（平均为磁盘转速的 1/2，如 5400 转 / 分硬盘平均旋转延迟≈5.56ms）。</li><li><strong>传输时间</strong>：数据读写时间（与转速和扇区大小相关）。</li></ul><p><strong>2. 调度算法对比</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>核心策略</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>平均寻道时间</strong></th><th><strong>是否饥饿</strong></th></tr></thead><tbody><tr><td><strong>FCFS（先来先服务）</strong></td><td>按请求顺序处理磁道访问（如 100→10→22→…）</td><td>公平，实现简单</td><td>寻道时间波动大（如从 100 到 10 再到 22）</td><td>高</td><td>否</td></tr><tr><td><strong>SSTF（最短寻道时间优先）</strong></td><td>优先处理与当前磁头位置最近的磁道（如当前 100，选 102 而非 10）</td><td>大幅减少寻道时间</td><td>可能导致某些磁道长期无法访问（饥饿）</td><td>中</td><td>是（可能）</td></tr><tr><td><strong>SCAN（电梯调度）</strong></td><td>磁头单向移动（如从内到外），处理所有请求后反向，重复（类似电梯运行）</td><td>均衡内外磁道访问，避免饥饿</td><td>边缘磁道访问频率低（如最内 / 外磁道）</td><td>低</td><td>否</td></tr><tr><td><strong>CSCAN（循环扫描）</strong></td><td>磁头单向移动，到达终点后立即跳转至起点，不处理反向请求（仅正向扫描）</td><td>确保各磁道访问频率均衡</td><td>寻道时间略高于 SCAN</td><td>低</td><td>否</td></tr><tr><td><strong>N-Step SCAN</strong></td><td>将请求队列分为多个子队列，每个子队列执行 SCAN（避免 SSTF 的 “粘着” 现象）</td><td>减少磁头频繁切换方向</td><td>实现稍复杂</td><td>中</td><td>否</td></tr></tbody></table><p><strong>示例</strong>：</p><ul><li>磁头初始位置 100，请求序列：10, 22, 20, 2, 40, 6, 38</li><li><strong>FCFS 寻道顺序</strong>：100→10→22→20→2→40→6→38，总寻道长度 = (90)+(12)+(2)+(18)+(38)+(34)+(32) = 226</li><li><strong>SSTF 寻道顺序</strong>：100→102（假设附近有请求）→ 实际应为最近的 102？ 更正：示例中最近为 22（100→22→20→10→6→2→38→40），总寻道长度 = 78+2+10+4+4+36+2 = 136</li></ul><h4 id="五、缓冲区管理与-spooling-技术" tabindex="-1"><a class="header-anchor" href="#五、缓冲区管理与-spooling-技术"><span><strong>五、缓冲区管理与 SPOOLing 技术</strong></span></a></h4><p><strong>1. 缓冲区类型</strong></p><ul><li><strong>单缓冲</strong>：CPU 与设备共享一个缓冲区（如打印机缓冲区），轮流使用，效率低。</li><li><strong>双缓冲</strong>：两个缓冲区交替使用（如 A 区写入时 B 区读取），提升 CPU 与设备并行度。</li><li><strong>循环缓冲</strong>：多个缓冲区组成环形队列，适用于连续数据传输（如视频流）。</li><li><strong>缓冲池</strong>：共享多个缓冲区，动态分配给不同设备（如 Linux 的页缓存），提高利用率。</li></ul><p><strong>2. SPOOLing（假脱机技术）</strong></p><ul><li><strong>作用</strong>：将独占设备（如打印机）虚拟为共享设备，实现多进程并发使用。</li><li>核心原理： <ol><li><strong>输入井 / 输出井</strong>：用磁盘空间模拟设备缓冲区（如打印队列）。</li><li><strong>输入进程 / 输出进程</strong>：分别负责将数据从输入设备写入输入井，或将输出井数据发送到输出设备。</li></ol></li><li>优点： <ul><li>减少进程等待时间（数据先存入磁盘，再由 SPOOLing 进程处理）。</li><li>实现设备无关性（用户程序只访问逻辑设备名）。</li></ul></li></ul><h4 id="六、设备分配与独立性" tabindex="-1"><a class="header-anchor" href="#六、设备分配与独立性"><span><strong>六、设备分配与独立性</strong></span></a></h4><p><strong>1. 设备分配策略</strong></p><ul><li><strong>静态分配</strong>：进程启动时一次性分配所需所有设备，运行结束后释放（适用于独占设备，如磁带机）。 <ul><li><strong>优点</strong>：无死锁风险。</li><li><strong>缺点</strong>：设备利用率低（进程可能长期占用设备但不使用）。</li></ul></li><li><strong>动态分配</strong>：进程需要时申请设备，使用完毕后立即释放（适用于共享设备，如磁盘）。 <ul><li><strong>优点</strong>：利用率高。</li><li><strong>缺点</strong>：需处理竞争条件（如死锁，需结合银行家算法）。</li></ul></li></ul><p><strong>2. 设备独立性（逻辑设备 vs 物理设备）</strong></p><ul><li><strong>逻辑设备</strong>：用户程序使用的抽象设备名（如 “打印机 01”）。</li><li><strong>物理设备</strong>：实际硬件设备（如 “HP LaserJet P1108”）。</li><li><strong>映射过程</strong>：操作系统通过设备驱动表将逻辑设备名映射到物理设备的驱动程序入口。</li><li>优点： <ul><li>用户无需关心硬件细节（如更换打印机无需修改程序）。</li><li>方便设备热插拔（如 U 盘插入后自动映射为逻辑设备）。</li></ul></li></ul><h3 id="作业管理" tabindex="-1"><a class="header-anchor" href="#作业管理"><span>作业管理</span></a></h3><h4 id="作业管理基础" tabindex="-1"><a class="header-anchor" href="#作业管理基础"><span><strong>作业管理基础</strong></span></a></h4><p><strong>1. 作业定义</strong></p><ul><li><strong>作业</strong>：用户提交给操作系统执行的一个独立任务，包含 <strong>程序、数据、作业说明书</strong>（描述运行条件，如资源需求、优先级）。</li><li>组成部分： <ul><li><strong>作业控制块（JCB）</strong>：记录作业信息（作业名、状态、资源需求、调度参数等），是作业调度的依据。</li><li><strong>程序段</strong>：执行具体功能的代码（如 C 语言编译程序）。</li><li><strong>数据段</strong>：程序运行所需的输入数据或输出结果。</li></ul></li></ul><p><strong>2. 作业与进程的区别</strong></p><table><thead><tr><th><strong>对比项</strong></th><th><strong>作业</strong></th><th><strong>进程</strong></th></tr></thead><tbody><tr><td><strong>视角</strong></td><td>用户角度（任务整体）</td><td>操作系统角度（程序执行实例）</td></tr><tr><td><strong>生命周期</strong></td><td>从提交到完成（包含等待、执行阶段）</td><td>从创建到终止（动态执行过程）</td></tr><tr><td><strong>包含关系</strong></td><td>一个作业可对应多个进程（如编译作业→编译进程 + 链接进程）</td><td>进程是作业的执行单元</td></tr></tbody></table><h4 id="作业状态与处理流程" tabindex="-1"><a class="header-anchor" href="#作业状态与处理流程"><span><strong>作业状态与处理流程</strong></span></a></h4><p><strong>1. 作业四状态模型</strong></p><table><thead><tr><th><strong>状态</strong></th><th><strong>说明</strong></th><th><strong>转换条件</strong></th></tr></thead><tbody><tr><td><strong>提交态</strong></td><td>作业通过输入设备（如键盘、网络）提交给系统，等待进入后备队列。</td><td>作业提交成功，尚未被调度程序处理。</td></tr><tr><td><strong>后备态</strong></td><td>作业已存入外存（如磁盘）的作业队列，等待调度到内存执行（又称 “收容态”）。</td><td>调度程序将作业从外存读入内存，分配资源，创建进程。</td></tr><tr><td><strong>执行态</strong></td><td>作业被调度到内存，进程正在 CPU 上执行（可能交替运行 / 阻塞）。</td><td>作业获得 CPU 资源，进程处于运行态或就绪态。</td></tr><tr><td><strong>完成态</strong></td><td>作业执行结束，系统回收资源，等待输出结果或用户查看。</td><td>作业的最后一个进程终止，结果写入外存，JCB 被删除。</td></tr></tbody></table><p><strong>2. 批处理系统作业处理流程</strong></p><ol><li><strong>提交</strong>：用户通过 JCL（作业控制语言）或图形界面提交作业（如<code>submit job.prg</code>）。</li><li><strong>调度</strong>：作业调度程序按算法选择后备作业，分配内存和外设（如打印机、磁盘空间）。</li><li><strong>执行</strong>：作业转换为进程集合，进程调度程序负责 CPU 分配（如时间片轮转）。</li><li><strong>终止</strong>：作业执行完毕，输出结果（如打印报表），释放所有资源。</li></ol><h4 id="作业调度算法-核心考点" tabindex="-1"><a class="header-anchor" href="#作业调度算法-核心考点"><span><strong>作业调度算法（核心考点）</strong></span></a></h4><p><strong>1. 调度目标</strong></p><ul><li><strong>公平性</strong>：各作业获得合理的资源分配（如避免短作业长期等待）。</li><li><strong>效率</strong>：提高系统吞吐量（单位时间完成的作业数），减少作业平均等待时间。</li><li><strong>响应时间</strong>：交互式作业需快速响应（但批处理系统更关注吞吐量）。</li></ul><p><strong>2. 常见算法对比</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>关键公式 / 指标</strong></th></tr></thead><tbody><tr><td><strong>FCFS（先来先服务）</strong></td><td>按作业提交顺序调度，先进入后备队列的先执行。</td><td>实现简单，公平性好。</td><td>长作业导致短作业等待（如 “饥饿”）。</td><td>平均周转时间 = 总等待时间 / 作业数</td></tr><tr><td><strong>SJF（短作业优先）</strong></td><td>优先调度预计运行时间最短的作业（可抢占 / 非抢占，批处理常用非抢占）。</td><td>平均周转时间最小。</td><td>需预知作业运行时间（实际难实现）。</td><td>带权周转时间 = 周转时间 / 运行时间</td></tr><tr><td><strong>HRRN（高响应比优先）</strong></td><td>响应比 =（等待时间 + 运行时间）/ 运行时间，优先选择响应比高的作业。</td><td>兼顾公平与效率，避免饥饿。</td><td>每次调度需计算响应比，开销略高。</td><td>响应比 = (等待时间 + 运行时间) / 运行时间</td></tr><tr><td><strong>优先级调度</strong></td><td>按作业优先级（用户指定或系统动态计算）调度，高优先级先执行。</td><td>灵活控制任务优先级（如系统作业优先）。</td><td>低优先级作业可能长期等待（需动态调整优先级）。</td><td>优先级可基于资源需求、提交时间等因素</td></tr></tbody></table><p><strong>3. 示例计算（3 个作业）</strong></p><table><thead><tr><th><strong>作业</strong></th><th>提交时间</th><th>运行时间</th><th><strong>FCFS 周转时间</strong></th><th><strong>SJF 周转时间</strong></th><th><strong>HRRN 响应比（调度时）</strong></th></tr></thead><tbody><tr><td>A</td><td>0</td><td>10</td><td>10</td><td>10</td><td>(0+10)/10 = 1（首次调度）</td></tr><tr><td>B</td><td>1</td><td>1</td><td>10+1-1=10（等待 9 单位）</td><td>10+1=11（A 执行完才开始）</td><td>(9+1)/1=10（调度时等待 9 单位）</td></tr><tr><td>C</td><td>2</td><td>2</td><td>10+1+2-2=11</td><td>10+1+2=13</td><td>(8+2)/2=5（调度时等待 8 单位，B 执行完后）</td></tr></tbody></table><ul><li><strong>FCFS 平均周转时间</strong>：(10+10+11)/3 = 10.33</li><li><strong>SJF 平均周转时间</strong>：(10+11+13)/3 = 11.33（注：此处示例 SJF 应为非抢占，若抢占则结果不同）</li><li><strong>HRRN 选择顺序</strong>：A（响应比 1）→ B（响应比 10）→ C（响应比 5，B 执行完后 C 的等待时间为 8）</li></ul><h4 id="作业控制与用户接口" tabindex="-1"><a class="header-anchor" href="#作业控制与用户接口"><span><strong>作业控制与用户接口</strong></span></a></h4><p><strong>1. 作业控制方式</strong></p><ul><li><p>脱机控制</p><p>：通过 <strong>作业控制语言（JCL）</strong> 提前编写作业执行步骤（如 IBM JCL、UNIX shell 脚本），适用于批处理系统。</p><ul><li>示例：<code>//COMPILE JOB CLASS=A, USER=ADMIN</code>（定义编译作业）。</li></ul></li><li><p>联机控制</p><p>：通过交互式命令实时控制作业（如 Windows 命令提示符、Linux 终端）。</p><ul><li>常用命令：<code>start</code>（启动作业）、<code>pause</code>（暂停）、<code>kill</code>（终止）。</li></ul></li></ul><p><strong>2. 用户接口类型</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>CLI（命令行接口）</strong></td><td>文本交互，需记忆命令语法（如<code>dir</code>查看文件、<code>rm</code>删除文件）。</td><td>DOS 命令行、Linux Shell</td></tr><tr><td><strong>GUI（图形用户界面）</strong></td><td>可视化操作，通过鼠标点击菜单、图标完成任务（如打开文件、创建文件夹）。</td><td>Windows Explorer、macOS Finder</td></tr><tr><td><strong>作业控制语言（JCL）</strong></td><td>批处理专用，定义作业执行流程和资源需求（如分配内存、指定输入文件）。</td><td>IBM OS/360 JCL、批处理脚本</td></tr></tbody></table><p><strong>3. 脱机输入输出（SPOOLing 技术前身）</strong></p><ul><li><strong>原理</strong>：通过外围计算机预先将作业输入到磁盘（输入井），执行时直接从磁盘读取，输出结果暂存磁盘（输出井）后统一打印。</li><li><strong>优点</strong>：减少 CPU 等待输入输出时间，提升批处理效率（早期大型机常用）。</li></ul><h4 id="五、作业调度与进程调度的关系" tabindex="-1"><a class="header-anchor" href="#五、作业调度与进程调度的关系"><span><strong>五、作业调度与进程调度的关系</strong></span></a></h4><table><thead><tr><th><strong>调度层次</strong></th><th><strong>作用</strong></th><th><strong>调度时机</strong></th><th><strong>调度算法</strong></th></tr></thead><tbody><tr><td><strong>作业调度</strong></td><td>从后备队列选择作业进入内存，分配资源（如内存空间、外设）。</td><td>作业提交后或执行完毕时</td><td>FCFS、SJF、HRRN 等</td></tr><tr><td><strong>进程调度</strong></td><td>从就绪队列选择进程占用 CPU，控制 CPU 时间分配。</td><td>时间片用完或进程阻塞时</td><td>时间片轮转、优先级调度等</td></tr></tbody></table><ul><li><strong>核心关联</strong>：作业调度是<strong>高级调度</strong>，决定哪些作业进入内存；进程调度是<strong>低级调度</strong>，决定内存中的进程如何使用 CPU。</li><li><strong>资源分配</strong>：作业调度分配内存和外设等资源，进程调度不分配资源（仅分配 CPU 时间）。</li></ul><h2 id="软件工程基础知识" tabindex="-1"><a class="header-anchor" href="#软件工程基础知识"><span>软件工程基础知识</span></a></h2><h3 id="软件工程概述" tabindex="-1"><a class="header-anchor" href="#软件工程概述"><span>软件工程概述</span></a></h3><p>软件工程基本要素：方法，工具，过程</p><h4 id="软件生存周期" tabindex="-1"><a class="header-anchor" href="#软件生存周期"><span>软件生存周期</span></a></h4><h5 id="可行性分析与项目开发计划" tabindex="-1"><a class="header-anchor" href="#可行性分析与项目开发计划"><span>可行性分析与项目开发计划</span></a></h5><p>这个阶段主要确定软件的开发目标及其可行性  参加人员有用户，项目负责人和系统分析师  该阶段产生的主要文档有可行性分析报告和项目 开发计划，从而确定系统的逻辑模型</p><h5 id="需求分析" tabindex="-1"><a class="header-anchor" href="#需求分析"><span>需求分析</span></a></h5><p>这个阶段确定软件的系统的功能，性能，数据和界面等要求  参加人员有用户，项目负责人和系统分析师。  该阶段产生的主要文档软件需求说明书</p><h5 id="概要设计" tabindex="-1"><a class="header-anchor" href="#概要设计"><span>概要设计</span></a></h5><p>在概要设计阶段，开发人员要把确定的各项功能 需求转换需要的体系结构。概要设计就是设计软件的结构  概要设计概要的参加人员有系统分析师和软件设计师  该阶段主要产生文档有概要设计说明书</p><h5 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计"><span>详细设计</span></a></h5><p>详细设计阶段的主要任务是对每个模块完成的功能进行具体描述，要把功能描述转变为精确的，结构化的过程描述。  详细设计阶段的参加人员有软件设计师和程序员。  该阶段主要产生文档有详细设计文档。</p><h5 id="编码" tabindex="-1"><a class="header-anchor" href="#编码"><span>编码</span></a></h5><p>编码阶段就是把每个模块的控制结构转换成计算机课接受的程序代码。即写成某种特定程序设计语言表示的源程序清单</p><h5 id="测试" tabindex="-1"><a class="header-anchor" href="#测试"><span>测试</span></a></h5><p>测试是保证软件质量的重要手段，其主要方式是在设计测试用例的基础上检查软件的各个组成部分。  测试阶段的参加人员通常是另一部门的软件设计师或系统分析师。  该阶段主要产生文档有软件测试计划，测试用例和软件测试报告。</p><h3 id="软件工具与开发环境" tabindex="-1"><a class="header-anchor" href="#软件工具与开发环境"><span>软件工具与开发环境</span></a></h3><p>有效的项目管理集中在 4P 上：人员，产品，过程，项目。</p><p><strong>软件项目估算方法：成本估算方法</strong></p><ul><li><strong>自顶向下估算</strong>：又称类比估算法，先确定一个总金额，再向下分摊到每一个功能点。</li><li><strong>自底向上估算</strong>：从底层功能点开始估算成本，然后向上累加。</li><li><strong>差别估算法</strong>：与以前的项目相比，找出不同点重新估算，相同点则直接估算。</li><li><strong>专家估算</strong>：聘请专家，凭借其经验对项目整体费用进行估算。</li></ul><p><strong>COCOMO 模型</strong>：常见的软件规模估算方法。常用代码行分析方法作为一种度量估计单位，以代码行数估算每个程序员工作量，再累加得到软件成本。</p><ul><li>模型按详细程度分为三级： <ul><li><strong>基本 COCOMO 模型</strong>：是一个静态单变量模型，它用一个以估算出来的原代码行数为自变量的经验函数计算软件开发工作量。</li><li><strong>中间 COCOMO 模型</strong>：在基本 COCOMO 模型的基础上，再用涉及产品、硬件、人员、项目等方面影响因素调整工作量的估算。</li><li><strong>详细 COCOMO 模型</strong>：包括中间 COCOMO 模型所有特性，但更进一步考虑了软件工程的每一个步骤的影响。</li></ul></li></ul><p><strong>COCOMO II 模型</strong>：COCOMO 模型的升级，也是以软件规模作为成本的主要因素，考虑多个成本驱动因子。该方法包括三个阶段性模型，即应用组装模型，早期设计阶段模型，体系结构阶段模型。</p><p><strong>Putnam 估算模型</strong>：一种动态多变量模型，假设在软件开发的整个生存周期中工作量有特定的分布。</p><h4 id="进度管理" tabindex="-1"><a class="header-anchor" href="#进度管理"><span>进度管理</span></a></h4><p><strong>基本原则</strong>：划分，相互依赖，时间分配，工作量确认，确认责任，明确输出结果，确定里程碑。</p><p><strong>Gantt 图</strong>：又称横道图，横轴表示时间，纵轴表示活动，以时间顺序表示活动，能反应活动间的并行关系，但无法反应活动间的依赖关系，因此也难以清晰的确定关键任务和关键路径。</p><p><strong>PERT 图</strong>：类似前趋图，是有向图，反应活动间的依赖关系，有向边上标注活动的运行时间，但无法反应活动间的并行关系。</p><p><strong>PERT 图关键路径</strong>：</p><ul><li><strong>最早开始时间 ES</strong>：取所有前驱活动最早完成时间 EF 的最大值。</li><li><strong>最早完成时间 EF</strong>：ES + DU（活动本身时间）。</li><li><strong>关键路径（项目总工期）</strong>：项目中耗时最长的线路。</li><li><strong>最晚完成时间 LF</strong>：取后续活动最晚开始时间的最小值。</li><li><strong>最晚开始时间 LS</strong>：LF - DU。</li><li><strong>松弛时间</strong>：LS - ES 或者 LF - EF （即活动最多可以晚几天开始）。</li></ul><p><strong>例</strong>： 关键路径为图中最长的路径即 D-F-H 权值为 48 所以第一空选 C。 FG 的松弛时间为 关键路径 - 包含 FG 的最长路径 （DFH）-（DFG）=48-28=20 所以第二空为 B。</p><h4 id="软件项目的组织" tabindex="-1"><a class="header-anchor" href="#软件项目的组织"><span>软件项目的组织</span></a></h4><p><strong>程序设计小组的组织方式</strong>：</p><ul><li><strong>主程序员制小组</strong>：主程序员全权负责，后援工程师有必要时能替代主程序员，适合大规模项目。</li><li><strong>民主制小组</strong>：也即无主程序员小组，成员之间地位平等，任何决策都是全员参与投票，适合于项目规模小，开发人员少，采用新技术和确定性较小的项目。</li><li><strong>层次式小组</strong>：两个层次，一名组长领导若干个高级程序员，每个高级程序员领导若干个程序员。</li></ul><h3 id="软件开发项目管理" tabindex="-1"><a class="header-anchor" href="#软件开发项目管理"><span>软件开发项目管理</span></a></h3><h3 id="软件质量管理" tabindex="-1"><a class="header-anchor" href="#软件质量管理"><span>软件质量管理</span></a></h3><p>通常将质量理解为用户满意程度，为了使用户满意，有两个必要条件：设计的规格说明书符合用户标准，称为设计质量。程序按照设计规模书所规定的情况正确执行，称为程序质量。  设计质量评审，程序质量评审。</p><table><thead><tr><th>质量特性</th><th>质量子特性</th></tr></thead><tbody><tr><td>功能性</td><td>适合性 准确性 互用性 依从性 安全性</td></tr><tr><td>可靠性</td><td>成熟性 容错性 易恢复性</td></tr><tr><td>易使用性</td><td>易理解性 易学性 易操作性</td></tr><tr><td>效率</td><td>时间特性 资源特性</td></tr><tr><td>可维护性</td><td>易分析性 易改变性 稳定性 易测试性</td></tr><tr><td>可移植性</td><td>适应性 易安装性 一致性 易替换性</td></tr></tbody></table><ul><li>易分析性：与为诊断缺陷或失效原因，或为判定待修改部分所需那里有关的软件属性。</li><li>易改变性：与进行修改、排错、或适应环境变换所需努力有关的软件属性。</li><li>稳定性：与修改造成未预料效果风险有关的软件属性。</li><li>易测试性：为确认经修改软件所需努力有关的软件属性。</li></ul><h4 id="软件容错技术" tabindex="-1"><a class="header-anchor" href="#软件容错技术"><span>软件容错技术</span></a></h4><p>容错就是软件遇到错误的处理能力，实现容错的手段主要是冗余，包括下面四种冗余技术：</p><ul><li><strong>结构冗余</strong>：分为静态（通过表决和比较，少数服从多数）、动态（多重模块待机备份，故障是切换备份机）、混合冗余（二者综合）。</li><li><strong>信息冗余</strong>：为检错和纠错在数据中加上一段额外的信息，例如检验码原理。</li><li><strong>时间冗余</strong>：遇到错误是重复执行，例如回滚，重复执行还有错，则转入错误处理逻辑。</li><li><strong>冗余附加技术</strong>：冗余附加技术是指为实现数据结构，信息和时间冗余技术所需的资源和技术，包括程序，指令，数据，存放和调动它们的空间和通道等</li></ul><h4 id="风险管理" tabindex="-1"><a class="header-anchor" href="#风险管理"><span>风险管理</span></a></h4><p>风险管理两个特性：不确定性（可能发生也可能不发生）、损失（发生会产生恶性后果）。</p><ul><li><strong>项目风险</strong>威胁到项目计划，如果项目风险发生，有可能拖延项目的进度和增加项目的成本，指预算。进度、人员、资源。利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素。</li><li><strong>技术风险</strong>威胁到要开发软件的质量和交付时间，如果技术风险发生，开发工作就变得很困难或者不可能，只设计、实现、接口、验证和维护等方面的潜在问题。此外，规格说明的歧义性，技术的不确定性，技术陈旧以及“前沿”技术也是技术风险因数。</li></ul><p>商业风险威胁到要开发软件的生存能力，包括下面五种：</p><ol><li>市场风险：开发了一个没有人真正需要的优良产品或系统。</li><li>策略风险：开发的产品不在符合公司的整体商业策略。</li><li>销售风险：开发了一个销售部门不知道该如何销售的产品。</li><li>管理风险：由于重点的转移或人员变动而失去了高级管理层的支持。</li><li>预算风险：没有得到预算或人员的保证。</li></ol><p>风险管理过程如下：</p><ol><li>风险识别：识别出项目中已知和可预测的风险，确定风险的来源，产生的条件，描述风险的特征以及哪些项目可以产生风险。形成一个风险列表。</li><li>风险预测：又称为风险估计，从两个方面预测风险，即风险可能发生的概率和风险产生的后果，因此有风险曝光度=风险发生的可能性*风险发生带来的损失。</li><li>风险评估：定义风险参照水准，将识别出来的风险评估分类。</li><li>风险控制：辅助项目组建立处理风险的策略，包括风险避免，风险监控，RMMM计划（风险缓解，监控和管理计划）</li></ol><h4 id="软件度量" tabindex="-1"><a class="header-anchor" href="#软件度量"><span>软件度量</span></a></h4><p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的属性，如可靠度等，只能间接测量。  McCabe算法：又称为环路复杂度，假设有向图中有向边数为M，节点数为N，则此有向图的环路复杂度为M-N+2。</p><h3 id="软件过程管理" tabindex="-1"><a class="header-anchor" href="#软件过程管理"><span>软件过程管理</span></a></h3><h4 id="能力成熟度模型cmm" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型cmm"><span>能力成熟度模型CMM</span></a></h4><p>能力成熟度模型CMM：对软件组织化阶段的描述，随着软件组织地定义、实施，测量、控制和改进其软件过程，软件组织地能力经过这些阶段逐步提高。</p><ol><li>初始级（Initial）：软件过程的特点是杂乱无章，又是甚至很混乱，几乎没有明确定义的步骤，项目的完成全依赖个人的努力和英雄式核心人物的作用。</li><li>可重复级（Repeatable）：建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</li><li>已定义级（Defined）：管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件来发组织地标准软件过程，所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li>已管理级（Managed）：制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织地成员所理解和控制。</li><li>优化级（Optimized）：加强了定量分析，通过来之过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</li></ol><h4 id="能力成熟度模型cmmi" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型cmmi"><span>能力成熟度模型CMMI</span></a></h4><p>能力成熟度模型CMMI：将已有的几个CMM模型结合在一起，使之构造成为“集成模型”。支持多个工程学科和领域的、系统的、一致的过程改进框架，能适应现代工程的特点和需求，能提高过程的质量和工作效率。  阶段式模型：类似于CMM，它关注组织地成熟度，五个成熟度模型如下：</p><ol><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程为以度量和控制。</li><li>优化的：集中于过程改进。</li></ol><h4 id="维护" tabindex="-1"><a class="header-anchor" href="#维护"><span>维护</span></a></h4><p>软件维护是软件设计生存周期中时间最长的阶段。已交付的软件投入正式使用后，便进入软件维护阶段，它可以持续几年甚至十几年。</p><h4 id="软件过程模型" tabindex="-1"><a class="header-anchor" href="#软件过程模型"><span>软件过程模型</span></a></h4><h5 id="统一过程模型-up" tabindex="-1"><a class="header-anchor" href="#统一过程模型-up"><span>统一过程模型（UP）</span></a></h5><p>统一过程模型：是一种“用例和风险驱动，以架构为中心，迭代并且增量”的开发过程。 开发的四个阶段</p><ol><li>起始阶段：项目的初始活动，如确认需求和风险评估等。</li><li>精化阶段：需求分析和架构设计等。</li><li>构建阶段：系统的构建，产生实现模型等。</li><li>移交阶段：软件提交方面的工作，产生软件增量，进行β测试，交付系统等。 UP的每一次迭代都是一次完整的软件开发过程，包括整个软件开发生命周期，有五个核心工作流（需求-分析-设计-实现-测试）。</li></ol><h5 id="瀑布模型" tabindex="-1"><a class="header-anchor" href="#瀑布模型"><span>瀑布模型</span></a></h5><p>结构化方法中的模型，是结构化的开发，开发流程如瀑布一样，一步一步走下去，直到项目完成开发  只适用于需求明确或者二次开发（需求稳定）的项目。</p><h5 id="v模型" tabindex="-1"><a class="header-anchor" href="#v模型"><span>V模型</span></a></h5><p>是瀑布模型的一个变种。特点是增加了多轮测试，并且这些测试贯穿于软件开发的各个阶段。</p><h5 id="原型" tabindex="-1"><a class="header-anchor" href="#原型"><span>原型</span></a></h5><p>快速原型开发，与瀑布模型相反，原型针对需求不明确的情况。</p><h5 id="螺旋模型" tabindex="-1"><a class="header-anchor" href="#螺旋模型"><span>螺旋模型</span></a></h5><p>是多种模型的混合，针对需求不明确的项目，与原型相似，但增加了风险分析（制定计划—风险分析—实施工程—用户评估）。</p><h5 id="增量模型" tabindex="-1"><a class="header-anchor" href="#增量模型"><span>增量模型</span></a></h5><p>首先开发核心功能模块，而后与用户确认，之后再开发次核心功能，即每次开发一部分功能，并与用户需求确认，最终完成项目开发，优先级高的服务最先交付。 增量模型的每一次增量版本都可作为独立操作的作品。</p><h5 id="喷泉模型" tabindex="-1"><a class="header-anchor" href="#喷泉模型"><span>喷泉模型</span></a></h5><p>是一种以用户需求为动力，以对象作为驱动的模型。适用于面向对象的开发方法是开发过程具有迭代性和无间隙性</p><h5 id="基于构建的开发模型" tabindex="-1"><a class="header-anchor" href="#基于构建的开发模型"><span>基于构建的开发模型</span></a></h5><p>利于预先包装的构件来构造应用系统，构件是可以组织内部开发的构件，也可以是商品化成品软件构件。  提点是增强了复用性，在系统开发过程中，会构建一个构件库，供其他系统复用，因此可以提高复用性，节省时间和成本。</p><h5 id="敏捷开发" tabindex="-1"><a class="header-anchor" href="#敏捷开发"><span>敏捷开发</span></a></h5><p>敏捷开发的总体目标是通过“尽可能早，持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷开发使用户能够在开发周期的后期增加或者改变需求。</p><h5 id="自适应开发-asd" tabindex="-1"><a class="header-anchor" href="#自适应开发-asd"><span>自适应开发（ASD）</span></a></h5><p>强调开发方法的适应性。</p><h5 id="水晶方法-crystal" tabindex="-1"><a class="header-anchor" href="#水晶方法-crystal"><span>水晶方法（Crystal）</span></a></h5><p>水晶法认为每一个不同项目都需要一套不同的策略，约定和方法论。</p><h5 id="特性驱动开发" tabindex="-1"><a class="header-anchor" href="#特性驱动开发"><span>特性驱动开发</span></a></h5><p>是一套针对中小型软件开发项目的开发模式，是一个模型驱动的快速迭代开发过程，它强调的是简化，使用，易被开发团队接受，适用于需求经常变动的项目。</p><h5 id="并列争求法-scrum" tabindex="-1"><a class="header-anchor" href="#并列争求法-scrum"><span>并列争求法（Scrum）</span></a></h5><p>并列争求法是一种迭代的增量化过程，其中，把每30天一次的迭代称为一个“冲刺”，并按需求的优先级来实现产品。</p><h5 id="极限编程-xp" tabindex="-1"><a class="header-anchor" href="#极限编程-xp"><span>极限编程（XP）</span></a></h5><p>XP是一种轻量级（敏捷），高效，低风险，柔性，可预测，科学的软件开发方式。  <strong>四大价值观</strong>：沟通，简单性，反馈和勇气。  <strong>五个原则</strong>：快速反馈，简单性假设，逐步修改，提倡更改和优质工作。  12个最佳实践：计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结队编程，集体代码所有制，持续集成，每周工作40小时，现场客户和编码标准</p><h5 id="结对编程" tabindex="-1"><a class="header-anchor" href="#结对编程"><span>结对编程</span></a></h5><p>一个程序员开发，另一个审查代码，能够有效的提高代码的质量。</p><h2 id="系统开发与运行" tabindex="-1"><a class="header-anchor" href="#系统开发与运行"><span>系统开发与运行</span></a></h2><h3 id="系统分析概述" tabindex="-1"><a class="header-anchor" href="#系统分析概述"><span>系统分析概述</span></a></h3><p>系统分析是一种问题的求解技术，它将一个系统分解成各个组成部分，目的是研究各个部分如何工作，交互，以实现其系统目标。  目的和任务：系统分析的主要任务是对现行系统进一步详细调查，将调查中所得到的文档资料集中，对组织内部整体管理状况和信息处理过程进行分析，为系统开发提供所需资料，并提交系统方案说明书。  系统分析的主要步骤:</p><ol><li>认识、理解当前的现实环境，获得当前系统的“物理模型”。</li><li>从当前系统的“物理模型”抽象出当前系统的“逻辑模型”。</li><li>对当前系统的“逻辑模型”进行分析和优化，建立目标系统的“逻辑模型”。</li><li>对目标系统的逻辑模型具体化（物理化），建立目标系统的物理模型。</li></ol><p>系统开发的目的是将现有系统的物理模型转换为目标系统的物理模型。</p><h4 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计"><span>系统设计</span></a></h4><p><strong>抽象</strong></p><p><strong>本质</strong>：聚焦问题核心本质，忽略非本质细节（如具体实现、技术差异），提炼关键特征形成通用模型。 <strong>作用</strong>：简化复杂系统，让设计者专注于 “做什么” 而非 “如何做”（例如将磁盘抽象为文件系统，屏蔽物理存储细节）。</p><p><strong>模块化</strong></p><p><strong>定义</strong>：将系统拆解为<strong>可独立设计、组合、替换的单元（模块）</strong>，每个模块完成特定功能（如用户模块、支付模块）。 <strong>特性</strong>：</p><ul><li><strong>可分解</strong>：按功能 / 逻辑拆分（如 MVC 模式分为模型、视图、控制器）。</li><li><strong>可组合</strong>：通过标准接口灵活组装（如插件式架构新增功能）。</li><li><strong>可替换</strong>：模块实现可独立升级（如更换数据库驱动不影响上层逻辑）。</li></ul><p><strong>信息隐蔽</strong></p><p><strong>核心</strong>：将模块内部细节（算法、数据结构等）<strong>封装隐藏</strong>，仅通过公开接口（如函数、API）对外提供服务（形成 “黑盒”）。 <strong>目的</strong>：减少模块间依赖，修改内部实现不影响外部调用（如文件系统仅暴露<code>read/write</code>接口，隐藏磁盘块分配逻辑）。</p><p><strong>模块独立</strong></p><p><strong>设计目标</strong>：追求<strong>高内聚、低耦合</strong>，是衡量模块质量的核心标准：</p><ul><li><strong>高内聚</strong>：模块内部功能高度相关（一个模块仅完成单一明确任务，如 “用户登录验证” 模块）。</li><li><strong>低耦合</strong>：模块间联系简单（仅通过数据交互，无复杂逻辑依赖，如模块 A 调用模块 B 时仅传递参数，不操作其内部数据）。</li></ul><p><strong>关键</strong>：内聚体现模块 “内部紧密性”，耦合体现模块 “外部依赖性”——<strong>内聚越高越好，耦合越低越好</strong>。</p><h4 id="内聚" tabindex="-1"><a class="header-anchor" href="#内聚"><span>内聚</span></a></h4><p>内聚程度从低到高如下表所示：</p><table><thead><tr><th>内聚分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>偶然内聚</td><td>一个模块内各处理元素之间没有任何联系</td><td>无直接关系</td></tr><tr><td>逻辑内聚</td><td>模块内执行若干个逻辑上相似的功能，通过参数确定改模块完成哪一个功能</td><td>逻辑相似，参数决定</td></tr><tr><td>时间内聚</td><td>把需要同时执行的动作组合在一起形成模块</td><td>同时执行</td></tr><tr><td>过程内聚</td><td>一个模块完成多个任务，这些任务必须按指定的过程执行</td><td>指定的过程顺序</td></tr><tr><td>通信内聚</td><td>模块内所有处理元素都在同一个数据结构上操作，或者各处理使用相同的输入数据或产生相同的输出数据</td><td>相同的数据结构、形同的输入输出</td></tr><tr><td>顺序内聚</td><td>一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一个功能元素的输出就是后一个功能元素的输入</td><td>顺序执行、输入为输出</td></tr><tr><td>功能内聚</td><td>最强的内聚，模块内所有元素共同作用完成一个功能，缺一不可</td><td>共同作用，缺一不可</td></tr></tbody></table><h4 id="耦合" tabindex="-1"><a class="header-anchor" href="#耦合"><span>耦合</span></a></h4><p>耦合程度从低到高如下表所示：</p><table><thead><tr><th>耦合分类</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td>无直接耦合</td><td>两个模块之间没有直接的关系，它们分别从属于不同模块的控制与调用，不传递任何信息</td><td>无直接关系</td></tr><tr><td>数据耦合</td><td>两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递</td><td>传递数据值调用</td></tr><tr><td>标记耦合</td><td>两个模块之间传递的是数据结构</td><td>传递数据结构</td></tr><tr><td>控制耦合</td><td>一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值，有选择的执行模块内的某一功能</td><td>控制变量，选择执行某一功能</td></tr><tr><td>外部耦合</td><td>模块间通过软件之外的环境联合（如I/O将模块耦合到特定的设备，格式，通信协议）时</td><td>软件外部环境</td></tr><tr><td>公共耦合</td><td>通过一个公共数据环境相互作用的那些模块间的耦合</td><td>公共数据结构</td></tr><tr><td>内容耦合</td><td>当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个内部模块时</td><td>模块内部关联</td></tr></tbody></table><h3 id="系统设计-1" tabindex="-1"><a class="header-anchor" href="#系统设计-1"><span>系统设计</span></a></h3><p>系统设计的主要目的是为系统制定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，得出新系统的详细设计方案。</p><p>步骤：概要设计和详细设计</p><p><strong>概要设计基本任务</strong>：</p><ul><li>设计软件系统总体结构</li><li>数据结构及数据库设计</li><li>编写概要设计文档</li><li>评审</li></ul><p><strong>详细设计基本任务</strong>：</p><ul><li>模块内详细算法设计</li><li>模块内数据结构设计</li><li>数据库物理设计</li><li>其他设计（代码、输入输出格式、用户界面）</li><li>编写详细设计文档</li><li>评审</li></ul><h4 id="软件需求" tabindex="-1"><a class="header-anchor" href="#软件需求"><span>软件需求</span></a></h4><p><strong>按需求内容分类</strong>：</p><ul><li><strong>业务需求</strong>：由客户提出的宏观功能需求。</li><li><strong>用户需求</strong>：设计员通过调查，获取每个用户的具体需求。</li><li><strong>系统需求</strong>：整合后的最终需求，包含功能、性能、设计约束三个方面。</li></ul><p><strong>从客户角度分类</strong>：</p><ul><li><strong>基本需求</strong>：需求中明确规定的功能。</li><li><strong>期望需求</strong>：除基本需求外，客户认为应包含的其他功能。</li><li><strong>兴奋需求</strong>：客户未要求的功能需求，可能增加项目开发时间和成本。</li></ul><p><strong>软件需求分类</strong>：</p><ul><li><strong>功能需求</strong>：软件必须完成的基本动作。</li><li><strong>性能需求</strong>：软件或人机交互的静态 / 动态数值需求，如系统响应速度、处理速度等。</li><li><strong>设计约束</strong>：受硬件标准等外部因素的限制。</li><li><strong>属性</strong>：可用性、安全性、可维护性、可移植性。</li><li><strong>外部接口需求</strong>：用户接口、硬件接口、软件接口、通信接口。</li></ul><h3 id="测试基础知识" tabindex="-1"><a class="header-anchor" href="#测试基础知识"><span>测试基础知识</span></a></h3><p>系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。</p><p><strong>测试原则</strong>：</p><ul><li>应尽早并持续进行测试。</li><li>测试工作避免由开发软件的人员或小组承担。</li><li>设计测试方案时，需确定输入数据及预期输出结果。</li><li>测试用例包含有效、合理及不合理、失效的情况。</li><li>检验程序是否完成应做之事，且未做不应做之事。</li><li>严格按测试计划执行。</li><li>妥善保存测试用例和测试计划。</li><li>测试用例可重复使用或追加测试。</li></ul><h4 id="测试阶段" tabindex="-1"><a class="header-anchor" href="#测试阶段"><span>测试阶段</span></a></h4><ul><li><strong>单元测试</strong>：对单个模块进行测试，由程序员依据软件详细说明书，测试模块内部接口、信息和功能。单元测试中，驱动模块（上层）用于调用被测模块（自顶向下测试无需额外编写），桩模块（底层）模拟被测模块调用的子模块。</li><li><strong>集成测试</strong>：将模块组合测试，分为一次性组装（简单、省时、发现错误少，适用于小项目）和增量式组装（能发现更多错误，耗时，可分为自顶向下、自底向上、混合式） 。</li><li><strong>确认测试</strong>：对完成的软件进行功能测试，包括内部确认测试（无用户参与）、Alpha 测试（用户在开发环境测试）、Beta 测试（用户在实际使用中测试）、验收测试（用户依据 SRS 验收项目）。</li><li><strong>系统测试</strong>：对软件进行性能测试，主要包括负载测试（极限情况下的性能指标）、强度测试（低资源情况下）、容量测试（并发测试，最大在线用户数） ，还涉及可靠性等测试，一般采用黑盒测试方法。</li><li><strong>回归测试</strong>：软件修改或变更后，验证修改是否引入新错误。</li><li>动态测试：程序运行时测试，分为： <ul><li><strong>黑盒测试法</strong>：功能性测试，基于功能设计用例，不关注代码结构。</li><li><strong>白盒测试法</strong>：结构性测试，依据代码逻辑设计用例，实现代码覆盖。</li><li><strong>灰盒测试法</strong>：结合黑盒与白盒测试。</li></ul></li><li>静态测试：程序静止时进行，即人工审查代码，分为： <ul><li><strong>桌前检查</strong>：程序员在程序编译后、单元测试前，检查自己编写的程序。</li><li><strong>代码审查</strong>：由程序员和测试人员组成评审小组，通过会议评审程序。</li><li><strong>代码走查</strong>：通过会议审查代码，测试人员提供用例，程序员模拟计算机手动运行用例，检查代码逻辑。</li></ul></li></ul><h4 id="测试策略" tabindex="-1"><a class="header-anchor" href="#测试策略"><span>测试策略</span></a></h4><ul><li><strong>自底向上</strong>：从底层模块开始测试，需编写驱动程序，逐步合并模块完成系统测试，优点是可较早验证底层模块。</li><li><strong>自顶向下</strong>：先测试整个系统，需编写桩程序，逐步向下测试底层模块，优点是可较早验证系统主要控制和判断点。</li><li><strong>三明治</strong>：结合自底向上和自顶向下测试方法，兼具两者优点，但测试工作量大。</li></ul><h4 id="测试用例设计" tabindex="-1"><a class="header-anchor" href="#测试用例设计"><span>测试用例设计</span></a></h4><p><strong>黑盒测试用例</strong>：将程序视为黑盒，仅关注输入输出，设计用例分类如下：</p><ul><li><strong>等价类划分</strong>：将数据按特性归类，从每类中选取数据。设计原则为：先设计用例覆盖未覆盖的有效等价类，直至全部覆盖；再设计用例覆盖未覆盖的无效等价类，直至全部覆盖。</li><li><strong>边界值划分</strong>：选取每类数据的边界值作为测试用例，边界值通常为范围两端值及范围外与之间隔最小的两个值，如年龄范围 0 - 150，边界值为 0、150、1、151。</li></ul><p><strong>白盒测试用例</strong>：依据代码逻辑，设计覆盖代码分支的用例，覆盖级别从低到高分为六种：</p><ol><li><strong>语句覆盖</strong>：执行逻辑代码中的所有语句，覆盖层级最低，执行所有语句不代表覆盖所有条件判断。</li><li><strong>判定覆盖</strong>：覆盖逻辑代码中所有判断语句条件的真假分支。</li><li><strong>条件覆盖</strong>：对代码中每个独立条件的真假分支都进行覆盖，例如对于条件 <code>a&gt;0&amp;&amp;b&lt;0</code>，条件覆盖需对 <code>a&gt;0</code> 和 <code>b&lt;0</code> 各自的真假分支设计测试用例，共 4 个，比判定覆盖层级更高。</li><li><strong>判定 / 条件覆盖</strong>：使判定中每个条件的所有可能取值（真 / 假）至少出现一次，且每个判定本身的结果（真 / 假）也至少出现一次，综合了判定覆盖和条件覆盖。</li><li><strong>条件组合覆盖</strong>：覆盖每个判定条件中所有条件的可能值组合。</li><li><strong>路径覆盖</strong>：覆盖逻辑代码中所有可行路径，覆盖层级最高。</li></ol><h2 id="面向对象技术" tabindex="-1"><a class="header-anchor" href="#面向对象技术"><span>面向对象技术</span></a></h2><h3 id="面向对象基本概念" tabindex="-1"><a class="header-anchor" href="#面向对象基本概念"><span>面向对象基本概念</span></a></h3><p>面向对象分析：是为了确定问题域，理解问题。 包含五个活动：<code>认定对象</code>(按自然存在的实体确定对象)、<code>组织对象</code>(分析对象关系,抽象成类)、<code>对象间的互相作用</code>(描述各对象在应用系统中的关系)、<code>确定对象的操作</code>(操作,如创建增加删除等)、<code>定义对象的内部信息(属性)</code></p><p>面向对象设计：是设计分析模型和实现相应源代码，在目标代码环境中这种源代码可被执行。设计问题域的解决方案。 面向对象程序设计：用面向对象程序设计语言实现设计方案。详见案例分析。 面向对象测试：与普通测试步骤并无不同。可分为四个层次：</p><ol><li><code>算法层</code>(测试类中定义的每个方法，类似单元测试)</li><li><code>类层</code>(测试同一个类中所有方法与属性的互相作用，<code>特有的模块测试</code>)</li><li><code>模板层</code>(测试一组协同工作的类之间的互相作用，类似集成测试)</li><li><code>系统层</code>(类似系统测试)</li></ol><h3 id="uml图" tabindex="-1"><a class="header-anchor" href="#uml图"><span>UML图</span></a></h3><p>UML是统一建模语言，和程序设计语言并无关系。 UML三个要素：UML的基本<strong>构造快</strong>、支配这些构造块如何放置在一起的<strong>规则</strong>和运用与整个语言的一些<strong>公共机制</strong>。 UML的基本构造快包括：<strong>事务</strong>（对模型中最具有代表性的成分的抽象）、<strong>关系</strong>（把事务结合在一起）、<strong>图</strong>（聚集了相关的事务）。 UML中有四种事务：<strong>结构事务</strong>、<strong>行为事务</strong>、<strong>分组事务</strong>、<strong>注释事务</strong>。</p><p>结构事务：模型的静态部分，如<strong>类、接口、用例、构件等</strong>如下图示例： <img src="/assets/59-y9hSpkC8.png" alt="img"></p><h4 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h4><p><img src="/assets/60-CiLiK6D9.png" alt="img"></p><hr><h4 id="关系" tabindex="-1"><a class="header-anchor" href="#关系"><span>关系</span></a></h4><ol><li>依赖：一个事务的语义依赖于另一个事务的语义变化而变化</li><li>关联：是一种结构关系，描述一组链，链是对象之间的连接。分为<strong>组合（强关联）<strong>和</strong>聚合（弱关联）</strong></li><li>泛化：一般/特殊的关系，子类和父类之间的关系。</li><li>实现：一个类元指定了另一个类元保证执行的契约。 <img src="/assets/61-gU8K_lwm.png" alt="img"></li></ol><hr><h4 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h4><p><code>类图：静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</code><img src="/assets/62-CNJUt_sp.png" alt="img"></p><hr><h4 id="对象图" tabindex="-1"><a class="header-anchor" href="#对象图"><span>对象图</span></a></h4><p><code>对象图：静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</code><img src="/assets/63-C2hs4Npk.png" alt="img"></p><hr><h4 id="用例图" tabindex="-1"><a class="header-anchor" href="#用例图"><span>用例图</span></a></h4><p><code>用例图：静态图，展现了一组用例、参与者以及他们之间的关系。</code> 用例图中的参与者是人、硬件或其它系统可以扮演的角色；用例是参与者完成的一系列操作。 用力之间的关系包括：</p><ol><li>包含(include)</li><li>扩展(extend)</li><li>泛化 <img src="/assets/64-D81HV21A.png" alt="img"></li></ol><hr><h4 id="序列图" tabindex="-1"><a class="header-anchor" href="#序列图"><span>序列图</span></a></h4><p>序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。 有<strong>同步消息</strong>（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示）、 <strong>异步消息</strong>（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心箭头表示）、 <strong>返回消息</strong>（由从右到左的虚线箭头表示）三种。 <img src="/assets/65-C8UEHjrl.png" alt="img"></p><hr><h4 id="通信图" tabindex="-1"><a class="header-anchor" href="#通信图"><span>通信图</span></a></h4><p>通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过 <strong>不强调时间顺序，只强调事件之间的通信</strong>，而且也没有固定的画法规则，<strong>和顺序图统称为交互图</strong>。 <img src="/assets/66-N5Nz1Mkt.png" alt="img"></p><hr><h4 id="状态图" tabindex="-1"><a class="header-anchor" href="#状态图"><span>状态图</span></a></h4><p>状态图：<strong>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态</strong>。 转换可以<strong>通过事件触发器出发</strong>，事件触发后相应的监护条件会进行检查。</p><p>状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件， 实心圆点为起点和终点。下图描述的就是一个图书的状态变化： <img src="/assets/67-D4gOsU_7.png" alt="img"></p><hr><h4 id="活动图" tabindex="-1"><a class="header-anchor" href="#活动图"><span>活动图</span></a></h4><p>活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另二个活动的流程。 <code>活动的分叉和汇合线是一条水平粗线。</code> 每个分岔的分支数代表了可同时运行的线程数。 活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。 <img src="/assets/68-B_v9o9Ig.png" alt="img"></p><h4 id="uml图总结" tabindex="-1"><a class="header-anchor" href="#uml图总结"><span>UML图总结</span></a></h4><table><thead><tr><th>图名称</th><th>用途</th><th>类型</th></tr></thead><tbody><tr><td><strong>类图</strong></td><td>静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>对象图</strong></td><td>静态图，展现某一时刻一组对象及他们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计图。</td><td>静态图</td></tr><tr><td><strong>用例图</strong></td><td>静态图，展现了一组用例、参与者以及他们之间的关系。</td><td>静态图</td></tr><tr><td><strong>序列图</strong></td><td>即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</td><td>动态图</td></tr><tr><td><strong>通信图</strong></td><td>不强调时间顺序，只强调事件之间的通信，而且也没有固定的画法规则，和顺序图统称为交互图</td><td>动态图</td></tr><tr><td><strong>状态图</strong></td><td>动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括单状态和组合状态。</td><td>动态图</td></tr><tr><td><strong>活动图</strong></td><td>展现了在系统内从一个活动到另二个活动的流程。</td><td>动态图</td></tr></tbody></table><h3 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h3><h4 id="创建型设计模式" tabindex="-1"><a class="header-anchor" href="#创建型设计模式"><span>创建型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：单抽元件厂</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Singleton 单例模式</strong></td><td>确保一个类仅有一个实例，并提供全局访问点</td><td>唯一实例</td></tr><tr><td><strong>Abstract Factory 抽象工厂模式</strong></td><td>提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类</td><td>抽象接口</td></tr><tr><td><strong>Prototype 原型模式</strong></td><td>通过复制现有原型对象来创建新对象，避免重复初始化操作</td><td>原型实例化，拷贝</td></tr><tr><td><strong>Builder 构建器模式</strong></td><td>将复杂对象的构造与其表示分离，使同样的构建过程可以创建不同对象</td><td>类和构造分离</td></tr><tr><td><strong>Factory Method 工厂方法模式</strong></td><td>定义一个创建对象的接口，但让子类决定实例化哪个类</td><td>子类决定实例化</td></tr></tbody></table><h4 id="结构型设计模式" tabindex="-1"><a class="header-anchor" href="#结构型设计模式"><span>结构型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：外侨组员带配饰</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Facade 外观模式</strong></td><td>为复杂子系统提供一个统一的高层接口，简化调用过程</td><td>对外统一接口</td></tr><tr><td><strong>Bridge 桥接模式</strong></td><td>将抽象部分与其实现部分分离，使它们可以独立变化</td><td>抽象和实现分离</td></tr><tr><td><strong>Composite 组合模式</strong></td><td>将对象组合成树形结构以表示”整体-部分”的层次关系</td><td>整体-部分，树形结构</td></tr><tr><td><strong>Flyweight 享元模式</strong></td><td>通过共享技术来高效地支持大量细粒度对象的重用</td><td>细粒度，共享</td></tr><tr><td><strong>Proxy 代理模式</strong></td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>代理控制</td></tr><tr><td><strong>Adapter 适配器模式</strong></td><td>将一个类的接口转换为另一个接口，使原本不兼容的类可以协同工作</td><td>转换，兼容接口</td></tr><tr><td><strong>Decorator 装饰模式</strong></td><td>动态地给对象添加额外的职责，相比继承更加灵活</td><td>附加职责</td></tr></tbody></table><h4 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式"><span>行为型设计模式</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>速记口诀：观摩对(迭)策，责令解放，戒忘台</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>模式名称</th><th>定义</th><th>记忆关键字</th></tr></thead><tbody><tr><td><strong>Observer 观察者模式</strong></td><td>定义对象间的一对多依赖关系，当一个对象状态改变时自动通知所有依赖对象</td><td>通知、自动更新</td></tr><tr><td><strong>Template Method 模板方法模式</strong></td><td>定义算法框架，允许子类在不改变结构的情况下重写特定步骤</td><td>子类可重写算法步骤</td></tr><tr><td><strong>Iterator 迭代器模式</strong></td><td>提供一种方法顺序访问聚合对象的元素，而不暴露其内部表示</td><td>顺序访问，不暴露内部</td></tr><tr><td><strong>Strategy 策略模式</strong></td><td>定义一系列算法，将每个算法封装在独立的类中，并使它们可以相互替换</td><td>算法替换</td></tr><tr><td><strong>Chain of Responsibility 责任链模式</strong></td><td>将请求沿着处理链传递，直到有对象处理它</td><td>传递请求、职责链接</td></tr><tr><td><strong>Command 命令模式</strong></td><td>将请求封装为对象，支持可撤销操作和请求队列</td><td>日志记录、可撤销</td></tr><tr><td><strong>Interpreter 解释器模式</strong></td><td>定义语言的文法表示，并提供解释器来处理该语法</td><td>解释器，虚拟机</td></tr><tr><td><strong>Visitor 访问者模式</strong></td><td>将作用于对象结构的操作与对象本身分离，便于新增操作</td><td>数据和操作分离</td></tr><tr><td><strong>Mediator 中介者模式</strong></td><td>定义一个中介对象来封装一组对象间的交互，降低耦合度</td><td>不直接引用</td></tr><tr><td><strong>Memento 备忘录模式</strong></td><td>在不破坏封装性的前提下，捕获并保存对象的内部状态以便恢复</td><td>保存，恢复</td></tr><tr><td><strong>State 状态模式</strong></td><td>允许对象在其内部状态改变时改变它的行为</td><td>状态变成类</td></tr></tbody></table><h3 id="面向对象设计原则" tabindex="-1"><a class="header-anchor" href="#面向对象设计原则"><span>面向对象设计原则</span></a></h3><ol><li>单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中</li><li>开闭原则：软件实体应当对扩展开放，对修改关闭</li><li>里氏替换原则：所有引用基类的地方必须能透明的使用其子类的对象</li><li>依赖倒转原则：高层模块不应该依赖低层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>接口隔离原则：客户端不应该依赖那些它不需要的接口</li><li>合成复用原则：优先使用对象组合，而不是继承来达到复用的目的</li><li>迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</li></ol><h2 id="网络与信息安全和病毒防护" tabindex="-1"><a class="header-anchor" href="#网络与信息安全和病毒防护"><span>网络与信息安全和病毒防护</span></a></h2><h3 id="iso-osi-网络体系结构" tabindex="-1"><a class="header-anchor" href="#iso-osi-网络体系结构"><span>ISO/OSI 网络体系结构</span></a></h3><table><thead><tr><th><strong>层次</strong></th><th><strong>功能描述</strong></th><th><strong>典型协议 / 技术</strong></th><th><strong>数据单元</strong></th><th><strong>对应设备</strong></th></tr></thead><tbody><tr><td><strong>7. 应用层</strong></td><td>直接为用户应用程序提供服务（如文件传输、电子邮件、远程登录等）。</td><td>HTTP、FTP、SMTP、POP3、DNS、Telnet、SSH</td><td>消息（Message）</td><td>主机（终端设备）</td></tr><tr><td><strong>6. 表示层</strong></td><td>负责数据格式转换（如加密、压缩、解码），确保不同系统间数据格式兼容。</td><td>SSL/TLS、JPEG、MPEG、ASCII、UTF-8</td><td>数据（Data）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>5. 会话层</strong></td><td>管理主机间的通信会话（建立、维护、终止），如会话同步和错误恢复。</td><td>NFS、RPC、ZIP（会话管理）</td><td>会话数据单元</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>4. 传输层</strong></td><td>实现端到端的可靠（TCP）或不可靠（UDP）数据传输，处理流量控制和错误恢复。</td><td>TCP、UDP、SPX（Novell）</td><td>段（Segment）</td><td>无特定硬件设备（软件实现）</td></tr><tr><td><strong>3. 网络层</strong></td><td>负责网络间的逻辑寻址和路由选择，将数据从一个网络传输到另一个网络。</td><td>IP、ICMP、IGMP、OSPF、BGP</td><td>数据包（Packet）</td><td>路由器（Router）</td></tr><tr><td><strong>2. 数据链路层</strong></td><td>将物理层的比特流封装为帧，实现相邻节点间的可靠传输（错误检测、流量控制）。</td><td>Ethernet、PPP、HDLC、VLAN、802.11（Wi-Fi）</td><td>帧（Frame）</td><td>交换机（Switch）、网桥（Bridge）、网卡（NIC）</td></tr><tr><td><strong>1. 物理层</strong></td><td>定义物理设备的电气、机械特性，传输原始比特流（0/1 信号）。</td><td>IEEE 802.3（以太网）、RJ-45、光纤、同轴电缆</td><td>比特（Bit）</td><td>集线器（Hub）、中继器（Repeater）、网卡（NIC）</td></tr></tbody></table><p>以下是对网络协议、网络安全、加密技术及常见网络诊断命令的优化整理，采用清晰的结构化格式：</p><hr><h3 id="网络协议" tabindex="-1"><a class="header-anchor" href="#网络协议"><span><strong>网络协议</strong></span></a></h3><h4 id="_1-局域网协议" tabindex="-1"><a class="header-anchor" href="#_1-局域网协议"><span><strong>1. 局域网协议</strong></span></a></h4><table><thead><tr><th><strong>协议标准</strong></th><th><strong>速率</strong></th><th><strong>传输介质</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>IEEE 802.3</strong></td><td>10Mbps</td><td>同轴电缆</td><td>标准以太网协议，基础局域网通信。</td></tr><tr><td><strong>IEEE 802.3u</strong></td><td>100Mbps</td><td>双绞线</td><td>快速以太网协议，支持更高带宽。</td></tr><tr><td><strong>IEEE 802.3z</strong></td><td>1Gbps</td><td>光纤/双绞线</td><td>千兆以太网协议，支持光纤或超五类双绞线。</td></tr></tbody></table><hr><h4 id="_2-网络层协议" tabindex="-1"><a class="header-anchor" href="#_2-网络层协议"><span><strong>2. 网络层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>功能</strong></th><th><strong>关键特性</strong></th></tr></thead><tbody><tr><td><strong>IP协议</strong></td><td>负责寻址和路由，将数据包从源传到目标。</td><td><strong>无连接、不可靠</strong>，仅保证尽力传输。</td></tr><tr><td><strong>ICMP协议</strong></td><td>网络诊断与错误报告（如ping命令）。</td><td>属于IP协议的补充，用于检测网络连通性。</td></tr><tr><td><strong>ARP协议</strong></td><td>将IP地址映射为物理地址（MAC）。</td><td><strong>IP → MAC</strong>，用于本地网络通信。</td></tr><tr><td><strong>RARP协议</strong></td><td>将物理地址（MAC）映射为IP地址。</td><td><strong>MAC → IP</strong>，常用于无盘工作站启动。</td></tr></tbody></table><hr><h4 id="_3-传输层协议" tabindex="-1"><a class="header-anchor" href="#_3-传输层协议"><span><strong>3. 传输层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>可靠性</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>TCP协议</strong></td><td><strong>可靠</strong></td><td>面向连接，三次握手建立连接，保证数据有序、无错传输。</td><td>文件传输（FTP）、网页浏览（HTTP）</td></tr><tr><td><strong>UDP协议</strong></td><td><strong>不可靠</strong></td><td>无连接，低延迟，适用于实时性要求高的场景。</td><td>视频通话、在线游戏、DNS查询</td></tr></tbody></table><hr><h4 id="_4-应用层协议" tabindex="-1"><a class="header-anchor" href="#_4-应用层协议"><span><strong>4. 应用层协议</strong></span></a></h4><table><thead><tr><th><strong>协议</strong></th><th><strong>传输协议</strong></th><th><strong>端口</strong></th><th><strong>功能</strong></th><th><strong>可靠性</strong></th></tr></thead><tbody><tr><td><strong>HTTP</strong></td><td>TCP</td><td>80</td><td>超文本传输协议，用于网页浏览。</td><td>可靠</td></tr><tr><td><strong>HTTPS</strong></td><td>TCP</td><td>443</td><td>HTTP + SSL/TLS加密，安全传输。</td><td>可靠</td></tr><tr><td><strong>FTP</strong></td><td>TCP</td><td>21 (控制) <br> 20 (数据)</td><td>文件传输，支持文件上传/下载。</td><td>可靠</td></tr><tr><td><strong>DNS</strong></td><td>UDP</td><td>53</td><td>域名解析，将域名转换为IP地址。</td><td>不可靠</td></tr><tr><td><strong>DHCP</strong></td><td>UDP</td><td>67/68</td><td>动态分配IP地址，客户端/服务器模式，默认租期8天。</td><td>不可靠</td></tr><tr><td><strong>SMTP</strong></td><td>TCP</td><td>25</td><td>邮件发送协议，使用ASCII格式。</td><td>可靠</td></tr><tr><td><strong>POP3</strong></td><td>TCP</td><td>110</td><td>邮件接收协议，从服务器下载邮件。</td><td>可靠</td></tr><tr><td><strong>Telnet</strong></td><td>TCP</td><td>23</td><td>远程登录，明文传输（不安全）。</td><td>可靠</td></tr></tbody></table><hr><h3 id="网络安全" tabindex="-1"><a class="header-anchor" href="#网络安全"><span><strong>网络安全</strong></span></a></h3><h4 id="_1-核心要素" tabindex="-1"><a class="header-anchor" href="#_1-核心要素"><span><strong>1. 核心要素</strong></span></a></h4><ul><li><strong>保密性</strong>：数据仅对授权用户可见。</li><li><strong>完整性</strong>：数据未被篡改。</li><li><strong>可用性</strong>：系统资源可被授权用户随时访问。</li><li><strong>可控性</strong>：对网络行为和资源有控制权。</li><li><strong>不可抵赖性</strong>：操作行为可追溯，不可否认。</li></ul><hr><h4 id="_2-防火墙" tabindex="-1"><a class="header-anchor" href="#_2-防火墙"><span><strong>2. 防火墙</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>层级</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>网络级防火墙</strong></td><td>网络层</td><td>基于包过滤，检查IP、端口、协议等。</td><td><strong>优点</strong>：速度快，透明性高；<br><strong>缺点</strong>：无法检测内部伪装数据。</td></tr><tr><td><strong>应用级防火墙</strong></td><td>应用层</td><td>深度检测数据内容，如代理服务器。</td><td><strong>优点</strong>：安全性高；<br><strong>缺点</strong>：效率低，资源消耗大。</td></tr></tbody></table><p><strong>DMZ（非军事区）</strong>：</p><ul><li>位于内外网之间，存放Web服务器、邮件服务器等对外服务，增强内网安全。</li></ul><hr><h4 id="_3-病毒与木马" tabindex="-1"><a class="header-anchor" href="#_3-病毒与木马"><span><strong>3. 病毒与木马</strong></span></a></h4><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>病毒</strong></td><td>自我复制，破坏数据或系统功能。</td><td>CIH（破坏硬件）、宏病毒（如“美丽沙”）</td></tr><tr><td><strong>木马</strong></td><td>隐藏的后门程序，窃取数据或控制权。</td><td>冰河、特洛伊木马</td></tr><tr><td><strong>蠕虫</strong></td><td>通过网络自主传播，无需用户干预。</td><td>熊猫烧香、冲击波</td></tr></tbody></table><hr><h4 id="_4-网络攻击类型" tabindex="-1"><a class="header-anchor" href="#_4-网络攻击类型"><span><strong>4. 网络攻击类型</strong></span></a></h4><table><thead><tr><th><strong>攻击类型</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>拒绝服务（DoS）</strong></td><td>洪泛网络资源，导致合法用户无法访问。</td><td>SYN Flood、CC攻击</td></tr><tr><td><strong>中间人（MITM）</strong></td><td>窃听或篡改通信数据。</td><td>ARP欺骗、DNS劫持</td></tr><tr><td><strong>重放攻击</strong></td><td>重复发送合法数据包以达到恶意目的。</td><td>窃取认证信息</td></tr><tr><td><strong>SQL注入</strong></td><td>通过输入恶意SQL代码攻击数据库。</td><td>篡改或窃取数据</td></tr><tr><td><strong>XSS</strong></td><td>在网页中注入恶意脚本，攻击用户浏览器。</td><td>盗取Cookie、会话令牌</td></tr></tbody></table><hr><h3 id="加密技术" tabindex="-1"><a class="header-anchor" href="#加密技术"><span><strong>加密技术</strong></span></a></h3><h4 id="_1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-基本概念"><span><strong>1. 基本概念</strong></span></a></h4><ul><li><strong>明文</strong>：原始数据。</li><li><strong>密文</strong>：加密后的数据。</li><li><strong>加密/解密</strong>：通过算法和密钥转换数据。</li><li><strong>对称加密</strong>：加密/解密使用同一密钥。</li><li><strong>非对称加密</strong>：加密/解密使用公钥和私钥。</li></ul><hr><h4 id="_2-对称加密算法" tabindex="-1"><a class="header-anchor" href="#_2-对称加密算法"><span><strong>2. 对称加密算法</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>DES</strong></td><td>56位密钥，速度快，但安全性低。</td><td>历史遗留系统</td></tr><tr><td><strong>3DES</strong></td><td>三重DES，安全性增强，但效率低。</td><td>金融、支付系统</td></tr><tr><td><strong>AES</strong></td><td>128/192/256位密钥，安全性高，效率适中。</td><td>现代加密标准（如SSL/TLS）</td></tr><tr><td><strong>RC-5/IDEA</strong></td><td>可变参数，灵活性高。</td><td>专用加密场景</td></tr></tbody></table><hr><h4 id="_3-非对称加密算法" tabindex="-1"><a class="header-anchor" href="#_3-非对称加密算法"><span><strong>3. 非对称加密算法</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>RSA</strong></td><td>基于大整数分解，密钥长度长（1024/2048位）。</td><td>数字签名、SSL/TLS握手</td></tr><tr><td><strong>ECC</strong></td><td>基于椭圆曲线数学，密钥长度短，安全性高。</td><td>移动设备、物联网</td></tr><tr><td><strong>ElGamal</strong></td><td>基于Diffie-Hellman密钥交换，支持加密和数字签名。</td><td>安全通信协议</td></tr></tbody></table><hr><h3 id="常见网络诊断命令" tabindex="-1"><a class="header-anchor" href="#常见网络诊断命令"><span><strong>常见网络诊断命令</strong></span></a></h3><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th><th><strong>常用参数/示例</strong></th></tr></thead><tbody><tr><td><strong>ping</strong></td><td>检测网络连通性，发送ICMP回显请求。</td><td><code>ping 8.8.8.8</code></td></tr><tr><td><strong>tracert</strong></td><td>跟踪数据包路径，定位网络故障点。</td><td><code>tracert www.google.com</code></td></tr><tr><td><strong>ipconfig</strong></td><td>显示/修改TCP/IP配置（Windows）。</td><td><code>ipconfig /release</code>（释放IP）<br><code>ipconfig /flushdns</code>（清除DNS缓存）</td></tr><tr><td><strong>nslookup</strong></td><td>查询DNS记录，验证域名解析。</td><td><code>nslookup baidu.com</code></td></tr><tr><td><strong>netstat</strong></td><td>显示网络连接、端口状态及路由表。</td><td><code>netstat -ano</code>（查看所有连接）</td></tr></tbody></table><h2 id="数据库技术" tabindex="-1"><a class="header-anchor" href="#数据库技术"><span>数据库技术</span></a></h2><h3 id="数据库基础知识" tabindex="-1"><a class="header-anchor" href="#数据库基础知识"><span>数据库基础知识</span></a></h3><ul><li><strong>数据库</strong>：是指按照一定的结构来存储和管理数据的仓库。</li><li><strong>数据库管理系统（DBMS）</strong>：是用于创建和管理数据库的软件系统。它允许用户定义、创建、维护和控制对数据库的访问。</li><li><strong>数据库系统（DBS）</strong>：由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员（DBA）和用户构成的整体。</li></ul><h4 id="数据库类型" tabindex="-1"><a class="header-anchor" href="#数据库类型"><span>数据库类型</span></a></h4><ol><li><p><strong>关系型数据库（RDBMS）</strong></p><ul><li>使用表格形式存储数据，其中行代表记录，列表示字段。</li><li>支持SQL作为查询语言。</li><li>常见的关系型数据库有MySQL、PostgreSQL、Oracle、Microsoft SQL Server等。</li></ul></li><li><p><strong>非关系型数据库（NoSQL）</strong></p><ul><li>不使用传统的表格形式存储数据，而是采用键值对、文档、列族或图形存储方式。</li><li>更加灵活，适用于大规模分布式系统。</li><li>常见的NoSQL数据库有MongoDB（文档型）、Cassandra（列族型）、Redis（键值对型）、Neo4j（图数据库）等。</li></ul></li></ol><h4 id="数据模型" tabindex="-1"><a class="header-anchor" href="#数据模型"><span>数据模型</span></a></h4><ul><li><strong>层次模型</strong>：早期的数据组织形式，以树状结构表示数据之间的关系。</li><li><strong>网状模型</strong>：比层次模型更复杂，允许一个子节点拥有多个父节点。</li><li><strong>关系模型</strong>：现代最常用的模型，基于数学理论，通过表格的形式展示数据间的联系。</li><li><strong>面向对象模型</strong>：将数据和方法封装在一起，支持复杂的对象结构。</li></ul><h4 id="sql基础" tabindex="-1"><a class="header-anchor" href="#sql基础"><span>SQL基础</span></a></h4><ul><li><strong>数据定义语言（DDL）</strong>：用于定义数据库结构，如<code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>等命令。</li><li><strong>数据操作语言（DML）</strong>：用于添加、更新、删除数据，如<code>INSERT INTO</code>, <code>UPDATE</code>, <code>DELETE FROM</code>等。</li><li><strong>数据查询语言（DQL）</strong>：用于检索数据，主要命令为<code>SELECT</code>。</li><li><strong>数据控制语言（DCL）</strong>：用于权限管理，如<code>GRANT</code>, <code>REVOKE</code>等命令。</li></ul><h4 id="事务管理" tabindex="-1"><a class="header-anchor" href="#事务管理"><span>事务管理</span></a></h4><ul><li><strong>事务</strong>：指作为一个逻辑单元执行的一系列操作，要么全部成功，要么全部失败回滚。</li><li><strong>ACID属性</strong>： <ul><li><strong>原子性（Atomicity）</strong>：事务是不可分割的工作单位，要么都做，要么都不做。</li><li><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态。</li><li><strong>隔离性（Isolation）</strong>：并发事务之间相互不影响。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，它对数据库的影响就是永久性的。</li></ul></li></ul><h3 id="e-r-模型" tabindex="-1"><a class="header-anchor" href="#e-r-模型"><span>E-R 模型</span></a></h3><h4 id="e-r模型-实体-联系模型" tabindex="-1"><a class="header-anchor" href="#e-r模型-实体-联系模型"><span><strong>E-R模型（实体-联系模型）</strong></span></a></h4><h5 id="_1-基本概念-1" tabindex="-1"><a class="header-anchor" href="#_1-基本概念-1"><span><strong>1. 基本概念</strong></span></a></h5><ul><li><strong>定义</strong>：E-R模型是用户视角的数据建模工具，通过实体、属性和联系描述现实世界的信息结构。 <ul><li><strong>实体（Entity）</strong>：现实世界可区分的对象，用<strong>矩形</strong>表示（如学生、课程）。 <ul><li><strong>软考重点</strong>：需明确实体的业务含义，避免遗漏关键实体（如“订单”与“订单详情”）。</li></ul></li><li><strong>属性（Attribute）</strong>：实体的特征，用<strong>椭圆</strong>表示，分为： <ul><li><strong>主属性</strong>（主键）：唯一标识实体（如学号），需用<strong>下划线或加粗</strong>标注。</li><li><strong>次属性</strong>：非唯一属性（如姓名、年龄）。</li><li><strong>软考重点</strong>：主键选择需唯一且最小化，避免多值属性（如“电话”可能为多值需单独表）。</li></ul></li><li><strong>联系（Relationship）</strong>：实体间的关联，用<strong>菱形</strong>表示，分为： <ul><li><strong>一对一（1:1）</strong>：如“身份证号”与“个人”的关系。</li><li><strong>一对多（1:N）</strong>：如“部门”与“员工”的关系。</li><li><strong>多对多（M:N）</strong>：如“学生”与“课程”的选课关系。</li><li><strong>软考重点</strong>：联系类型判断是考试高频考点，需结合业务场景（如“教师授课”是1:N还是N:M）。</li></ul></li></ul></li></ul><hr><h5 id="_2-e-r图设计步骤" tabindex="-1"><a class="header-anchor" href="#_2-e-r图设计步骤"><span><strong>2. E-R图设计步骤</strong></span></a></h5><ol><li><strong>确定实体</strong>：明确系统涉及的对象（如学生、教师、课程）。</li><li><strong>定义属性</strong>：为每个实体列出属性，并标记主属性。 <ul><li><strong>软考重点</strong>：主键需唯一且不可为空，避免冗余属性。</li></ul></li><li><strong>分析联系</strong>：确定实体间的关联类型（1:1、1:N、M:N）。</li><li><strong>转换为关系模式</strong>： <ul><li><strong>一对一（1:1）</strong>：合并到任意一端实体的表中，或单独建表。 <ul><li><strong>软考重点</strong>：若合并需考虑业务需求，考试中常考“如何选择更优方案”。</li></ul></li><li><strong>一对多（1:N）</strong>：在“多”端实体表中添加“一”端的主键作为外键。 <ul><li><strong>软考重点</strong>：外键命名需规范（如<code>DepartmentID</code>作为员工表的外键）。</li></ul></li><li><strong>多对多（M:N）</strong>：创建中间表，包含双方主键作为联合主键（如<code>学生选课表</code>包含学生学号和课程号）。 <ul><li><strong>软考重点</strong>：多对多联系必须转为中间表，否则视为错误设计。</li></ul></li></ul></li></ol><hr><h5 id="_3-转换规则与常见错误" tabindex="-1"><a class="header-anchor" href="#_3-转换规则与常见错误"><span><strong>3. 转换规则与常见错误</strong></span></a></h5><ul><li><strong>多对多联系</strong>：必须转为中间表，联合主键需包含双方主键。</li><li><strong>三个实体的联系</strong>：需拆分为两个二元联系，分别建表。</li><li><strong>软考重点</strong>：考试中常出现“三元联系”转换错误，需拆分后设计中间表。</li></ul><hr><h4 id="综合示例与考点解析" tabindex="-1"><a class="header-anchor" href="#综合示例与考点解析"><span><strong>综合示例与考点解析</strong></span></a></h4><p><strong>题目</strong>：<br> 设计学生选课系统的E-R图，并转换为关系模式。<br><strong>解答步骤</strong>：</p><ol><li><strong>E-R图设计</strong>： <ul><li>实体：学生（学号（主键），姓名，年龄）、课程（课程号（主键），课程名，学分）。</li><li>联系：选课（学号，课程号，成绩）。</li><li><strong>考点</strong>：需正确标注主键（学号、课程号），联系类型为M:N。</li></ul></li><li><strong>关系模式转换</strong>： <ul><li><strong>学生表</strong>：<code>Student(Sno, Sname, Sage)</code>（主键：Sno）。</li><li><strong>课程表</strong>：<code>Course(Cno, Cname, Credit)</code>（主键：Cno）。</li><li><strong>选课表</strong>：<code>SC(Sno, Cno, Grade)</code>（主键：(Sno, Cno)，外键：Sno→Student.Sno，Cno→Course.Cno）。</li><li><strong>考点</strong>：中间表需包含双方主键作为联合主键，外键命名规范。</li></ul></li></ol><hr><h4 id="关键考点总结" tabindex="-1"><a class="header-anchor" href="#关键考点总结"><span><strong>关键考点总结</strong></span></a></h4><p><strong>E-R模型</strong>：</p><ul><li>E-R图绘制：实体、属性、联系的正确标注及类型判断。</li><li>多对多联系转中间表，避免遗漏。</li><li>主键与外键的规范设置。</li></ul><h3 id="sql-语言" tabindex="-1"><a class="header-anchor" href="#sql-语言"><span>SQL 语言</span></a></h3><h4 id="基础查询-select" tabindex="-1"><a class="header-anchor" href="#基础查询-select"><span><strong>基础查询（SELECT）</strong></span></a></h4><p><strong>作用</strong>：从数据库中检索数据。 <strong>基本语法</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列名1, 列名2, ... </span></span>
<span class="line"><span>FROM 表名 </span></span>
<span class="line"><span>[WHERE 条件] </span></span>
<span class="line"><span>[GROUP BY 分组列] </span></span>
<span class="line"><span>[HAVING 分组条件] </span></span>
<span class="line"><span>[ORDER BY 排序列 ASC/DESC] </span></span>
<span class="line"><span>[LIMIT 分页参数];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-基础用法" tabindex="-1"><a class="header-anchor" href="#_1-基础用法"><span><strong>1. 基础用法</strong></span></a></h5><ul><li><p><strong>查询所有列</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名;  -- 返回表中所有行和列</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT * FROM 学生;</code><strong>考点</strong>：<code>*</code> 表示所有列，但实际应用中需避免滥用以减少数据量。</p></li><li><p><strong>查询指定列</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列1, 列2 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT 学号, 姓名 FROM 学生;</code><strong>考点</strong>：明确指定列可提高查询效率，避免冗余数据。</p></li><li><p><strong>别名（AS）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列 AS 新列名 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT 姓名 AS 学生姓名 FROM 学生;</code><strong>考点</strong>：<code>AS</code> 可省略，但增强可读性（如 <code>SELECT 姓名 学生姓名</code>）。</p></li><li><p><strong>去重（DISTINCT）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT DISTINCT 列 FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT DISTINCT 部门 FROM 员工;</code><strong>考点</strong>：<code>DISTINCT</code> 仅对指定列去重，需与聚合函数区分。</p></li></ul><hr><h4 id="条件查询-where" tabindex="-1"><a class="header-anchor" href="#条件查询-where"><span><strong>条件查询（WHERE）</strong></span></a></h4><p><strong>作用</strong>：筛选满足条件的记录。 <strong>常用运算符</strong>：</p><ul><li><strong>比较运算符</strong>：<code>=</code>、<code>!=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>。</li><li><strong>逻辑运算符</strong>：<code>AND</code>、<code>OR</code>、<code>NOT</code>。</li><li><strong>范围查询</strong>：<code>BETWEEN ... AND ...</code>。</li><li><strong>模糊匹配</strong>：<code>LIKE</code>（结合通配符 <code>%</code> 和 <code>_</code>）。</li></ul><h5 id="_1-单条件与多条件" tabindex="-1"><a class="header-anchor" href="#_1-单条件与多条件"><span><strong>1. 单条件与多条件</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 单条件</span></span>
<span class="line"><span>SELECT * FROM 表名 WHERE 列 = 值;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 多条件</span></span>
<span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列1 = 值1 AND 列2 &gt; 值2 </span></span>
<span class="line"><span>OR 列3 IS NULL;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：</p><ul><li><code>SELECT * FROM 学生 WHERE 年龄 = 20;</code></li><li><code>SELECT * FROM 员工 WHERE 工资 &gt; 10000 AND 部门 = &#39;技术部&#39;;</code></li></ul><hr><h5 id="_2-范围查询-between" tabindex="-1"><a class="header-anchor" href="#_2-范围查询-between"><span><strong>2. 范围查询（BETWEEN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列 BETWEEN 值1 AND 值2;  -- 包含边界值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：<code>SELECT * FROM 学生 WHERE 年龄 BETWEEN 18 AND 22;</code></p><hr><h5 id="_3-模糊查询-like" tabindex="-1"><a class="header-anchor" href="#_3-模糊查询-like"><span><strong>3. 模糊查询（LIKE）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>WHERE 列 LIKE &#39;模式&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>%</code>：匹配任意字符（0个或多个）。</li><li><code>_</code>：匹配单个字符。 <strong>示例</strong>：</li><li><code>SELECT * FROM 学生 WHERE 姓名 LIKE &#39;张%&#39;;</code> -- 查询姓“张”的学生。</li><li><code>SELECT * FROM 商品 WHERE 名称 LIKE &#39;A__&#39;;</code> -- 查询以“A”开头且长度为3的名称。</li></ul><hr><h4 id="聚合函数与分组-group-by-having" tabindex="-1"><a class="header-anchor" href="#聚合函数与分组-group-by-having"><span><strong>聚合函数与分组（GROUP BY/HAVING）</strong></span></a></h4><p><strong>作用</strong>：对数据进行分组统计。 <strong>常用聚合函数</strong>：</p><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>COUNT(*)</code></td><td>统计总行数</td><td><code>SELECT COUNT(*) FROM 学生</code></td></tr><tr><td><code>SUM(列)</code></td><td>求和</td><td><code>SELECT SUM(销售额) FROM 销售</code></td></tr><tr><td><code>AVG(列)</code></td><td>计算平均值</td><td><code>SELECT AVG(年龄) FROM 学生</code></td></tr><tr><td><code>MAX(列)</code></td><td>取最大值</td><td><code>SELECT MAX(成绩) FROM 考试</code></td></tr><tr><td><code>MIN(列)</code></td><td>取最小值</td><td><code>SELECT MIN(价格) FROM 商品</code></td></tr></tbody></table><h5 id="_1-分组查询-group-by" tabindex="-1"><a class="header-anchor" href="#_1-分组查询-group-by"><span><strong>1. 分组查询（GROUP BY）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 分组列, 聚合函数(列) </span></span>
<span class="line"><span>FROM 表名 </span></span>
<span class="line"><span>GROUP BY 分组列 </span></span>
<span class="line"><span>[HAVING 条件];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例</strong>：</p><ul><li><p>统计各部门平均工资</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 部门, AVG(工资) AS 平均工资 </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>GROUP BY 部门;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>过滤分组结果（HAVING）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 部门, COUNT(*) AS 人数 </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>GROUP BY 部门 </span></span>
<span class="line"><span>HAVING 人数 &gt; 5;  -- 过滤员工数超过5人的部门</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h4 id="连接查询-join" tabindex="-1"><a class="header-anchor" href="#连接查询-join"><span><strong>连接查询（JOIN）</strong></span></a></h4><p><strong>作用</strong>：合并多表数据。 <strong>常见连接类型</strong>：</p><table><thead><tr><th>连接类型</th><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><strong>内连接（INNER JOIN）</strong></td><td><code>ON 条件</code></td><td>返回两个表中满足条件的匹配行。</td></tr><tr><td><strong>左连接（LEFT JOIN）</strong></td><td><code>LEFT JOIN ... ON 条件</code></td><td>返回左表所有行，右表匹配则返回，否则为NULL。</td></tr><tr><td><strong>右连接（RIGHT JOIN）</strong></td><td><code>RIGHT JOIN ... ON 条件</code></td><td>返回右表所有行，左表匹配则返回，否则为NULL。</td></tr><tr><td><strong>全连接（FULL JOIN）</strong></td><td><code>FULL JOIN ... ON 条件</code></td><td>返回两个表所有行，不匹配则对应列为NULL（部分数据库不支持）。</td></tr></tbody></table><h5 id="_1-内连接-inner-join" tabindex="-1"><a class="header-anchor" href="#_1-内连接-inner-join"><span><strong>1. 内连接（INNER JOIN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学生.学号, 课程.课程名, 成绩 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>INNER JOIN 选课 ON 学生.学号 = 选课.学号 </span></span>
<span class="line"><span>INNER JOIN 课程 ON 选课.课程号 = 课程.课程号;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-左连接-left-join" tabindex="-1"><a class="header-anchor" href="#_2-左连接-left-join"><span><strong>2. 左连接（LEFT JOIN）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 表1.列, 表2.列 </span></span>
<span class="line"><span>FROM 表1 </span></span>
<span class="line"><span>LEFT JOIN 表2 </span></span>
<span class="line"><span>ON 表1.关联列 = 表2.关联列;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学生.学号, 学生.姓名, 选课.课程号 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>LEFT JOIN 选课 ON 学生.学号 = 选课.学号;  -- 包含未选课的学生</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="子查询-subquery" tabindex="-1"><a class="header-anchor" href="#子查询-subquery"><span><strong>子查询（Subquery）</strong></span></a></h4><p><strong>作用</strong>：嵌套查询实现复杂条件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 查询选修过课程ID为 &#39;C001&#39; 的学生</span></span>
<span class="line"><span>SELECT 姓名 </span></span>
<span class="line"><span>FROM 学生 </span></span>
<span class="line"><span>WHERE 学号 IN (SELECT 学号 FROM 选课 WHERE 课程ID = &#39;C001&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 查询比平均工资高的员工</span></span>
<span class="line"><span>SELECT * </span></span>
<span class="line"><span>FROM 员工 </span></span>
<span class="line"><span>WHERE 工资 &gt; (SELECT AVG(工资) FROM 员工);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="排序与分页-order-by-limit" tabindex="-1"><a class="header-anchor" href="#排序与分页-order-by-limit"><span><strong>排序与分页（ORDER BY/LIMIT）</strong></span></a></h4><h5 id="_1-排序-order-by" tabindex="-1"><a class="header-anchor" href="#_1-排序-order-by"><span><strong>1. 排序（ORDER BY）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>ORDER BY 列 ASC/DESC;  -- ASC升序（默认），DESC降序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 学生 </span></span>
<span class="line"><span>ORDER BY 年龄 DESC, 姓名 ASC;  -- 先按年龄降序，再按姓名升序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-分页-limit-offset" tabindex="-1"><a class="header-anchor" href="#_2-分页-limit-offset"><span><strong>2. 分页（LIMIT/OFFSET）</strong></span></a></h5><ul><li><p>MySQL/PostgreSQL</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT * FROM 表名 </span></span>
<span class="line"><span>LIMIT 偏移量, 行数;  -- 如 LIMIT 0, 10 表示第1页，每页10条</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>SQL Server</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT TOP 行数 * FROM 表名 </span></span>
<span class="line"><span>WHERE 条件 NOT IN (SELECT TOP 偏移量 * FROM 表名);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h4 id="高级查询技巧" tabindex="-1"><a class="header-anchor" href="#高级查询技巧"><span><strong>高级查询技巧</strong></span></a></h4><h5 id="_1-常见表表达式-cte" tabindex="-1"><a class="header-anchor" href="#_1-常见表表达式-cte"><span><strong>1. 常见表表达式（CTE）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>WITH 临时表名 AS (子查询) </span></span>
<span class="line"><span>SELECT * FROM 临时表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>WITH 高薪员工 AS (</span></span>
<span class="line"><span>  SELECT * FROM 员工 WHERE 工资 &gt; 20000</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span>SELECT 部门, COUNT(*) AS 高薪人数 </span></span>
<span class="line"><span>FROM 高薪员工 </span></span>
<span class="line"><span>GROUP BY 部门;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-窗口函数-window-functions" tabindex="-1"><a class="header-anchor" href="#_2-窗口函数-window-functions"><span><strong>2. 窗口函数（Window Functions）</strong></span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 列, </span></span>
<span class="line"><span>       SUM(列) OVER (PARTITION BY 分组列) AS 累计值 </span></span>
<span class="line"><span>FROM 表名;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>SELECT 学号, 课程号, 成绩, </span></span>
<span class="line"><span>       AVG(成绩) OVER (PARTITION BY 学号) AS 学生平均分 </span></span>
<span class="line"><span>FROM 选课;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-联合查询-union-union-all" tabindex="-1"><a class="header-anchor" href="#_3-联合查询-union-union-all"><span><strong>3. 联合查询（UNION/UNION ALL）</strong></span></a></h5><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 列 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 表1 </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UNION</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [ALL] </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 列 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 表2;  </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 去重，UNION ALL保留所有行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="insert-插入数据" tabindex="-1"><a class="header-anchor" href="#insert-插入数据"><span><strong>INSERT（插入数据）</strong></span></a></h4><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>INSERT INTO 表名 (列1, 列2, ...) </span></span>
<span class="line"><span>VALUES (值1, 值2, ...);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>默认值/NULL</strong>：未指定列时需允许 <code>NULL</code> 或设置默认值。</li><li><strong>批量插入</strong>：<code>INSERT INTO 表A SELECT * FROM 表B</code>。</li></ul></li></ul><hr><h4 id="update-更新数据" tabindex="-1"><a class="header-anchor" href="#update-更新数据"><span>UPDATE（更新数据）</span></a></h4><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>UPDATE 表名 </span></span>
<span class="line"><span>SET 列1 = 新值, 列2 = 新值 </span></span>
<span class="line"><span>WHERE 条件;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>WHERE 条件</strong>：必须明确条件，否则会更新全表。</li><li><strong>自增字段</strong>：若表有自增主键，需谨慎更新以避免冲突。</li></ul></li></ul><hr><h4 id="delete-删除数据" tabindex="-1"><a class="header-anchor" href="#delete-删除数据"><span>DELETE（删除数据）</span></a></h4><ul><li><p>基础语法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>DELETE FROM 表名 </span></span>
<span class="line"><span>WHERE 条件;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点：</p><ul><li><strong>外键约束</strong>：删除主表数据前需先删除从表关联数据，或设置 <code>ON DELETE CASCADE</code>。</li><li><strong>全表删除</strong>：<code>DELETE FROM 表名</code> 删除所有数据，但保留表结构。</li></ul></li></ul><h4 id="字符串与日期函数" tabindex="-1"><a class="header-anchor" href="#字符串与日期函数"><span><strong>字符串与日期函数</strong></span></a></h4><hr><h5 id="字符串函数" tabindex="-1"><a class="header-anchor" href="#字符串函数"><span><strong>字符串函数</strong></span></a></h5><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CONCAT(列1, 列2)</code></td><td>字符串拼接</td><td><code>SELECT CONCAT(姓, 名) AS 全名 FROM 员工</code></td></tr><tr><td><code>SUBSTRING(列, 起始, 长度)</code></td><td>截取子字符串</td><td><code>SELECT SUBSTRING(电话, 4, 4) FROM 客户</code></td></tr><tr><td><code>UPPER(列)</code></td><td>转大写</td><td><code>SELECT UPPER(城市) FROM 订单</code></td></tr><tr><td><code>LOWER(列)</code></td><td>转小写</td><td><code>SELECT LOWER(邮箱) FROM 用户</code></td></tr></tbody></table><hr><h5 id="日期函数" tabindex="-1"><a class="header-anchor" href="#日期函数"><span>** 日期函数**</span></a></h5><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>CURRENT_DATE()</code></td><td>获取当前日期</td><td><code>SELECT CURRENT_DATE()</code></td></tr><tr><td><code>DATE_FORMAT(日期, 格式)</code></td><td>格式化日期</td><td><code>SELECT DATE_FORMAT(出生日期, &#39;%Y-%m-%d&#39;) FROM 学生</code></td></tr><tr><td><code>DATEDIFF(日期1, 日期2)</code></td><td>计算日期差</td><td><code>SELECT DATEDIFF(&#39;2023-01-01&#39;, &#39;2022-01-01&#39;)</code></td></tr></tbody></table><hr><h4 id="四、授权与收回-dcl核心考点" tabindex="-1"><a class="header-anchor" href="#四、授权与收回-dcl核心考点"><span><strong>四、授权与收回（DCL核心考点）</strong></span></a></h4><hr><h5 id="_1-grant-授权" tabindex="-1"><a class="header-anchor" href="#_1-grant-授权"><span><strong>1. GRANT（授权）</strong></span></a></h5><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>GRANT 权限1, 权限2 </span></span>
<span class="line"><span>ON 对象类型.对象名 </span></span>
<span class="line"><span>TO 用户/角色 </span></span>
<span class="line"><span>[WITH GRANT OPTION];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考权限类型</p><ul><li><strong>数据操作权限</strong>：<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>。</li><li><strong>数据定义权限</strong>：<code>CREATE</code>, <code>DROP</code>, <code>ALTER</code>。</li><li><strong>全部权限</strong>：<code>ALL PRIVILEGES</code>。</li></ul></li><li><p>常考考点</p><ul><li><p><strong>列级权限</strong>：<code>GRANT UPDATE(列名) ON 表名 TO 用户</code>。</p></li><li><p><strong>转授权</strong>：<code>WITH GRANT OPTION</code> 允许被授权用户再次授权。</p></li><li><p>对象范围</p><ul><li><code>ON 表名</code>：对指定表授权。</li><li><code>ON *.*</code>：对数据库所有对象授权。</li></ul></li><li><p>示例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 授予用户UserA对表employees的查询权限</span></span>
<span class="line"><span>GRANT SELECT ON employees TO UserA;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 授予角色Analyst对所有表的全部权限</span></span>
<span class="line"><span>GRANT ALL PRIVILEGES ON *.* TO Analyst;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 列级权限：仅允许更新price列</span></span>
<span class="line"><span>GRANT UPDATE(price) ON sales TO UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><hr><h5 id="_2-revoke-收回权限" tabindex="-1"><a class="header-anchor" href="#_2-revoke-收回权限"><span><strong>2. REVOKE（收回权限）</strong></span></a></h5><ul><li><p>基础语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>REVOKE 权限1, 权限2 </span></span>
<span class="line"><span>ON 对象类型.对象名 </span></span>
<span class="line"><span>FROM 用户/角色;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>常考考点</p><ul><li><p>收回转授权权限：</p></li><li><p>需明确指定<strong>GRANT OPTION</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>REVOKE GRANT OPTION FOR INSERT ON projects FROM UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>对象范围</strong>：需与 <code>GRANT</code> 时指定的范围一致。</p></li><li><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-- 撤销UserA对表employees的查询权限</span></span>
<span class="line"><span>REVOKE SELECT ON employees FROM UserA;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-- 撤销UserB对列price的更新权限</span></span>
<span class="line"><span>REVOKE UPDATE(price) ON sales FROM UserB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="关系代数" tabindex="-1"><a class="header-anchor" href="#关系代数"><span>关系代数</span></a></h3><h4 id="运算分类" tabindex="-1"><a class="header-anchor" href="#运算分类"><span>运算分类</span></a></h4><table><thead><tr><th>类型</th><th>运算符</th><th>描述</th><th>核心操作对象</th></tr></thead><tbody><tr><td><strong>传统集合运算</strong></td><td>∪（并）、∩（交）、−（差）、×（笛卡尔积）</td><td>基于元组集合的行操作，要求参与运算的关系 <strong>并相容</strong>（列数相同且对应属性域一致）</td><td>行（元组）</td></tr><tr><td><strong>专门关系运算</strong></td><td>σ（选择）、π（投影）、∞（连接）、÷（除）</td><td>结合行列操作，支持复杂查询逻辑</td><td>行和列（属性）</td></tr></tbody></table><p><strong>运算符速查表</strong></p><table><thead><tr><th>运算符</th><th>名称</th><th>SQL 对应</th><th>功能描述</th></tr></thead><tbody><tr><td>∪</td><td>并</td><td>UNION</td><td>合并元组，去重</td></tr><tr><td>−</td><td>差</td><td>EXCEPT</td><td>排除另一关系的元组</td></tr><tr><td>∩</td><td>交</td><td>INTERSECT</td><td>取共同元组</td></tr><tr><td>×</td><td>笛卡尔积</td><td>CROSS JOIN</td><td>所有元组组合</td></tr><tr><td>σ</td><td>选择</td><td>WHERE</td><td>筛选行</td></tr><tr><td>π</td><td>投影</td><td>SELECT</td><td>选择列</td></tr><tr><td>∞</td><td>连接</td><td>JOIN ... ON</td><td>关联表</td></tr><tr><td>÷</td><td>除</td><td>NOT EXISTS</td><td>包含全部匹配</td></tr></tbody></table><h4 id="传统集合运算-行操作" tabindex="-1"><a class="header-anchor" href="#传统集合运算-行操作"><span>传统集合运算（行操作）</span></a></h4><p><strong>2.1 并（∪）</strong></p><ul><li><p><strong>定义</strong>：合并两个关系的元组，去除重复行。</p></li><li><p><strong>表达式</strong>：R ∪ S = {所有属于 R 或 S 的元组}。</p></li><li><p>示例：</p><ul><li><p>关系 R：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></li><li><p>关系 S：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></li><li><p>R ∪ S：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></li></ul></li></ul><p><strong>2.2 差（−）</strong></p><ul><li><p><strong>定义</strong>：保留属于 R 但不属于 S 的元组。</p></li><li><p><strong>表达式</strong>：R − S = {属于 R 但不在 S 中的元组}。</p></li><li><p>示例：</p><ul><li><p>R − S：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table></li></ul></li></ul><p><strong>2.3 交（∩）</strong></p><ul><li><p><strong>定义</strong>：保留同时属于 R 和 S 的元组。</p></li><li><p><strong>表达式</strong>：R ∩ S = {同时属于 R 和 S 的元组}。</p></li><li><p>示例：</p><ul><li><p>R ∩ S：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr></tbody></table></li></ul></li></ul><p><strong>2.4 笛卡尔积（×）</strong></p><ul><li><p><strong>定义</strong>：生成两个关系所有元组的组合，属性数为 R+S，元组数为 R×S。</p></li><li><p><strong>表达式</strong>：R × S = {所有 r∈R，s∈S 的组合}。</p></li><li><p>示例：</p><ul><li><p>R × S：</p><table><thead><tr><th>A</th><th>B</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>2</td><td>5</td><td>6</td></tr><tr><td>3</td><td>4</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table></li></ul></li></ul><h4 id="专门关系运算-行列结合" tabindex="-1"><a class="header-anchor" href="#专门关系运算-行列结合"><span>专门关系运算（行列结合）</span></a></h4><p><strong>3.1 选择（σ）</strong></p><ul><li><strong>定义</strong>：从关系中筛选满足条件的元组。</li><li><strong>表达式</strong>：σ<sub>条件</sub>(关系)</li><li><strong>示例</strong>：查询年龄≥20 的学生：σ<sub>年龄≥20</sub>(学生表)。</li></ul><p><strong>3.2 投影（π）</strong></p><ul><li><strong>定义</strong>：从关系中选择指定列，去重。</li><li><strong>表达式</strong>：π<sub>属性 1, 属性 2</sub>(关系)</li><li><strong>示例</strong>：查询学生姓名和年龄：π<sub>姓名，年龄</sub>(学生表)。</li></ul><p><strong>3.3 连接（∞）</strong></p><table><thead><tr><th>类型</th><th>符号</th><th>描述</th><th>示例（关系 R 和 S）</th></tr></thead><tbody><tr><td>等值连接</td><td>⋈<sub>A=B</sub></td><td>选择 R 和 S 中指定属性值相等的元组</td><td>R ⋈<sub>R.A=S.A</sub> S</td></tr><tr><td>自然连接</td><td>⋈</td><td>等值连接后去掉重复属性</td><td>R ⋈ S（隐含相同属性名的等值连接）</td></tr><tr><td>左外连接</td><td>⟕</td><td>保留 R 所有元组，S 中无匹配的元组补 NULL</td><td>R ⟕ S</td></tr><tr><td>右外连接</td><td>⟖</td><td>保留 S 所有元组，R 中无匹配的元组补 NULL</td><td>R ⟖ S</td></tr><tr><td>全外连接</td><td>⟗</td><td>保留 R 和 S 所有元组，无匹配的元组补 NULL</td><td>R ⟗ S</td></tr></tbody></table><p><strong>自然连接与等值连接对比</strong></p><table><thead><tr><th>对比项</th><th>自然连接</th><th>等值连接</th></tr></thead><tbody><tr><td>条件</td><td>基于相同属性名的等值连接</td><td>任意属性的等值条件</td></tr><tr><td>结果列</td><td>去除重复属性</td><td>保留重复属性</td></tr><tr><td>符号</td><td>⋈</td><td>⋈<sub>A=B</sub></td></tr></tbody></table><p><strong>3.4 除（÷）</strong></p><ul><li><strong>定义</strong>：R÷S 返回 R 中包含 S 所有属性值的元组。</li><li><strong>表达式</strong>：R÷S = {r[X] | r∈R ∧ π<sub>Y</sub>(S)⊆Y<sub>x</sub>}，其中 Y 是 S 的属性，Y<sub>x</sub>是 R 中 X 值对应的 Y 值集合。</li><li><strong>示例</strong>：查询选修了所有课程的学生：π<sub>学号，课程号</sub>(选课表) ÷ π<sub>课程号</sub>(课程表)。</li></ul><p><strong>除运算步骤</strong></p><ol><li><strong>投影 S 的属性</strong>：提取 S 中与 R 相同的属性列。</li><li><strong>分组 R 的属性</strong>：按 R 中与 S 不同的属性分组。</li><li><strong>检查包含关系</strong>：每组的象集是否包含 S 的投影。</li></ol><h4 id="典型题型与解题技巧" tabindex="-1"><a class="header-anchor" href="#典型题型与解题技巧"><span>典型题型与解题技巧</span></a></h4><p><strong>关系代数表达式书写</strong></p><p><strong>例题</strong>：查询年龄≥20 且性别为男的学生姓名和年龄。</p><ul><li>步骤： <ol><li>选择条件：σ<sub>年龄≥20 ∧ 性别 =‘男’</sub>(学生表)</li><li>投影属性：π<sub>姓名，年龄</sub>(步骤 1 结果)</li></ol></li><li><strong>表达式</strong>：π<sub>姓名，年龄</sub>(σ<sub>年龄≥20 ∧ 性别 =‘男’</sub>(学生表))</li></ul><p><strong>除运算应用</strong></p><p><strong>例题</strong>：查询选修了所有课程的学生学号。</p><ul><li>步骤： <ol><li>提取选课表的学号和课程号：π<sub>学号，课程号</sub>(选课表)</li><li>提取课程表的课程号：π<sub>课程号</sub>(课程表)</li><li>执行除运算：步骤 1 ÷ 步骤 2</li></ol></li><li><strong>表达式</strong>：π<sub>学号，课程号</sub>(选课表) ÷ π<sub>课程号</sub>(课程表)</li></ul><p><strong>连接类型判断</strong></p><p><strong>例题</strong>：判断以下连接类型：</p><ul><li>R ⟕ S：左外连接，保留 R 所有元组。</li><li>R ⟖ S：右外连接，保留 S 所有元组。</li><li>R ⋈ S：自然连接，隐含相同属性的等值连接。</li></ul><h4 id="关系代数与-sql-对应" tabindex="-1"><a class="header-anchor" href="#关系代数与-sql-对应"><span>关系代数与 SQL 对应</span></a></h4><table><thead><tr><th>关系代数运算</th><th>SQL 语句示例</th></tr></thead><tbody><tr><td>选择</td><td>SELECT * FROM 表 WHERE 条件；</td></tr><tr><td>投影</td><td>SELECT 属性 1, 属性 2 FROM 表；</td></tr><tr><td>自然连接</td><td>SELECT * FROM R JOIN S USING (公共属性);</td></tr><tr><td>除</td><td>SELECT 学号 FROM 选课表 AS A WHERE NOT EXISTS (SELECT * FROM 课程表 AS B WHERE NOT EXISTS (SELECT * FROM 选课表 AS C WHERE C. 学号 = A. 学号 AND C. 课程号 = B. 课程号));</td></tr></tbody></table><h3 id="关系数据库的规范化" tabindex="-1"><a class="header-anchor" href="#关系数据库的规范化"><span>关系数据库的规范化</span></a></h3><h4 id="核心概念-1" tabindex="-1"><a class="header-anchor" href="#核心概念-1"><span>核心概念</span></a></h4><p>规范化的核心目标是通过分解关系模式，消除数据冗余和操作异常（如插入、删除、更新异常），提高数据一致性。核心工具包括函数依赖和范式：</p><ul><li><strong>函数依赖</strong>：属性间的决定关系，如<code>学号→姓名</code>。分为完全依赖、部分依赖和传递依赖。</li><li><strong>范式</strong>：关系模式的规范化等级，包括 1NF、2NF、3NF、BCNF 等，等级越高约束越严格。</li></ul><h4 id="函数依赖基础" tabindex="-1"><a class="header-anchor" href="#函数依赖基础"><span>函数依赖基础</span></a></h4><h5 id="基本定义" tabindex="-1"><a class="header-anchor" href="#基本定义"><span>基本定义</span></a></h5><ul><li><strong>函数依赖（FD）</strong>：若属性 X 的值确定时，属性 Y 的值唯一确定，记为<code>X→Y</code>。</li><li><strong>候选键</strong>：能唯一标识元组的最小属性集，如学生表中的<code>学号</code>。</li><li><strong>主属性</strong>：包含在任一候选键中的属性；<strong>非主属性</strong>：不包含在任何候选键中的属性。</li></ul><h5 id="依赖类型对比" tabindex="-1"><a class="header-anchor" href="#依赖类型对比"><span>依赖类型对比</span></a></h5><table><thead><tr><th>类型</th><th>定义</th><th>示例</th></tr></thead><tbody><tr><td>完全函数依赖</td><td>Y 依赖于 X 的全部属性，且 X 的任何真子集都不能决定 Y</td><td><code>(学号,课程号)→成绩</code>（成绩完全依赖于组合键）</td></tr><tr><td>部分函数依赖</td><td>Y 依赖于 X 的部分属性</td><td><code>(学号,课程号)→姓名</code>（姓名仅依赖学号）</td></tr><tr><td>传递函数依赖</td><td>X→Y 且 Y→Z（Y 不决定 X），则 Z 传递依赖于 X</td><td><code>学号→系名，系名→系主任</code> → <code>学号→系主任</code></td></tr></tbody></table><h4 id="各级范式详解" tabindex="-1"><a class="header-anchor" href="#各级范式详解"><span>各级范式详解</span></a></h4><h5 id="第一范式-1nf" tabindex="-1"><a class="header-anchor" href="#第一范式-1nf"><span>第一范式（1NF）</span></a></h5><ul><li><strong>定义</strong>：所有属性不可再分，确保每个单元格为原子值。</li><li>条件： <ul><li>关系模式中的每个属性均为原子类型。</li><li>无重复组或多值属性。</li></ul></li><li>示例： <ul><li><strong>不符合 1NF</strong>：关系<code>学生(学号,姓名,联系方式(电话,邮箱))</code>（联系方式可拆分）。</li><li><strong>符合 1NF</strong>：关系<code>学生(学号,姓名,电话,邮箱)</code>。</li></ul></li></ul><h5 id="第二范式-2nf" tabindex="-1"><a class="header-anchor" href="#第二范式-2nf"><span>第二范式（2NF）</span></a></h5><ul><li><strong>定义</strong>：在 1NF 基础上，消除非主属性对主码的部分函数依赖。</li><li>条件： <ul><li>关系模式满足 1NF。</li><li>所有非主属性完全依赖于主码。</li></ul></li><li>示例： <ul><li><strong>不符合 2NF</strong>：关系<code>选课(学号,课程号,课程名,成绩)</code>，因<code>课程号→课程名</code>存在部分依赖。</li><li>分解后： <ul><li><code>选课(学号,课程号,成绩)</code>（完全依赖）。</li><li><code>课程(课程号,课程名)</code>（消除部分依赖）。</li></ul></li></ul></li></ul><h5 id="第三范式-3nf" tabindex="-1"><a class="header-anchor" href="#第三范式-3nf"><span>第三范式（3NF）</span></a></h5><ul><li><strong>定义</strong>：在 2NF 基础上，消除非主属性对主码的传递函数依赖。</li><li>条件： <ul><li>关系模式满足 2NF。</li><li>所有非主属性不传递依赖于主码。</li></ul></li><li>示例： <ul><li><strong>不符合 3NF</strong>：关系<code>学生(学号,姓名,系名,系主任)</code>，因<code>学号→系名→系主任</code>存在传递依赖。</li><li>分解后： <ul><li><code>学生(学号,姓名,系名)</code>。</li><li><code>系(系名,系主任)</code>（消除传递依赖）。</li></ul></li></ul></li></ul><h5 id="bcnf-boyce-codd-范式" tabindex="-1"><a class="header-anchor" href="#bcnf-boyce-codd-范式"><span>BCNF（Boyce-Codd 范式）</span></a></h5><ul><li><strong>定义</strong>：在 3NF 基础上，消除主属性对候选键的部分和传递依赖。</li><li>条件： <ul><li>关系模式满足 3NF。</li><li>所有决定因素（X）均为候选键。</li></ul></li><li>示例： <ul><li><strong>不符合 BCNF</strong>：关系<code>教师(教师编号,课程号,学生)</code>，若<code>(教师编号,课程号)→学生</code>且<code>学生→课程号</code>，则<code>学生</code>非候选键，存在主属性依赖。</li><li>分解后： <ul><li><code>授课(教师编号,课程号)</code>。</li><li><code>学生(学生,课程号)</code>（确保所有决定因素为候选键）。</li></ul></li></ul></li></ul><h5 id="范式层次关系" tabindex="-1"><a class="header-anchor" href="#范式层次关系"><span>范式层次关系</span></a></h5><p>范式等级从低到高依次为：1NF ⊂ 2NF ⊂ 3NF ⊂ BCNF。每一级范式均需满足前一级的所有条件。</p><h5 id="范式转换流程" tabindex="-1"><a class="header-anchor" href="#范式转换流程"><span>范式转换流程</span></a></h5><p><strong>转换步骤</strong></p><ol><li><strong>1NF→2NF</strong>：拆分部分依赖的非主属性至新表。</li><li><strong>2NF→3NF</strong>：拆分传递依赖的非主属性至新表。</li><li><strong>3NF→BCNF</strong>：拆分主属性依赖的决定因素至新表。</li></ol><p><strong>分解原则</strong></p><ul><li><strong>无损连接</strong>：分解后的关系通过自然连接可恢复原关系。</li><li><strong>保持依赖</strong>：分解后的关系保留原函数依赖。</li><li>示例： <ul><li><strong>原关系</strong>：<code>S-L-C(Sno, Sdept, SLOC, Cno, Grade)</code>（SLOC 为学生宿舍楼）。</li><li><strong>问题</strong>：存在部分依赖<code>Sno→Sdept</code>和传递依赖<code>Sdept→SLOC</code>。</li><li>分解步骤： <ol><li>拆分为<code>S-C(Sno, Cno, Grade)</code>和<code>S-L(Sno, Sdept, SLOC)</code>（消除部分依赖）。</li><li>进一步拆分为<code>S-D(Sno, Sdept)</code>和<code>D-L(Sdept, SLOC)</code>（消除传递依赖）。</li></ol></li></ul></li></ul><h4 id="典型题型" tabindex="-1"><a class="header-anchor" href="#典型题型"><span>典型题型</span></a></h4><h5 id="范式判断" tabindex="-1"><a class="header-anchor" href="#范式判断"><span>范式判断</span></a></h5><p><strong>例题</strong>：判断关系<code>R(A,B,C,D,E)</code>，函数依赖<code>F={A→B, B→C, C→D, D→E}</code>满足几范式？ <strong>解析</strong>：</p><ol><li><strong>1NF</strong>：属性原子化，满足。</li><li><strong>2NF</strong>：候选键为<code>A</code>，非主属性<code>B、C、D、E</code>均完全依赖<code>A</code>，满足。</li><li><strong>3NF</strong>：存在传递依赖<code>A→B→C→D→E</code>，不满足。 <strong>结论</strong>：关系<code>R</code>满足 2NF，不满足 3NF。</li></ol><h5 id="模式分解" tabindex="-1"><a class="header-anchor" href="#模式分解"><span>模式分解</span></a></h5><p><strong>例题</strong>：分解关系<code>S(PNO, PNAME, QTY, PRICE, DATE, CUST_NAME, CUST_ADDR)</code>至 3NF。 <strong>步骤</strong>：</p><ol><li><strong>确定函数依赖</strong>：<code>(PNO, DATE)→QTY, PRICE</code>；<code>PNO→PNAME</code>；<code>CUST_NAME→CUST_ADDR</code>。</li><li>消除部分依赖： <ul><li><code>产品(PNO, PNAME, PRICE)</code>。</li><li><code>销售(PNO, DATE, QTY)</code>。</li><li><code>顾客(CUST_NAME, CUST_ADDR)</code>。</li></ul></li><li><strong>消除传递依赖</strong>：已满足 3NF。 <strong>分解结果</strong>：<code>产品</code>、<code>销售</code>、<code>顾客</code>三张表。</li></ol><h5 id="依赖保持与无损连接" tabindex="-1"><a class="header-anchor" href="#依赖保持与无损连接"><span>依赖保持与无损连接</span></a></h5><p><strong>例题</strong>：关系<code>R(A,B,C,D)</code>，函数依赖<code>F={A→B, B→C, C→D}</code>，分解为<code>R1(A,B)</code>、<code>R2(B,C)</code>、<code>R3(C,D)</code>是否保持依赖？ <strong>解析</strong>：</p><ul><li><strong>依赖保持</strong>：<code>A→B</code>在<code>R1</code>，<code>B→C</code>在<code>R2</code>，<code>C→D</code>在<code>R3</code>，所有依赖均保留，保持依赖。</li><li><strong>无损连接</strong>：通过自然连接可恢复原关系，满足无损连接。 <strong>结论</strong>：分解保持依赖且无损。</li></ul><table><thead><tr><th>题型类型</th><th>例题描述</th><th>解析要点</th></tr></thead><tbody><tr><td>范式判断</td><td>判断关系<code>R(A,B,C,D,E)</code>，函数依赖<code>F={A→B, B→C, C→D, D→E}</code>满足几范式？</td><td>逐层检查 1NF、2NF、3NF 条件，重点分析部分依赖和传递依赖。</td></tr><tr><td>模式分解</td><td>分解关系<code>S(PNO, PNAME, QTY, PRICE, DATE, CUST_NAME, CUST_ADDR)</code>至 3NF。</td><td>识别函数依赖，拆分部分依赖和传递依赖的属性至新表，确保无损连接和保持依赖。</td></tr><tr><td>依赖保持与无损连接</td><td>关系<code>R(A,B,C,D)</code>分解为<code>R1(A,B)</code>、<code>R2(B,C)</code>、<code>R3(C,D)</code>是否保持依赖？</td><td>检查所有函数依赖是否保留在分解后的关系中，并验证自然连接能否恢复原关系。</td></tr></tbody></table><h3 id="控制功能" tabindex="-1"><a class="header-anchor" href="#控制功能"><span>控制功能</span></a></h3><h4 id="事务管理-1" tabindex="-1"><a class="header-anchor" href="#事务管理-1"><span>事务管理</span></a></h4><p><strong>ACID 特性</strong></p><ul><li><strong>原子性（Atomicity）</strong>：事务中的操作要么全部执行，要么全部不执行。例如，转账操作中扣款和入账必须同时成功或失败。</li><li><strong>一致性（Consistency）</strong>：事务执行前后，数据库从一个合法状态转换到另一个合法状态。例如，转账前后账户总金额不变。</li><li><strong>隔离性（Isolation）</strong>：并发执行的事务之间互不干扰。例如，多个用户同时修改同一数据时，通过锁机制保证数据一致性。</li><li><strong>持久性（Durability）</strong>：事务提交后，数据修改永久生效。例如，断电后已提交的转账记录不会丢失。</li></ul><p><strong>事务状态转换</strong></p><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>活动状态 → 部分提交状态 → 提交状态（成功）  </span></span>
<span class="line"><span>活动状态 → 失败状态 → 中止状态（回滚）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>活动状态</strong>：事务开始后的初始状态。</li><li><strong>部分提交状态</strong>：最后一条操作执行完毕，但未提交。</li><li><strong>提交状态</strong>：事务成功完成，数据持久化。</li><li><strong>失败状态</strong>：事务执行中出现错误。</li><li><strong>中止状态</strong>：事务回滚，数据恢复到初始状态。</li></ul><p><strong>事务调度</strong></p><ul><li><strong>串行调度</strong>：事务依次执行，结果唯一。</li><li><strong>并发调度</strong>：事务交替执行，需保证可串行化（结果与某一串行调度一致）。</li><li><strong>可恢复调度</strong>：事务读取的数据必须来自已提交的事务，避免脏读。</li></ul><h4 id="并发控制" tabindex="-1"><a class="header-anchor" href="#并发控制"><span>并发控制</span></a></h4><p><strong>并发问题</strong></p><table><thead><tr><th>问题类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>丢失修改</td><td>两个事务同时修改同一数据，后提交的覆盖先提交的结果</td><td>事务 A 和 B 同时修改库存，最终库存值错误</td></tr><tr><td>脏读</td><td>事务读取到未提交的中间数据</td><td>事务 A 修改数据后未提交，事务 B 读取到该数据，随后 A 回滚，B 读取的数据无效</td></tr><tr><td>不可重复读</td><td>同一事务内多次读取同一数据，结果不一致</td><td>事务 A 读取数据后，事务 B 修改并提交，A 再次读取时结果不同</td></tr><tr><td>幻读</td><td>事务读取符合条件的记录数变化</td><td>事务 A 查询得到 10 条记录，事务 B 插入新记录后，A 再次查询得到 12 条记录</td></tr></tbody></table><p><strong>封锁协议</strong></p><table><thead><tr><th>协议等级</th><th>加锁规则</th><th>解决的问题</th></tr></thead><tbody><tr><td>一级协议</td><td>修改数据前加 X 锁，事务结束释放</td><td>丢失修改</td></tr><tr><td>二级协议</td><td>一级协议 + 读取数据前加 S 锁，读完释放</td><td>丢失修改、脏读</td></tr><tr><td>三级协议</td><td>一级协议 + 读取数据前加 S 锁，事务结束释放</td><td>丢失修改、脏读、不可重复读</td></tr></tbody></table><p><strong>两阶段锁协议（2PL）</strong></p><ul><li><strong>扩展阶段</strong>：事务可申请锁，但不能释放锁。</li><li><strong>收缩阶段</strong>：事务只能释放锁，不能申请新锁。</li><li><strong>特点</strong>：确保可串行化调度，但可能导致死锁。</li></ul><p><strong>隔离级别</strong></p><table><thead><tr><th>隔离级别</th><th>描述</th><th>解决的问题</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>允许读取未提交数据</td><td>仅避免丢失修改</td></tr><tr><td>READ COMMITTED</td><td>只能读取已提交数据</td><td>丢失修改、脏读</td></tr><tr><td>REPEATABLE READ</td><td>事务内多次读取结果一致</td><td>丢失修改、脏读、不可重复读</td></tr><tr><td>SERIALIZABLE</td><td>最高级别，强制事务串行执行</td><td>所有并发问题</td></tr></tbody></table><h4 id="数据库恢复" tabindex="-1"><a class="header-anchor" href="#数据库恢复"><span>数据库恢复</span></a></h4><p><strong>恢复技术</strong></p><ul><li>数据转储： <ul><li><strong>静态转储</strong>：转储期间不允许读写操作。</li><li><strong>动态转储</strong>：转储期间允许读写，需结合日志文件。</li><li><strong>海量转储</strong>：备份全部数据。</li><li><strong>增量转储</strong>：备份自上次转储后更新的数据。</li></ul></li><li><strong>日志文件</strong>：记录事务操作，用于恢复时的 UNDO 和 REDO。</li></ul><p><strong>检查点机制</strong></p><ol><li><strong>设置检查点</strong>：定期将内存数据刷新到磁盘，记录活动事务。</li><li>恢复步骤： <ul><li>反向扫描日志，找到最后一个检查点。</li><li>对检查点后提交的事务执行 REDO（重做）。</li><li>对检查点后未提交的事务执行 UNDO（回滚）。</li></ul></li></ol><p><strong>故障恢复</strong></p><table><thead><tr><th>故障类型</th><th>恢复方法</th></tr></thead><tbody><tr><td>事务故障</td><td>反向扫描日志，对未提交事务执行 UNDO</td></tr><tr><td>系统故障</td><td>对未提交事务执行 UNDO，对已提交但未写入磁盘的事务执行 REDO</td></tr><tr><td>介质故障</td><td>重装数据库备份，结合日志文件执行 REDO</td></tr></tbody></table><h4 id="完整性约束" tabindex="-1"><a class="header-anchor" href="#完整性约束"><span>完整性约束</span></a></h4><p><strong>约束类型</strong></p><ul><li>实体完整性：主键不能为空或重复。 <ul><li>示例：<code>CREATE TABLE 学生 (学号 INT PRIMARY KEY, 姓名 VARCHAR(50));</code></li></ul></li><li>参照完整性：外键值必须存在于被参照表的主键中。 <ul><li>示例：<code>CREATE TABLE 选课 (学号 INT, 课程号 INT, FOREIGN KEY (学号) REFERENCES 学生(学号));</code></li></ul></li><li>用户定义完整性：自定义约束条件。 <ul><li>示例：<code>ALTER TABLE 学生 ADD CONSTRAINT 年龄 CHECK (年龄 BETWEEN 18 AND 30);</code></li></ul></li></ul><p><strong>触发器</strong></p><ul><li><p><strong>作用</strong>：自动执行特定操作，确保复杂业务规则。</p></li><li><p>示例：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> TRIGGER</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 库存检查</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> AFTER</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INSERT</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> ON</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 订单  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FOR</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> EACH </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">ROW</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">BEGIN</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 商品 </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 库存 </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 库存 </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> NEW</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">数量</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 商品ID </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> NEW</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">商品ID</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">END</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="安全性控制" tabindex="-1"><a class="header-anchor" href="#安全性控制"><span>安全性控制</span></a></h4><p><strong>访问控制</strong></p><ul><li><strong>用户认证</strong>：通过用户名 / 密码验证身份。</li><li>授权管理： <ul><li><strong>授予权限</strong>：<code>GRANT SELECT, INSERT ON 学生 TO &#39;user1&#39;@&#39;localhost&#39;;</code></li><li><strong>回收权限</strong>：<code>REVOKE INSERT ON 学生 FROM &#39;user1&#39;@&#39;localhost&#39;;</code></li></ul></li><li><strong>角色管理</strong>：将权限赋予角色，用户通过角色获取权限。</li></ul><p><strong>视图与审计</strong></p><ul><li>视图：限制用户访问特定数据。 <ul><li>示例：<code>CREATE VIEW 学生信息 AS SELECT 学号, 姓名 FROM 学生;</code></li></ul></li><li><strong>审计</strong>：记录用户操作，用于追踪和安全分析。</li></ul><p><strong>数据加密</strong></p><ul><li><strong>静态加密</strong>：对存储的数据加密（如透明数据加密 TDE）。</li><li><strong>动态加密</strong>：对传输中的数据加密（如 SSL/TLS）。</li></ul><h4 id="典型题型-1" tabindex="-1"><a class="header-anchor" href="#典型题型-1"><span>典型题型</span></a></h4><p><strong>事务调度判断</strong><strong>例题</strong>：事务 T1 和 T2 的操作序列如下，是否为可串行化调度？ T1: R(A), W(A), R(B), W(B) T2: R(B), W(B), R(A), W(A) <strong>解析</strong>：冲突操作顺序不一致（T1 的 W (B) 与 T2 的 R (B) 冲突），不可串行化。</p><p><strong>封锁协议应用</strong><strong>例题</strong>：若事务需要读取数据 A 并修改数据 B，应采用几级封锁协议？ <strong>解析</strong>：三级封锁协议，对 A 加 S 锁（事务结束释放），对 B 加 X 锁（事务结束释放），防止不可重复读和丢失修改。</p><p><strong>恢复步骤计算</strong><strong>例题</strong>：日志文件如下，检查点后发生故障，需恢复哪些事务？</p><ol><li>T1 START</li><li>T1 W(A)</li><li>T2 START</li><li>T2 W(B)</li><li>CHECKPOINT (T1, T2)</li><li>T3 START</li><li>T3 W(C)</li><li>T1 COMMIT</li><li>T3 COMMIT <strong>解析</strong>：T1 已提交（REDO），T2 未提交（UNDO），T3 已提交（REDO）。</li></ol><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h3 id="时间-空间-复杂度" tabindex="-1"><a class="header-anchor" href="#时间-空间-复杂度"><span>时间（空间）复杂度</span></a></h3><h4 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结"><span><strong>知识点总结</strong></span></a></h4><table><thead><tr><th><strong>知识点</strong></th><th><strong>内容概述</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度定义</strong></td><td>衡量算法运行时间随输入规模增长的趋势，用大O符号表示。通常关注最坏情况下的复杂度。</td></tr><tr><td><strong>空间复杂度定义</strong></td><td>衡量算法运行所需额外存储空间随输入规模的增长趋势，同样用大O符号表示。</td></tr><tr><td><strong>计算规则</strong></td><td>1. <strong>加法规则</strong>：总复杂度取最大项（如 T(n)=O(f(n))+O(g(n)) → O(max(f(n),g(n)))）。<br>2. <strong>乘法规则</strong>：嵌套操作复杂度相乘（如 T(n)=O(f(n))×O(g(n)) → O(f(n)*g(n))）。</td></tr><tr><td><strong>渐进符号（大O）</strong></td><td>忽略低阶项和系数，保留最高阶项。例如：T(n)=2n²+3n+5 → O(n²)。</td></tr><tr><td><strong>主定理（Master Theorem）</strong></td><td>用于求解递归式的时间复杂度，适用于形如 T(n)=aT(n/b)+f(n) 的递归方程。</td></tr></tbody></table><hr><h4 id="考点归纳" tabindex="-1"><a class="header-anchor" href="#考点归纳"><span><strong>考点归纳</strong></span></a></h4><table><thead><tr><th><strong>考点</strong></th><th><strong>核心内容</strong></th></tr></thead><tbody><tr><td><strong>常见时间复杂度等级</strong></td><td>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</td></tr><tr><td><strong>时间复杂度计算步骤</strong></td><td>1. 确定基本操作（如循环内耗时最多的语句）。<br>2. 计算基本操作的执行次数。<br>3. 用大O表示法简化。</td></tr><tr><td><strong>空间复杂度计算重点</strong></td><td>区分算法所需额外空间（如递归栈、辅助数组）与输入数据本身的存储空间。</td></tr><tr><td><strong>递归算法复杂度分析</strong></td><td>时间复杂度：递归次数 × 每次递归的操作次数。<br>空间复杂度：递归深度 × 每次递归的辅助空间。</td></tr></tbody></table><hr><h4 id="常见算法复杂度表" tabindex="-1"><a class="header-anchor" href="#常见算法复杂度表"><span><strong>常见算法复杂度表</strong></span></a></h4><table><thead><tr><th><strong>算法名称</strong></th><th><strong>时间复杂度（最坏情况）</strong></th><th><strong>空间复杂度</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>直接访问数组元素</strong></td><td>O(1)</td><td>O(1)</td><td>常数时间，无需额外空间。</td></tr><tr><td><strong>顺序查找（线性查找）</strong></td><td>O(n)</td><td>O(1)</td><td>遍历数组查找元素。</td></tr><tr><td><strong>二分查找</strong></td><td>O(log n)</td><td>O(1)</td><td>有序数组的对数时间查找。</td></tr><tr><td><strong>冒泡排序</strong></td><td>O(n²)</td><td>O(1)</td><td>简单排序，原地操作。</td></tr><tr><td><strong>快速排序</strong></td><td>O(n²)</td><td>O(log n)</td><td>平均O(n log n)，最坏O(n²)（递归栈）。</td></tr><tr><td><strong>归并排序</strong></td><td>O(n log n)</td><td>O(n)</td><td>需额外空间合并子数组。</td></tr><tr><td><strong>堆排序</strong></td><td>O(n log n)</td><td>O(1)</td><td>原地排序，基于堆结构。</td></tr><tr><td><strong>插入排序</strong></td><td>O(n²)</td><td>O(1)</td><td>适合小规模或部分有序数据。</td></tr><tr><td><strong>斐波那契数列（递归）</strong></td><td>O(2ⁿ)</td><td>O(n)</td><td>指数时间，递归栈深度为n。</td></tr><tr><td><strong>矩阵乘法（三重循环）</strong></td><td>O(n³)</td><td>O(1)</td><td>逐元素计算的朴素方法。</td></tr><tr><td><strong>Dijkstra算法（邻接表）</strong></td><td>O((V+E) log V)</td><td>O(V+E)</td><td>优先队列实现，V为顶点数，E为边数。</td></tr></tbody></table><hr><h4 id="复杂度等级对比" tabindex="-1"><a class="header-anchor" href="#复杂度等级对比"><span><strong>复杂度等级对比</strong></span></a></h4><table><thead><tr><th><strong>复杂度等级</strong></th><th><strong>示例算法/操作</strong></th><th><strong>输入规模n的适用范围</strong></th></tr></thead><tbody><tr><td>O(1)</td><td>数组访问、哈希表查询</td><td>任何规模，时间恒定。</td></tr><tr><td>O(log n)</td><td>二分查找、堆操作</td><td>n=1e9时，log2(n)≈30，效率极高。</td></tr><tr><td>O(n)</td><td>线性查找、单层循环</td><td>n=1e6时，可处理秒级。</td></tr><tr><td>O(n log n)</td><td>快速排序、归并排序</td><td>n=1e7时，仍可接受。</td></tr><tr><td>O(n²)</td><td>冒泡排序、简单矩阵乘法</td><td>n≤1e4时，可能超时。</td></tr><tr><td>O(n³)</td><td>三重循环、朴素矩阵乘法</td><td>n≤1e3时，可能超时。</td></tr><tr><td>O(2ⁿ)</td><td>子集枚举、斐波那契递归</td><td>n≤20时，可能超时；n=30时，不可行。</td></tr><tr><td>O(n!)</td><td>全排列生成</td><td>n≤12时，可能超时；n=20时，不可行。</td></tr></tbody></table><hr><h4 id="关键注意事项" tabindex="-1"><a class="header-anchor" href="#关键注意事项"><span><strong>关键注意事项</strong></span></a></h4><ol><li><strong>时间复杂度优先级</strong>：在算法选择中，优先考虑低阶复杂度（如O(n log n)优于O(n²)）。</li><li><strong>空间与时间的权衡</strong>：例如，哈希表（空间换时间）或分治算法（可能增加空间需求）。</li><li><strong>递归的隐式成本</strong>：递归可能导致额外空间开销（如栈深度）。</li><li><strong>实际优化</strong>：常数系数和低阶项在小规模数据中可能影响性能，但复杂度分析关注趋势。</li></ol><h3 id="线性结构" tabindex="-1"><a class="header-anchor" href="#线性结构"><span>线性结构</span></a></h3><h4 id="线性结构的核心概念" tabindex="-1"><a class="header-anchor" href="#线性结构的核心概念"><span><strong>线性结构的核心概念</strong></span></a></h4><p><strong>1. 定义与特点</strong></p><ul><li><strong>定义</strong>：数据元素之间存在<strong>一对一</strong>的线性关系，元素按顺序排列，每个元素有唯一前驱和后继（首尾元素除外）。</li><li>核心特点： <ul><li><strong>有序性</strong>：元素按逻辑顺序排列。</li><li><strong>唯一性</strong>：首元素无前驱，尾元素无后继。</li><li><strong>直接关系</strong>：相邻元素直接关联。</li></ul></li></ul><p><strong>2. 常见线性结构类型</strong></p><ul><li><strong>线性表</strong>：最基础的线性结构，包含顺序表和链表。</li><li><strong>栈（Stack）</strong>：后进先出（LIFO），仅允许在栈顶操作（如递归、表达式求值）。</li><li><strong>队列（Queue）</strong>：先进先出（FIFO），队尾入队、队头出队（如任务调度、BFS）。</li><li><strong>数组</strong>：固定大小的线性结构，支持随机访问。</li><li><strong>字符串</strong>：字符序列，属于线性表的特殊形式。</li></ul><hr><h4 id="存储方式对比与关键考点" tabindex="-1"><a class="header-anchor" href="#存储方式对比与关键考点"><span><strong>存储方式对比与关键考点</strong></span></a></h4><p><strong>1. 存储方式选择</strong></p><table><thead><tr><th><strong>存储方式</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th><th><strong>常考对比</strong></th></tr></thead><tbody><tr><td><strong>顺序存储</strong></td><td>内存连续，支持随机访问（<code>data[i]</code>），插入/删除需移动元素，动态扩容可能耗时</td><td>数据量固定或较少插入/删除操作</td><td>与链式存储对比：插入/删除效率低，但访问快</td></tr><tr><td><strong>链式存储</strong></td><td>动态分配内存，插入/删除快（改指针即可），但访问需遍历，空间利用率较低</td><td>频繁插入/删除操作，数据量动态变化</td><td>与顺序存储对比：访问慢，但插入/删除快</td></tr></tbody></table><p><strong>2. 线性表操作复杂度</strong></p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>顺序表</strong></th><th><strong>单链表</strong></th><th><strong>考点关联</strong></th></tr></thead><tbody><tr><td>插入/删除</td><td>平均 <code>O(n)</code></td><td>平均 <code>O(1)</code>（需找到位置）</td><td>考察存储方式选择：频繁操作选链表，静态数据选顺序表</td></tr><tr><td>查找</td><td><code>O(1)</code>（直接索引）</td><td><code>O(n)</code>（需遍历）</td><td>考察时间复杂度分析：顺序表随机访问快，链表需遍历</td></tr></tbody></table><hr><h4 id="栈与队列的核心对比与应用" tabindex="-1"><a class="header-anchor" href="#栈与队列的核心对比与应用"><span><strong>栈与队列的核心对比与应用</strong></span></a></h4><p><strong>1. 栈（Stack）与队列（Queue）的区别</strong></p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>栈（Stack）</strong></th><th><strong>队列（Queue）</strong></th><th><strong>常考题型</strong></th></tr></thead><tbody><tr><td><strong>操作原则</strong></td><td>后进先出（LIFO）</td><td>先进先出（FIFO）</td><td>概念对比题：区分LIFO与FIFO的应用场景</td></tr><tr><td><strong>典型应用</strong></td><td>递归、表达式求值、函数调用栈、括号匹配</td><td>任务调度、BFS、消息队列、缓存管理</td><td>应用实例题：DFS用栈，BFS用队列</td></tr><tr><td><strong>存储实现</strong></td><td>数组或链表实现，需维护栈顶指针</td><td>数组或链表实现，需维护队头/队尾指针</td><td>循环队列的溢出条件（<code>front = (rear + 1) % maxSize</code>）</td></tr></tbody></table><p><strong>2. 栈与队列的实现细节</strong></p><ul><li><strong>栈</strong>：通常用数组或链表实现，需注意栈满/栈空的判断。</li><li><strong>队列</strong>：循环队列需处理“假溢出”，需掌握其溢出条件（如 <code>front = (rear + 1) % maxSize</code>）。</li></ul><hr><h4 id="线性结构的典型应用与复杂度分析" tabindex="-1"><a class="header-anchor" href="#线性结构的典型应用与复杂度分析"><span><strong>线性结构的典型应用与复杂度分析</strong></span></a></h4><p><strong>1. 线性结构在算法中的应用</strong></p><ul><li>栈： <ul><li><strong>递归</strong>：函数调用栈的底层实现。</li><li><strong>表达式求值</strong>：用栈匹配括号或计算逆波兰表达式。</li></ul></li><li>队列： <ul><li><strong>BFS</strong>：通过队列按层次遍历图或树。</li><li><strong>任务调度</strong>：操作系统中任务队列的管理。</li></ul></li></ul><p><strong>2. 常考复杂度分析题</strong></p><ul><li>题目：顺序表和链表在插入操作上的时间复杂度有何差异？ <ul><li><strong>答案</strong>：顺序表需移动元素，复杂度 <code>O(n)</code>；链表仅改指针，复杂度 <code>O(1)</code>。</li></ul></li><li>题目：深度优先搜索（DFS）和广度优先搜索（BFS）分别使用什么结构？ <ul><li><strong>答案</strong>：DFS用栈（LIFO），BFS用队列（FIFO）。</li></ul></li></ul><hr><h4 id="关键注意事项与易错点" tabindex="-1"><a class="header-anchor" href="#关键注意事项与易错点"><span><strong>关键注意事项与易错点</strong></span></a></h4><ol><li><strong>线性结构与非线性结构的区别</strong>： <ul><li><strong>线性结构</strong>：元素间一对一（如线性表、栈、队列）。</li><li><strong>非线性结构</strong>：元素间多对多（如树、图）。</li><li><strong>易错点</strong>：将树或图误认为线性结构。</li></ul></li><li><strong>存储方式的权衡</strong>： <ul><li><strong>顺序表</strong>：适合静态数据或需频繁访问的场景（如数据库索引）。</li><li><strong>链表</strong>：适合动态数据或频繁插入/删除的场景（如链表实现LRU缓存）。</li></ul></li><li><strong>栈与队列的隐含要求</strong>： <ul><li>栈的操作仅限栈顶，队列的操作仅限队头/队尾。</li><li>循环队列的溢出条件需特别注意（避免“假溢出”）。</li></ul></li></ol><hr><p><strong>总结：线性结构对比表</strong></p><table><thead><tr><th><strong>结构类型</strong></th><th><strong>特点</strong></th><th><strong>存储方式</strong></th><th><strong>典型应用</strong></th><th><strong>时间复杂度（平均）</strong></th></tr></thead><tbody><tr><td>线性表</td><td>有序、一对一关系</td><td>顺序/链式</td><td>数据存储、排序算法</td><td>查找 <code>O(1)/O(n)</code>，插入/删除 <code>O(n)/O(1)</code></td></tr><tr><td>栈</td><td>LIFO</td><td>数组/链表</td><td>递归、表达式求值</td><td>入栈/出栈 <code>O(1)</code></td></tr><tr><td>队列</td><td>FIFO</td><td>数组/链表/循环队列</td><td>任务调度、BFS</td><td>入队/出队 <code>O(1)</code></td></tr><tr><td>顺序表</td><td>连续内存，支持随机访问</td><td>顺序存储</td><td>静态数据存储</td><td>插入/删除 <code>O(n)</code></td></tr><tr><td>链表</td><td>动态分配，插入/删除高效</td><td>链式存储</td><td>动态操作场景</td><td>查找 <code>O(n)</code></td></tr></tbody></table><h3 id="数组-矩阵-广义表" tabindex="-1"><a class="header-anchor" href="#数组-矩阵-广义表"><span>数组，矩阵，广义表</span></a></h3><h4 id="数组-array" tabindex="-1"><a class="header-anchor" href="#数组-array"><span><strong>数组（Array）</strong></span></a></h4><p><strong>1. 核心概念</strong></p><ul><li><strong>定义</strong>： 多个<strong>相同类型</strong>的元素按<strong>有序</strong>方式排列的集合，元素通过下标访问。</li><li>特点： <ul><li><strong>固定长度</strong>：定义后不可动态扩展或缩小（需重新分配内存）。</li><li><strong>连续存储</strong>：内存中连续存放，支持<strong>随机访问</strong>（通过下标直接定位）。</li><li><strong>多维特性</strong>：可以是高维结构（如二维数组、三维数组），但底层存储为一维线性结构。</li></ul></li></ul><p><strong>2. 存储方式</strong></p><ul><li>行优先（Row-major Order）： <ul><li>多维数组按行展开为一维数组。例如，二维数组 <code>A[m][n]</code> 中，<code>A[i][j]</code> 的地址计算公式为： <code>LOC(A[i][j]) = LOC(A[0][0]) + (i * n + j) * L</code>（L为元素大小）。</li><li><strong>C/C++/Java</strong> 等语言默认按行优先存储。</li></ul></li><li>列优先（Column-major Order）： <ul><li>多维数组按列展开，如 <code>A[i][j]</code> 的地址为 <code>LOC(A[i][j]) = LOC(A[0][0]) + (j * m + i) * L</code>。</li></ul></li></ul><p><strong>3. 考点与应用</strong></p><ul><li><strong>多维数组地址计算</strong>： 如二维数组 <code>A[3][4]</code> 中，<code>A[1][2]</code> 的地址为 <code>base + (1×4 + 2) × L</code>。</li><li>特殊矩阵的压缩存储： <ul><li><strong>对称矩阵</strong>：只存储下三角（含对角线）元素，空间复杂度降为 <code>n(n+1)/2</code>。</li><li><strong>三角矩阵</strong>：上/下三角全为常数，存储非常数区域。</li><li><strong>对角矩阵</strong>：非零元素集中在主对角线附近，按行或列压缩存储。</li></ul></li></ul><hr><h4 id="矩阵-matrix" tabindex="-1"><a class="header-anchor" href="#矩阵-matrix"><span><strong>矩阵（Matrix）</strong></span></a></h4><p><strong>1. 分类与存储</strong></p><ul><li>特殊矩阵： <ul><li><strong>对称矩阵</strong>：满足 <code>A[i][j] = A[j][i]</code>，存储下三角部分即可。</li><li>三角矩阵： <ul><li>上三角矩阵：下三角（不含对角线）全为常数。</li><li>下三角矩阵：上三角（不含对角线）全为常数。</li></ul></li><li><strong>对角矩阵</strong>：非零元素集中在主对角线附近（如三对角矩阵）。</li></ul></li><li>稀疏矩阵： <ul><li><strong>定义</strong>：非零元素远少于零元素，且分布无规律。</li><li>压缩存储方法： <ul><li><strong>三元组顺序表</strong>：存储<code>(行, 列, 值)</code>，如 <code>trimat[k][0]</code> 表示第k个非零元素的值。</li><li><strong>行逻辑链接表</strong>：增加行索引数组，快速定位某行的非零元素。</li><li><strong>十字链表</strong>：每个非零元素用节点表示，包含行、列、值，以及行指针和列指针。</li></ul></li></ul></li></ul><p><strong>2. 考点与应用</strong></p><ul><li><p>特殊矩阵的地址计算：</p><p>如三对角矩阵第i行的带状区域首元素下标为：</p><ul><li><code>i=1</code> 时为 <code>0</code>；</li><li><code>i&gt;1</code> 时为 <code>2 + (i-2)*3</code>。</li></ul></li><li><p><strong>稀疏矩阵的三元组操作</strong>： 如稀疏矩阵的转置、加法等需基于三元组顺序表实现。</p></li></ul><hr><h4 id="广义表-generalized-list" tabindex="-1"><a class="header-anchor" href="#广义表-generalized-list"><span><strong>广义表（Generalized List）</strong></span></a></h4><p><strong>1. 核心概念</strong></p><ul><li><strong>定义</strong>： 线性表的扩展，元素可以是<strong>原子</strong>（不可分数据）或<strong>子表</strong>（另一个广义表）。</li><li>关键术语： <ul><li><strong>长度</strong>：表中最外层元素的个数（如 <code>(a, (b, c))</code> 的长度为2）。</li><li><strong>深度</strong>：括号嵌套的最大层数（如 <code>(a, (b, (c)))</code> 的深度为3）。</li></ul></li></ul><p><strong>2. 存储方式</strong></p><ul><li><p>链式存储：</p><ul><li><p>节点类型：</p><ul><li><strong>原子节点</strong>：包含 <code>tag=0</code> 和原子值。</li><li><strong>表节点</strong>：包含 <code>tag=1</code>、<code>hp</code>（指向表头）和 <code>tp</code>（指向表尾）。</li></ul></li><li><p>C语言实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">typedef</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">          // 0:原子，1:子表</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    union</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        char</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> atom</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 原子值</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        struct</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            struct</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">hp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">tp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 表头、表尾指针</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> un</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GLNode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">GList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>存储特点：</p><ul><li>无法用顺序存储（因嵌套结构复杂）。</li><li>链式结构灵活，适合动态嵌套。</li></ul></li></ul><p><strong>3. 考点与应用</strong></p><ul><li><strong>深度与长度计算</strong>： 如广义表 <code>(a, (b, (c)))</code> 的长度为2，深度为3。</li><li>广义表操作： <ul><li><strong>取表头</strong>：<code>GetHead(L)</code> 返回第一个元素（原子或子表）。</li><li><strong>取表尾</strong>：<code>GetTail(L)</code> 返回剩余元素组成的表。</li></ul></li><li><strong>区别于线性表</strong>： 线性表元素只能是原子，广义表允许嵌套子表。</li></ul><hr><h4 id="对比总结" tabindex="-1"><a class="header-anchor" href="#对比总结"><span><strong>对比总结</strong></span></a></h4><table><thead><tr><th><strong>结构</strong></th><th><strong>元素类型</strong></th><th><strong>存储方式</strong></th><th><strong>特点</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>数组</strong></td><td>同类型、固定长度</td><td>顺序存储（行/列优先）</td><td>随机访问高效，插入/删除低效</td><td>多维数据存储、矩阵运算</td></tr><tr><td><strong>矩阵</strong></td><td>数值型</td><td>特殊矩阵压缩存储，稀疏矩阵三元组/链表</td><td>节省内存空间，支持高效运算</td><td>科学计算、图像处理</td></tr><tr><td><strong>广义表</strong></td><td>原子或子表</td><td>链式存储（带tag节点）</td><td>支持嵌套结构，灵活但操作复杂</td><td>人工智能、符号计算</td></tr></tbody></table><hr><h4 id="高频考题示例" tabindex="-1"><a class="header-anchor" href="#高频考题示例"><span><strong>高频考题示例</strong></span></a></h4><ol><li><strong>数组地址计算</strong>： <em>题目</em>：二维数组 <code>A[5][6]</code> 按行优先存储，首地址为 <code>100</code>，每个元素占 <code>4B</code>，求 <code>A[3][4]</code> 的地址。 <em>答案</em>：<code>100 + (3×6 + 4)×4 = 100 + 88×4 = 452</code>。</li><li><strong>广义表深度计算</strong>： <em>题目</em>：广义表 <code>(a, (b, (c, d)))</code> 的深度是多少？ <em>答案</em>：3（括号嵌套层数为3）。</li><li><strong>稀疏矩阵三元组操作</strong>： <em>题目</em>：稀疏矩阵的三元组顺序表中，第k个元素的行标如何表示？ <em>答案</em>：<code>trimat[k][1]</code>（假设三元组结构为 <code>[值, 行, 列]</code>）。</li></ol><hr><h4 id="关键注意事项-1" tabindex="-1"><a class="header-anchor" href="#关键注意事项-1"><span><strong>关键注意事项</strong></span></a></h4><ul><li><strong>数组与广义表的区别</strong>： 数组元素类型固定且无嵌套；广义表允许嵌套子表，结构灵活。</li><li><strong>特殊矩阵压缩的适用场景</strong>： 对称、三角、对角矩阵适合压缩，而稀疏矩阵需用三元组或链表。</li><li><strong>广义表的链式存储实现</strong>： 必须区分原子节点和表节点，通过 <code>tag</code> 标志域控制。</li></ul><h3 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h3><p>以下是关于<strong>数据结构中树</strong>的核心知识点总结，结合知识库内容，以清晰的结构化形式呈现，突出重点、对比和高频考点：</p><hr><h4 id="树的基本概念" tabindex="-1"><a class="header-anchor" href="#树的基本概念"><span><strong>树的基本概念</strong></span></a></h4><p><strong>定义</strong></p><ul><li><strong>树（Tree）</strong>：<br> 由<strong>n个节点</strong>组成的有限集合，满足以下条件： <ul><li>有且仅有一个<strong>根节点（Root）</strong>，无父节点。</li><li>其余节点分为<strong>互不相交的子树</strong>，每个子树本身也是一棵树。</li></ul></li><li><strong>特点</strong>： <ul><li>非线性结构，层次分明。</li><li>节点间存在<strong>一对一或多对多</strong>的层次关系。</li></ul></li></ul><hr><p><strong>核心术语</strong></p><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>节点（Node）</strong></td><td>树的基本单位，包含数据元素和指向子节点的指针。</td><td>A、B、C等节点构成树的结构。</td></tr><tr><td><strong>根节点（Root）</strong></td><td>树的顶层节点，无父节点。</td><td>树结构中的A节点。</td></tr><tr><td><strong>叶子节点（Leaf）</strong></td><td>度为0的节点，无子节点。</td><td>B、C等末端节点。</td></tr><tr><td><strong>父节点（Parent）</strong></td><td>有子节点的节点。</td><td>A是B的父节点。</td></tr><tr><td><strong>子节点（Child）</strong></td><td>直接连接到父节点的节点。</td><td>B是A的子节点。</td></tr><tr><td><strong>度（Degree）</strong></td><td>节点的子节点数目；树的度是所有节点度的最大值。</td><td>A的度为3，树的度为3。</td></tr><tr><td><strong>层次（Level）</strong></td><td>根为第1层，子节点逐层递增。</td><td>A为1层，B为2层。</td></tr><tr><td><strong>高度（Height）</strong></td><td>根节点到最远叶子节点的路径长度（边数+1）。</td><td>树的高度为4层。</td></tr></tbody></table><hr><h4 id="树的分类" tabindex="-1"><a class="header-anchor" href="#树的分类"><span><strong>树的分类</strong></span></a></h4><p><strong>按节点分支数量分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>二叉树</strong></td><td>每个节点最多2个子节点（左、右）。</td><td>表达式求值、搜索、编译器语法分析</td></tr><tr><td><strong>多叉树</strong></td><td>节点可有任意子节点数。</td><td>文件系统、组织架构表示</td></tr><tr><td><strong>满二叉树</strong></td><td>所有非叶子节点都有2个子节点，且叶子节点在同一层。</td><td>完全对称的树结构</td></tr><tr><td><strong>完全二叉树</strong></td><td>除最后一层外，其他层满；最后一层从左到右填充。</td><td>堆结构实现</td></tr><tr><td><strong>平衡二叉树</strong></td><td>任意节点的左右子树高度差≤1（如AVL树、红黑树）。</td><td>动态数据高效查询</td></tr><tr><td><strong>B/B+树</strong></td><td>多路平衡树，每个节点存储多个键，适合磁盘存储。</td><td>数据库索引（如MySQL）</td></tr></tbody></table><hr><p><strong>按结构特性分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>二叉搜索树（BST）</strong></td><td>左子树值 &lt; 根值 &lt; 右子树值，中序遍历有序。</td><td>快速查找、插入、删除操作</td></tr><tr><td><strong>哈夫曼树</strong></td><td>权值大的节点离根近，用于最优编码（如数据压缩）。</td><td>Huffman编码算法</td></tr><tr><td><strong>线索二叉树</strong></td><td>在空闲指针域存储前驱/后继节点，支持非递归遍历。</td><td>遍历优化</td></tr></tbody></table><hr><h4 id="树的存储结构" tabindex="-1"><a class="header-anchor" href="#树的存储结构"><span><strong>树的存储结构</strong></span></a></h4><p><strong>常见存储方式</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>结构</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>双亲表示法</strong></td><td>每个节点存储父节点索引，便于查找父节点。</td><td>父节点访问频繁的场景</td></tr><tr><td><strong>孩子表示法</strong></td><td>每个节点的孩子构成链表，便于遍历子树。</td><td>子树操作频繁的场景</td></tr><tr><td><strong>孩子兄弟表示法</strong></td><td>每个节点保存第一个孩子和下一个兄弟的指针，支持多叉树转换为二叉树。</td><td>多叉树的二叉化存储</td></tr><tr><td><strong>顺序存储（数组）</strong></td><td>仅适用于完全二叉树，通过下标计算父子关系（父节点<code>i</code>，左子<code>2i+1</code>，右子<code>2i+2</code>）。</td><td>完全二叉树的高效索引访问</td></tr><tr><td><strong>链式存储</strong></td><td>每个节点包含数据和子节点指针，灵活支持任意树结构。</td><td>动态树结构（如AVL树）</td></tr></tbody></table><hr><h4 id="树的遍历方法" tabindex="-1"><a class="header-anchor" href="#树的遍历方法"><span>树的遍历方法</span></a></h4><p><strong>1. 遍历类型与实现</strong></p><table><thead><tr><th><strong>遍历方式</strong></th><th><strong>规则</strong></th><th><strong>示例（根A，左B右C）</strong></th></tr></thead><tbody><tr><td><strong>前序遍历（根→左→右）</strong></td><td>访问根，遍历左子树，遍历右子树。</td><td>A → B → C</td></tr><tr><td><strong>中序遍历（左→根→右）</strong></td><td>遍历左子树，访问根，遍历右子树。</td><td>B → A → C</td></tr><tr><td><strong>后序遍历（左→右→根）</strong></td><td>遍历左子树，遍历右子树，访问根。</td><td>B → C → A</td></tr><tr><td><strong>层次遍历（广度优先）</strong></td><td>按层次从上到下、从左到右访问。</td><td>A → B → C → D → E → F → G</td></tr></tbody></table><p><strong>2. 遍历应用</strong></p><ul><li><strong>前序</strong>：复制树结构、表达式生成。</li><li><strong>中序</strong>：二叉搜索树的有序输出。</li><li><strong>后序</strong>：释放树资源、表达式求值。</li><li><strong>层次遍历</strong>：文件系统目录遍历。</li></ul><hr><h4 id="关键性质与公式" tabindex="-1"><a class="header-anchor" href="#关键性质与公式"><span><strong>关键性质与公式</strong></span></a></h4><ol><li><strong>节点数与边数</strong>： <ul><li>树有N个节点，则边数为 <strong>N-1</strong>。</li></ul></li><li><strong>完全二叉树性质</strong>： <ul><li>若高度为h，则节点数范围：<code>2^(h-1) ≤ N ≤ 2^h -1</code>。</li></ul></li><li><strong>二叉树遍历唯一性</strong>： <ul><li>前序+中序可唯一确定树结构；</li><li>后序+中序可唯一确定树结构；</li><li>前序+后序无法唯一确定（除非是满二叉树）。</li></ul></li></ol><hr><h4 id="高频考点与典型题型" tabindex="-1"><a class="header-anchor" href="#高频考点与典型题型"><span><strong>高频考点与典型题型</strong></span></a></h4><p><strong>1. 树的度与高度计算</strong></p><ul><li><strong>例题</strong>：某树的度为3，有9个叶子节点，5个度为2的节点，求度为3的节点数。<br><strong>答案</strong>：<br> 设度为3的节点数为x，根据公式：<br><code>叶子 = 1 + 2×度2节点 + 3×度3节点</code> → <code>9 = 1 + 2×5 + 3x</code> → x=2。</li></ul><p><strong>2. 二叉树性质应用</strong></p><ul><li><strong>例题</strong>：一棵完全二叉树有100个节点，求其高度。<br><strong>答案</strong>：<br> 完全二叉树高度h满足：<code>2^(h-1) ≤ 100 ≤ 2^h -1</code> → h=7（2<sup>6=64，2</sup>7-1=127）。</li></ul><p><strong>3. 遍历序列还原树结构</strong></p><ul><li><strong>例题</strong>：已知前序序列<code>A B D E C F</code>，中序序列<code>D B E A F C</code>，画出二叉树。<br><strong>步骤</strong>： <ol><li>前序首节点A为根；</li><li>中序中A左边为左子树（D B E），右边为右子树（F C）；</li><li>递归构造左右子树。</li></ol></li></ul><hr><h4 id="常见易错点与陷阱" tabindex="-1"><a class="header-anchor" href="#常见易错点与陷阱"><span><strong>常见易错点与陷阱</strong></span></a></h4><ol><li><strong>树与森林的区别</strong>： <ul><li><strong>森林</strong>：m棵互不相交的树的集合。</li></ul></li><li><strong>完全二叉树与满二叉树混淆</strong>： <ul><li>满二叉树一定是完全二叉树，但反之不成立。</li></ul></li><li><strong>树的存储结构选择</strong>： <ul><li>顺序存储仅适用于完全二叉树，动态结构优先链式存储。</li></ul></li><li><strong>遍历顺序混淆</strong>： <ul><li>中序遍历需先访问左子树，再根，再右子树（易与前序混淆）。</li></ul></li></ol><hr><h4 id="总结对比表" tabindex="-1"><a class="header-anchor" href="#总结对比表"><span><strong>总结对比表</strong></span></a></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>树</strong></th><th><strong>二叉树</strong></th><th><strong>完全二叉树</strong></th></tr></thead><tbody><tr><td><strong>节点限制</strong></td><td>无限制</td><td>≤2个子节点</td><td>必须完全填充除最后一层外的层</td></tr><tr><td><strong>存储方式</strong></td><td>链式/孩子兄弟表示法</td><td>链式/顺序存储（完全二叉树适用）</td><td>顺序存储最优</td></tr><tr><td><strong>遍历方法</strong></td><td>前序、中序、后序、层次</td><td>前序、中序、后序、层次</td><td>层次遍历最常用</td></tr><tr><td><strong>典型应用</strong></td><td>文件系统、组织架构</td><td>表达式求值、编译器语法分析</td><td>堆结构、优先队列</td></tr></tbody></table><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h3><p>以下是关于**图（Graph Theory）**的核心知识点整理，结合知识库内容，以清晰的结构化形式呈现，涵盖定义、分类、术语、性质、算法及应用：</p><hr><h4 id="图的基本定义" tabindex="-1"><a class="header-anchor" href="#图的基本定义"><span><strong>图的基本定义</strong></span></a></h4><p><strong>1. 定义</strong></p><ul><li><strong>图（Graph）</strong>：<br> 由**顶点集合（V）<strong>和</strong>边集合（E）**组成，记为 ( G = (V, E) )。 <ul><li><strong>顶点（Vertex/Node）</strong>：图的基本单元，表示实体或对象。</li><li><strong>边（Edge）</strong>：连接两个顶点的线段，表示顶点之间的关系。</li><li><strong>有向边（Arc）</strong>：具有方向的边（如 ( u \rightarrow v )）。</li><li><strong>无向边（Edge）</strong>：无方向的边（如 ( (u, v) )）。</li></ul></li></ul><hr><h4 id="图的分类" tabindex="-1"><a class="header-anchor" href="#图的分类"><span><strong>图的分类</strong></span></a></h4><p><strong>1. 按边的方向分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>无向图</strong></td><td>边无方向，边是顶点的无序对（如 ( (u, v) = (v, u) )）。</td><td>社交网络中的朋友关系</td></tr><tr><td><strong>有向图（DAG）</strong></td><td>边有方向，边是顶点的有序对（如 ( u \rightarrow v )）。</td><td>交通网络中的单向道路</td></tr></tbody></table><p><strong>2. 按边的特性分类</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>简单图</strong></td><td>无自环（顶点到自身的边）和多重边（连接同一对顶点的多条边）。</td><td>无向图中的完全图</td></tr><tr><td><strong>多重图</strong></td><td>允许自环或多重边。</td><td>交通网络中的多条并行道路</td></tr><tr><td><strong>有向无环图（DAG）</strong></td><td>有向且无环的图。</td><td>任务调度中的依赖关系</td></tr></tbody></table><hr><h4 id="核心术语与性质" tabindex="-1"><a class="header-anchor" href="#核心术语与性质"><span><strong>核心术语与性质</strong></span></a></h4><p><strong>1. 度（Degree）</strong></p><ul><li><strong>无向图</strong>： <ul><li><strong>顶点的度</strong>：与顶点关联的边的数量。</li><li><strong>握手定理</strong>：所有顶点的度数之和等于边数的<strong>2倍</strong>。</li></ul></li><li><strong>有向图</strong>： <ul><li><strong>入度（In-degree）</strong>：指向顶点的边数。</li><li><strong>出度（Out-degree）</strong>：从顶点出发的边数。</li><li><strong>度数关系</strong>：所有顶点的入度之和等于出度之和，且等于边数。</li></ul></li></ul><p><strong>2. 连通性</strong></p><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>连通图（无向）</strong></td><td>图中任意两顶点间存在路径。</td><td>互联网中的节点连接</td></tr><tr><td><strong>连通分量</strong></td><td>无向图的极大连通子图（最大可能的连通子图）。</td><td>非连通图中的独立子图</td></tr><tr><td><strong>强连通图（有向）</strong></td><td>图中任意两顶点间存在<strong>双向路径</strong>。</td><td>环形交通网络</td></tr><tr><td><strong>强连通分量</strong></td><td>有向图的极大强连通子图。</td><td>社交网络中的紧密社群</td></tr></tbody></table><p><strong>3. 其他关键术语</strong></p><table><thead><tr><th><strong>术语</strong></th><th><strong>定义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>路径（Path）</strong></td><td>顶点序列 ( v_1, v_2, ..., v_n )，使得每对相邻顶点间有边。</td><td>从A到B的路线</td></tr><tr><td><strong>环（Cycle）</strong></td><td>起点和终点相同的路径，且除起点外无重复顶点。</td><td>三角形结构中的闭合路径</td></tr><tr><td><strong>自环（Loop）</strong></td><td>顶点到自身的边。</td><td>顶点A到自身的边</td></tr><tr><td><strong>子图（Subgraph）</strong></td><td>顶点集和边集均为原图子集的图。</td><td>删除部分边后的简化图</td></tr><tr><td><strong>生成子图</strong></td><td>包含原图所有顶点的子图。</td><td>连通图的生成树</td></tr></tbody></table><hr><h4 id="图的存储结构" tabindex="-1"><a class="header-anchor" href="#图的存储结构"><span><strong>图的存储结构</strong></span></a></h4><p><strong>常见存储方式</strong></p><table><thead><tr><th><strong>类型</strong></th><th><strong>结构</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>邻接矩阵</strong></td><td>二维数组 ( G[n][n] )，( G[i][j] = 1 ) 表示边 ( i \rightarrow j )。</td><td>小规模图、稠密图（边数多）</td></tr><tr><td><strong>邻接表</strong></td><td>每个顶点对应一个链表，存储其邻接顶点。</td><td>大规模图、稀疏图（边数少）</td></tr><tr><td><strong>邻接表（带权）</strong></td><td>链表节点存储邻接顶点及边权值。</td><td>赋权图（如最短路径问题）</td></tr><tr><td><strong>边集数组</strong></td><td>保存所有边的列表，按顶点或边权排序。</td><td>简单图操作（如最小生成树）</td></tr></tbody></table><hr><h4 id="图的遍历算法" tabindex="-1"><a class="header-anchor" href="#图的遍历算法"><span><strong>图的遍历算法</strong></span></a></h4><p><strong>常见遍历方法</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>规则</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td><strong>深度优先搜索（DFS）</strong></td><td>沿路径尽可能深访问，直到无法继续，再回溯。</td><td>( O(V + E) )</td></tr><tr><td><strong>广度优先搜索（BFS）</strong></td><td>逐层扩展访问，按距离起点的远近顺序探索。</td><td>( O(V + E) )</td></tr></tbody></table><p><strong>2. 遍历应用</strong></p><ul><li><strong>DFS</strong>：检测图的连通性、寻找路径、拓扑排序（DAG）。</li><li><strong>BFS</strong>：求最短路径（无权图）、层次遍历、二分图检测。</li></ul><hr><h4 id="关键性质与公式-1" tabindex="-1"><a class="header-anchor" href="#关键性质与公式-1"><span><strong>关键性质与公式</strong></span></a></h4><p><strong>完全图的边数</strong>：</p><ul><li>无向完全图：( \frac{n(n-1)}{2} ) 条边。</li><li>有向完全图：( n(n-1) ) 条边。</li></ul><p><strong>连通分量数量</strong>：</p><ul><li>无向图至多有 ( n ) 个连通分量（每个顶点独立）。</li></ul><ol><li><strong>欧拉定理</strong>： <ul><li>无向图存在欧拉回路的充要条件：所有顶点度数为偶数。</li></ul></li></ol><hr><h4 id="高频考点与典型题型-1" tabindex="-1"><a class="header-anchor" href="#高频考点与典型题型-1"><span><strong>高频考点与典型题型</strong></span></a></h4><p><strong>1. 度数计算</strong></p><ul><li><strong>例题</strong>：一个有向图有5个顶点，入度之和为8，求边数。<br><strong>答案</strong>：边数等于入度之和，即 <strong>8条</strong>。</li></ul><p><strong>2. 连通性判断</strong></p><ul><li><strong>例题</strong>：判断下图是否为强连通图。<br><strong>步骤</strong>： <ol><li>检查每对顶点是否存在双向路径；</li><li>若存在，则为强连通图。</li></ol></li></ul><p><strong>3. 最小生成树（MST）</strong></p><ul><li><strong>算法</strong>： <ul><li><strong>Kruskal算法</strong>：按边权从小到大选择，避免形成环。</li><li><strong>Prim算法</strong>：从单个顶点出发，逐步扩展最小边。</li></ul></li></ul><hr><h4 id="经典问题与应用" tabindex="-1"><a class="header-anchor" href="#经典问题与应用"><span><strong>经典问题与应用</strong></span></a></h4><p><strong>1. 典型问题</strong></p><table><thead><tr><th><strong>问题</strong></th><th><strong>描述</strong></th><th><strong>算法</strong></th></tr></thead><tbody><tr><td><strong>最短路径</strong></td><td>求两点间权值最小的路径。</td><td>Dijkstra、Floyd、Bellman-Ford</td></tr><tr><td><strong>拓扑排序</strong></td><td>对DAG进行线性排序，确保所有前驱在后继之前。</td><td>Kahn算法（BFS）、DFS</td></tr><tr><td><strong>旅行商问题（TSP）</strong></td><td>寻找访问所有顶点并返回起点的最短回路。</td><td>动态规划（NP难，近似算法）</td></tr></tbody></table><p><strong>2. 实际应用</strong></p><ul><li><strong>社交网络分析</strong>：通过图模型分析用户关系、社区发现。</li><li><strong>物流路径规划</strong>：利用最短路径算法优化运输路线。</li><li><strong>网页排名（PageRank）</strong>：基于有向图的节点重要性计算。</li></ul><hr><h4 id="常见易错点与陷阱-1" tabindex="-1"><a class="header-anchor" href="#常见易错点与陷阱-1"><span><strong>常见易错点与陷阱</strong></span></a></h4><ol><li><strong>连通分量与强连通分量混淆</strong>： <ul><li>连通分量针对无向图，强连通分量针对有向图。</li></ul></li><li><strong>度数计算错误</strong>： <ul><li>有向图中，顶点的度数是入度与出度之和。</li></ul></li><li><strong>生成树误解</strong>： <ul><li>连通图的生成树必须包含所有顶点且无环。</li></ul></li><li><strong>欧拉回路条件误判</strong>： <ul><li>必须所有顶点度数为偶数，且图连通。</li></ul></li></ol><hr><h4 id="总结对比表-1" tabindex="-1"><a class="header-anchor" href="#总结对比表-1"><span><strong>总结对比表</strong></span></a></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>无向图</strong></th><th><strong>有向图</strong></th></tr></thead><tbody><tr><td><strong>边</strong></td><td>无方向</td><td>有方向</td></tr><tr><td><strong>连通性</strong></td><td>连通图/连通分量</td><td>强连通图/强连通分量</td></tr><tr><td><strong>度数</strong></td><td>顶点关联边的数量</td><td>入度（in-degree）和出度（out-degree）</td></tr><tr><td><strong>完全图边数</strong></td><td>( \frac{n(n-1)}{2} )</td><td>( n(n-1) )</td></tr><tr><td><strong>典型应用</strong></td><td>社交网络、电路设计</td><td>任务调度、网页链接分析</td></tr></tbody></table><h3 id="算法" tabindex="-1"><a class="header-anchor" href="#算法"><span>算法</span></a></h3><h4 id="贪心算法-greedy-algorithm" tabindex="-1"><a class="header-anchor" href="#贪心算法-greedy-algorithm"><span><strong>贪心算法（Greedy Algorithm）</strong></span></a></h4><p><strong>核心思想</strong>： 在每一步决策中选择当前最优（局部最优），从而希望导致全局最优解。不考虑后续可能的影响，依赖问题的贪心选择性质（局部最优可推导全局最优）。</p><p><strong>工作流程</strong>：</p><ol><li>确定贪心策略（如按权重、时间、代价排序）；</li><li>按策略依次选择当前最优选项，确保不违反约束条件；</li><li>直至问题求解完成。</li></ol><p><strong>优点</strong>：</p><ul><li>实现简单，效率较高（常结合排序，复杂度多为 <em>O</em>(<em>n</em>log<em>n</em>)）；</li><li>适用于具备贪心选择性质的问题（如活动选择、最小生成树）。</li></ul><p><strong>缺点</strong>：</p><ul><li>无法保证所有问题的全局最优（如 0-1 背包问题，贪心可能失效）；</li><li>需严格证明策略的正确性。</li></ul><p><strong>经典案例</strong>：</p><ul><li>活动选择问题（选择不冲突的最多活动，按结束时间排序）；</li><li>Dijkstra 最短路径算法（非负权图，每次选当前最短距离节点）；</li><li>Kruskal/Prim 最小生成树算法（贪心选最小边或最近顶点）。</li></ul><h4 id="动态规划-dynamic-programming-dp" tabindex="-1"><a class="header-anchor" href="#动态规划-dynamic-programming-dp"><span><strong>动态规划（Dynamic Programming, DP）</strong></span></a></h4><p><strong>核心思想</strong>： 将复杂问题分解为重叠子问题，用表格（DP 表）存储子问题的解，避免重复计算，通过状态转移方程推导最终解。</p><p><strong>工作流程</strong>：</p><ol><li>定义状态（如 <em>d**p</em>[<em>i</em>] 表示前 <em>i</em> 个物品的最优解）；</li><li>推导状态转移方程（如 <em>d**p</em>[<em>i</em>]=max(<em>d**p</em>[<em>i</em>−1],<em>d**p</em>[<em>i</em>−<em>w</em>]+<em>v</em>)）；</li><li>填充 DP 表，处理边界条件。</li></ol><p><strong>优点</strong>：</p><ul><li>高效解决指数级复杂度问题（如 0-1 背包，暴力枚举为 <em>O</em>(2<em>n</em>)，DP 为 <em>O</em>(<em>nV</em>)）；</li><li>适用于具备最优子结构和重叠子问题的场景。</li></ul><p><strong>缺点</strong>：</p><ul><li>状态定义和转移方程推导较难（需抽象问题模型）；</li><li>空间复杂度可能较高（可通过滚动数组优化，如二维转一维）。</li></ul><p><strong>经典案例</strong>：</p><ul><li>0-1 背包问题（最大化价值，重量不超过容量）；</li><li>最长公共子序列（LCS，字符串相似度分析）；</li><li>斐波那契数列（递归优化，避免重复计算）。</li></ul><h4 id="回溯算法-backtracking" tabindex="-1"><a class="header-anchor" href="#回溯算法-backtracking"><span><strong>回溯算法（Backtracking）</strong></span></a></h4><p><strong>核心思想</strong>： 通过深度优先搜索（DFS）遍历解空间树，逐步构建候选解，若发现当前路径无效（违反约束）则回溯，尝试其他分支。</p><p><strong>工作流程</strong>：</p><ol><li>定义解空间（如排列、子集、路径的可能形式）；</li><li>递归遍历解空间，每一步选择合法选项，记录路径；</li><li>若达到目标解则保存，否则回溯（剪枝）到上一层。</li></ol><p><strong>优点</strong>：</p><ul><li>适合求解组合型问题（排列、子集、路径搜索），可枚举所有合法解；</li><li>剪枝优化可大幅减少搜索空间。</li></ul><p><strong>缺点</strong>：</p><ul><li>最坏时间复杂度高（指数级 <em>O</em>(2<em>n</em>) 或阶乘级 <em>O</em>(<em>n</em>!)）；</li><li>需设计高效的剪枝条件（否则性能低下）。</li></ul><p><strong>经典案例</strong>：</p><ul><li>八皇后问题（在棋盘上放置 8 个皇后，互不攻击）；</li><li>子集和问题（判断是否存在子集和为目标值）；</li><li>迷宫寻路（寻找从起点到终点的所有路径）。</li></ul><h4 id="分治算法-divide-and-conquer" tabindex="-1"><a class="header-anchor" href="#分治算法-divide-and-conquer"><span><strong>分治算法（Divide and Conquer）</strong></span></a></h4><p><strong>核心思想</strong>： 将问题分解为若干规模更小、结构相同的子问题，递归求解子问题，再合并子解得到原问题的解。</p><p><strong>工作流程</strong>：</p><ol><li><strong>分解</strong>：将原问题分成多个子问题；</li><li><strong>求解</strong>：递归求解每个子问题（直至子问题足够小可直接求解）；</li><li><strong>合并</strong>：将子问题的解合并为原问题的解。</li></ol><p><strong>优点</strong>：</p><ul><li>适合处理可分解为相似子问题的场景（如排序、搜索）；</li><li>可利用递归和并行计算优化效率（如归并排序的 O (n log n) 复杂度）。</li></ul><p><strong>缺点</strong>：</p><ul><li>子问题需独立（无重叠，否则动态规划更优）；</li><li>合并子解可能增加实现复杂度（如归并排序的合并步骤）。</li></ul><p><strong>经典案例</strong>：</p><ul><li>归并排序（分解数组，递归排序后合并）；</li><li>快速排序（选择基准值，分治处理左右子数组）；</li><li>二分查找（在有序数组中递归缩小区间）。</li></ul><h4 id="深度优先搜索-dfs-与广度优先搜索-bfs" tabindex="-1"><a class="header-anchor" href="#深度优先搜索-dfs-与广度优先搜索-bfs"><span><strong>深度优先搜索（DFS）与广度优先搜索（BFS）</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>DFS</strong></td><td>从起点出发，沿一条路径深入探索，直到无法继续则回溯，访问所有可达节点。</td><td>用栈（或递归）实现，优先访问深层节点，适合找单一路径或检测连通性。</td><td>图的连通性判断、强连通分量检测、回溯算法的基础。</td></tr><tr><td><strong>BFS</strong></td><td>从起点出发，按层遍历，优先访问距离起点近的节点（队列实现）。</td><td>用队列实现，适合求无权图的最短路径（层序遍历保证最短距离）。</td><td>无权图最短路径、层序遍历、社交网络最短距离计算。</td></tr></tbody></table><h4 id="kmp-算法" tabindex="-1"><a class="header-anchor" href="#kmp-算法"><span><strong>KMP 算法</strong></span></a></h4><p><strong>核心思想</strong>： 在字符串匹配中，利用预处理得到的<strong>部分匹配表</strong>（最长前缀后缀匹配长度），避免匹配失败时重复移动模式串，优化匹配效率。</p><p><strong>工作流程</strong>：</p><ol><li>预处理模式串，生成 next 数组（记录每个位置的最长前缀后缀长度）；</li><li>用 next 数组指导主串与模式串的匹配，失败时按 next 值跳转模式串指针。</li></ol><p><strong>优点</strong>：</p><ul><li>时间复杂度低（<em>O</em>(<em>n</em>+<em>m</em>)，n 为主串长度，m 为模式串长度）；</li><li>高效处理长文本匹配（如文本编辑器 “查找” 功能）。</li></ul><p><strong>缺点</strong>：</p><ul><li>仅适用于单模式串匹配（多模式串需 AC 自动机等算法）。</li></ul><p><strong>经典案例</strong>： 在 DNA 序列中查找特定子串、日志文件中的关键词匹配。</p><h4 id="最小生成树算法-prim-kruskal" tabindex="-1"><a class="header-anchor" href="#最小生成树算法-prim-kruskal"><span><strong>最小生成树算法（Prim/Kruskal）</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>数据结构</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Prim</strong></td><td>从顶点出发，每次选择离当前生成树最近的顶点（贪心），逐步扩展生成树。</td><td>邻接矩阵（稠密图，<em>O</em>(<em>V</em>2)）或优先队列（稀疏图，<em>O</em>(<em>E</em>log<em>V</em>)）。</td><td>稠密图（边数多）的最小生成树。</td></tr><tr><td><strong>Kruskal</strong></td><td>按边权从小到大排序，依次选择不构成环的边（并查集判环），直到生成树形成。</td><td>并查集（判环）+ 排序（<em>O</em>(<em>E</em>log<em>E</em>)）。</td><td>稀疏图（边数少）的最小生成树。</td></tr></tbody></table><h4 id="算法优缺点及实用案例对比表" tabindex="-1"><a class="header-anchor" href="#算法优缺点及实用案例对比表"><span><strong>算法优缺点及实用案例对比表</strong></span></a></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>核心思想</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>实用案例（软考高频）</strong></th></tr></thead><tbody><tr><td><strong>贪心算法</strong></td><td>局部最优推导全局最优</td><td>实现简单、效率高（常结合排序）</td><td>不保证全局最优（依赖问题性质）、需证明策略正确性</td><td>活动选择、Dijkstra 最短路径、Prim/Kruskal 生成树</td></tr><tr><td><strong>动态规划</strong></td><td>存储子问题解，避免重复计算</td><td>解决指数级复杂度问题、适用于重叠子问题和最优子结构</td><td>状态定义难、空间复杂度可能高（需优化）</td><td>0-1 背包、LCS、斐波那契数列优化</td></tr><tr><td><strong>回溯算法</strong></td><td>深度优先搜索解空间树，剪枝无效路径</td><td>适合组合问题、枚举所有合法解</td><td>最坏复杂度高（指数级）、依赖剪枝效率</td><td>八皇后、子集和、迷宫寻路</td></tr><tr><td><strong>分治算法</strong></td><td>分解子问题，递归求解后合并</td><td>高效处理可分解的相似子问题（如排序、搜索）</td><td>子问题需独立（无重叠）、合并步骤可能复杂</td><td>归并排序、快速排序、二分查找</td></tr><tr><td><strong>DFS</strong></td><td>深度优先遍历图或解空间</td><td>找单一路径、检测连通性</td><td>无法保证最短路径（适用于无权图）</td><td>图的连通性检测、回溯算法基础</td></tr><tr><td><strong>BFS</strong></td><td>广度优先按层遍历图</td><td>求无权图最短路径、层序遍历</td><td>空间复杂度高（需维护队列）</td><td>无权图最短路径、二叉树层序遍历</td></tr><tr><td><strong>KMP 算法</strong></td><td>利用部分匹配表优化字符串匹配</td><td>线性时间复杂度（O (n+m)）、高效长文本匹配</td><td>仅适用于单模式串匹配</td><td>DNA 序列子串查找、日志关键词匹配</td></tr><tr><td><strong>Prim 算法</strong></td><td>贪心选择最近顶点构建最小生成树</td><td>适合稠密图（邻接矩阵实现高效）</td><td>需维护顶点距离数组</td><td>电网布线（最小权重生成树）</td></tr><tr><td><strong>Kruskal 算法</strong></td><td>贪心选择最小边，并查集判环</td><td>适合稀疏图（排序和并查集高效）</td><td>需排序边集</td><td>通信网络最小成本架构设计</td></tr></tbody></table><h4 id="核心对比总结" tabindex="-1"><a class="header-anchor" href="#核心对比总结"><span><strong>核心对比总结</strong></span></a></h4><ol><li><strong>贪心 vs 动态规划</strong>： <ul><li>贪心：局部最优，无后效性（不考虑后续状态），依赖问题的贪心选择性质。</li><li>动态规划：全局最优，需考虑状态转移，处理重叠子问题和后效性（如 0-1 背包的 “选或不选” 影响后续容量）。</li></ul></li><li><strong>DFS vs BFS</strong>： <ul><li>DFS 适合找单一路径或检测连通性，用递归 / 栈实现；</li><li>BFS 适合求无权图最短路径，用队列实现，按层扩展。</li></ul></li><li><strong>Prim vs Kruskal</strong>： <ul><li>Prim 以顶点为中心，适合稠密图（邻接矩阵）；</li><li>Kruskal 以边为中心，适合稀疏图（排序 + 并查集）。</li></ul></li></ol><h2 id="标准化和知识产权" tabindex="-1"><a class="header-anchor" href="#标准化和知识产权"><span>标准化和知识产权</span></a></h2><p><strong>标准化组织对比表</strong></p><table><thead><tr><th>组织名称</th><th>性质</th><th>代表标准 / 领域</th><th>备注</th></tr></thead><tbody><tr><td><strong>ISO</strong></td><td>国际标准化组织</td><td>ISO 9000（质量）、ISO 27001（信息安全）</td><td>全球通用，促进国际间技术协调</td></tr><tr><td><strong>IEEE</strong></td><td>美国电气电子工程师协会</td><td>IEEE 802（局域网）、IEEE 754（浮点数）</td><td>侧重电气、电子及计算机工程领域标准</td></tr><tr><td><strong>CMMI</strong></td><td>过程改进模型</td><td>CMMI-DEV（软件开发成熟度）</td><td>评估企业软件开发过程成熟度</td></tr><tr><td><strong>GB</strong></td><td>中国国家标准</td><td>GB（强制性）、GB/T（推荐性）</td><td>国内通用，如 GB 18030（汉字编码）</td></tr><tr><td><strong>行业标准</strong></td><td>特定行业规范</td><td>YD（通信）、GA（公安）、SJ（电子）</td><td>在行业内强制或推荐使用</td></tr></tbody></table><h3 id="标准分类表" tabindex="-1"><a class="header-anchor" href="#标准分类表"><span>标准分类表</span></a></h3><h4 id="按适用范围分类" tabindex="-1"><a class="header-anchor" href="#按适用范围分类"><span>按适用范围分类</span></a></h4><table><thead><tr><th>分类</th><th>定义</th><th>示例</th></tr></thead><tbody><tr><td>国际标准</td><td>国际组织发布，全球适用</td><td>ISO、IEC 标准</td></tr><tr><td>国家标准</td><td>国家主管机构发布，全国适用</td><td>GB（中国）、ANSI（美国）</td></tr><tr><td>行业标准</td><td>行业协会发布，特定行业内适用</td><td>YD（通信）、IEEE 标准</td></tr><tr><td>企业标准</td><td>企业自行制定，内部适用</td><td>某公司技术规范</td></tr></tbody></table><h4 id="按性质分类" tabindex="-1"><a class="header-anchor" href="#按性质分类"><span>按性质分类</span></a></h4><table><thead><tr><th>分类</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>强制性标准</td><td>法律强制遵守，违规禁止生产 / 销售</td><td>GB（不带 / T 后缀）</td></tr><tr><td>推荐性标准</td><td>自愿采用，以 “/T” 标识</td><td>GB/T、ISO/IEC 指南</td></tr></tbody></table><h3 id="知识产权核心考点" tabindex="-1"><a class="header-anchor" href="#知识产权核心考点"><span>知识产权核心考点</span></a></h3><h4 id="知识产权保护期限表" tabindex="-1"><a class="header-anchor" href="#知识产权保护期限表"><span>知识产权保护期限表</span></a></h4><table><thead><tr><th>客体类型</th><th>权利类型</th><th>保护期限</th><th>特殊说明</th></tr></thead><tbody><tr><td><strong>软件著作权</strong></td><td>署名权、修改权</td><td>永久</td><td>公民作品归个人，职务作品归单位</td></tr><tr><td></td><td>发表权、使用权</td><td>公民：终生 + 死后 50 年；单位：首次发表后 50 年</td><td>合作开发以最后死亡作者为准</td></tr><tr><td><strong>专利权</strong></td><td>发明专利权</td><td>20 年（自申请日起）</td><td>需每年缴纳年费</td></tr><tr><td></td><td>实用新型 / 外观设计</td><td>10 年（自申请日起）</td><td></td></tr><tr><td><strong>商标权</strong></td><td>注册商标权</td><td>10 年（可无限续展，续展期 6 个月）</td><td>未续展则注销</td></tr><tr><td><strong>商业秘密</strong></td><td>技术 / 经营信息</td><td>未公开则永久有效</td><td>公开后丧失保护</td></tr></tbody></table><h4 id="知识产权归属判定表" tabindex="-1"><a class="header-anchor" href="#知识产权归属判定表"><span>知识产权归属判定表</span></a></h4><table><thead><tr><th>场景</th><th>归属原则</th><th>示例说明</th></tr></thead><tbody><tr><td><strong>职务作品</strong></td><td>单位享有著作权（除署名权）</td><td>员工在本职工作中开发的软件</td></tr><tr><td><strong>委托开发</strong></td><td>有合同按合同，无合同归受托人</td><td>甲委托乙开发软件，未约定则乙拥有</td></tr><tr><td><strong>合作开发</strong></td><td>共同享有，可分割成果可单独申请</td><td>甲乙合作开发，成果可拆分则各自申请</td></tr><tr><td><strong>商标 / 专利申请</strong></td><td>先申请原则，同时申请协商或抽签</td><td>甲乙同日申请，协商不成则抽签</td></tr></tbody></table><h3 id="常考例题汇总" tabindex="-1"><a class="header-anchor" href="#常考例题汇总"><span>常考例题汇总</span></a></h3><h4 id="标准化知识例题" tabindex="-1"><a class="header-anchor" href="#标准化知识例题"><span>标准化知识例题</span></a></h4><ol><li><strong>题目</strong>：以下属于推荐性国家标准的是（ ） A. GB 18030 B. YD/T 1234 C. GB/T 2312 D. ISO 9001 <strong>答案</strong>：C <strong>解析</strong>：GB/T 是推荐性国家标准标识，GB 为强制性，YD/T 是通信行业推荐标准，ISO 是国际标准。</li><li><strong>题目</strong>：IEEE 802.11 属于（ ） A. 国际标准 B. 行业标准 C. 企业标准 D. 地方标准 <strong>答案</strong>：B <strong>解析</strong>：IEEE 是美国电气电子工程师协会制定的行业标准，专注于局域网技术。</li></ol><h4 id="知识产权知识例题" tabindex="-1"><a class="header-anchor" href="#知识产权知识例题"><span>知识产权知识例题</span></a></h4><ol><li><strong>题目</strong>：某公司员工在业余时间开发的软件，著作权归（ ） A. 公司 B. 员工个人 C. 公司与员工共有 D. 无归属 <strong>答案</strong>：B <strong>解析</strong>：非职务作品（业余时间、未用公司资源）著作权归个人所有。</li><li><strong>题目</strong>：发明专利的保护期限是（ ） A. 10 年 B. 15 年 C. 20 年 D. 50 年 <strong>答案</strong>：C <strong>解析</strong>：发明专利权保护期自申请日起 20 年，实用新型和外观设计为 10 年。</li><li><strong>题目</strong>：甲委托乙开发软件，未约定著作权归属，该软件著作权归（ ） A. 甲 B. 乙 C. 甲乙共有 D. 国家所有 <strong>答案</strong>：B <strong>解析</strong>：委托开发未约定时，著作权归受托人（乙）所有。</li><li><strong>题目</strong>：以下属于侵犯软件著作权的行为是（ ） A. 购买正版后安装到公司 3 台电脑 B. 修改正版软件后自用 C. 备份正版软件到硬盘 D. 转让正版软件许可给他人 <strong>答案</strong>：D <strong>解析</strong>：转让软件许可需著作权人授权，个人安装、备份属于合理使用，修改后自用若未传播不侵权（具体视软件许可协议）。</li></ol><h2 id="专业英语" tabindex="-1"><a class="header-anchor" href="#专业英语"><span>专业英语</span></a></h2><table><thead><tr><th>英文</th><th style="text-align:left;">中文</th></tr></thead><tbody><tr><td>Abstract</td><td style="text-align:left;">摘要；抽象的</td></tr><tr><td>Abstraction</td><td style="text-align:left;">抽象</td></tr><tr><td>Access</td><td style="text-align:left;">访问</td></tr><tr><td>Accessibility</td><td style="text-align:left;">无障碍；辅助功能 (win/mac)</td></tr><tr><td>Activate, Activation</td><td style="text-align:left;">激活</td></tr><tr><td>Active</td><td style="text-align:left;">使用中的；现用的；有效的；激活的</td></tr><tr><td>Adapter, Adaptor</td><td style="text-align:left;">适配卡，适配器</td></tr><tr><td>Add</td><td style="text-align:left;">添加</td></tr><tr><td>Address</td><td style="text-align:left;">位址，地址</td></tr><tr><td>Advanced</td><td style="text-align:left;">高级的</td></tr><tr><td>Aggregation</td><td style="text-align:left;">聚合</td></tr><tr><td>AI (Artificial intelligence)</td><td style="text-align:left;">人工智能</td></tr><tr><td>Algorithm</td><td style="text-align:left;">算法</td></tr><tr><td>Allocate</td><td style="text-align:left;">分配</td></tr><tr><td>Allocator</td><td style="text-align:left;">分配器</td></tr><tr><td>Annotation</td><td style="text-align:left;">注释 (win)；注解 (mac)</td></tr><tr><td>App bundle</td><td style="text-align:left;">应用程序包 (win)；App 捆绑包 (mac)</td></tr><tr><td>Application</td><td style="text-align:left;">应用；应用程序</td></tr><tr><td>Apply</td><td style="text-align:left;">应用</td></tr><tr><td>Architecture</td><td style="text-align:left;">架构；结构</td></tr><tr><td>Argument</td><td style="text-align:left;">参数（也称为实际参数，实参）</td></tr><tr><td>Arity</td><td style="text-align:left;">参数数量</td></tr><tr><td>Artifact</td><td style="text-align:left;">项目 (win)；成品 (mac)</td></tr><tr><td>Array</td><td style="text-align:left;">数组</td></tr><tr><td>Assembly language</td><td style="text-align:left;">汇编语言</td></tr><tr><td>Assert, Assertion</td><td style="text-align:left;">断言 (win)；声明 (win/mac)；论断 (mac)</td></tr><tr><td>Assign, Assignment</td><td style="text-align:left;">分配；（编程）赋值</td></tr><tr><td>Assignment operator</td><td style="text-align:left;">赋值运算符</td></tr><tr><td>Asynchronize</td><td style="text-align:left;">异步</td></tr><tr><td>Asynchronous</td><td style="text-align:left;">异步的</td></tr><tr><td>Atomic</td><td style="text-align:left;">原子的</td></tr><tr><td>Attribute</td><td style="text-align:left;">属性</td></tr><tr><td>Audio</td><td style="text-align:left;">音频</td></tr><tr><td>Authenticate, Authentication</td><td style="text-align:left;">验证，认证</td></tr><tr><td>Authorize, Authorization</td><td style="text-align:left;">授权</td></tr><tr><td>Autoboxing</td><td style="text-align:left;">自动装箱</td></tr><tr><td>Background processes</td><td style="text-align:left;">后台进程</td></tr><tr><td>Bandwidth</td><td style="text-align:left;">带宽</td></tr><tr><td>Base class</td><td style="text-align:left;">基类</td></tr><tr><td>Batch</td><td style="text-align:left;">批（处理）</td></tr><tr><td>Binary function</td><td style="text-align:left;">二元函数</td></tr><tr><td>Binary operator</td><td style="text-align:left;">二元运算符</td></tr><tr><td>Binary search</td><td style="text-align:left;">二分查找</td></tr><tr><td>Binary tree</td><td style="text-align:left;">二叉树</td></tr><tr><td>Bind</td><td style="text-align:left;">绑定</td></tr><tr><td>Bit</td><td style="text-align:left;">位</td></tr><tr><td>Bitrate</td><td style="text-align:left;">码率</td></tr><tr><td>Block</td><td style="text-align:left;">屏蔽；阻止</td></tr><tr><td>Block</td><td style="text-align:left;">（代码）块</td></tr><tr><td>Blocker</td><td style="text-align:left;">阻止程序 (win)；拦截器 (mac)</td></tr><tr><td>Boolean</td><td style="text-align:left;">布尔</td></tr><tr><td>Bounce</td><td style="text-align:left;">退回；弹跳</td></tr><tr><td>Breakpoint</td><td style="text-align:left;">断点</td></tr><tr><td>Build (verb)</td><td style="text-align:left;">构建</td></tr><tr><td>Build (noun)</td><td style="text-align:left;">构件；版本（号）</td></tr><tr><td>Build-in</td><td style="text-align:left;">内置 (win)；内建 (mac)</td></tr><tr><td>Bundle (noun)</td><td style="text-align:left;">捆绑包</td></tr><tr><td>Bundle (verb)</td><td style="text-align:left;">整合</td></tr><tr><td>Bus</td><td style="text-align:left;">总线</td></tr><tr><td>Burn</td><td style="text-align:left;">刻录</td></tr><tr><td>Byte</td><td style="text-align:left;">字节</td></tr><tr><td>Cache</td><td style="text-align:left;">高速缓存，缓存</td></tr><tr><td>Call</td><td style="text-align:left;">调用</td></tr><tr><td>Callback</td><td style="text-align:left;">回调</td></tr><tr><td>Certificate</td><td style="text-align:left;">证书</td></tr><tr><td>Character</td><td style="text-align:left;">字符</td></tr><tr><td>Check</td><td style="text-align:left;">查看</td></tr><tr><td>Check box, Checkbox</td><td style="text-align:left;">复选框</td></tr><tr><td>Class</td><td style="text-align:left;">类</td></tr><tr><td>Point &amp; Click (noun)</td><td style="text-align:left;">点按</td></tr><tr><td>Click (vs. Tap)</td><td style="text-align:left;">点击 (win)；点按 (mac)</td></tr><tr><td>Tap (vs. Click)</td><td style="text-align:left;">触碰 (win)；轻点 (mac)</td></tr><tr><td>Client-side</td><td style="text-align:left;">客户端</td></tr><tr><td>Clipboard</td><td style="text-align:left;">剪贴板</td></tr><tr><td>Clone</td><td style="text-align:left;">克隆</td></tr><tr><td>Cloud computing</td><td style="text-align:left;">云计算</td></tr><tr><td>Cohesion</td><td style="text-align:left;">内聚</td></tr><tr><td>Collaborate, Collaboration</td><td style="text-align:left;">协作</td></tr><tr><td>Combo box</td><td style="text-align:left;">组合框</td></tr><tr><td>Come with</td><td style="text-align:left;">随附</td></tr><tr><td>Command</td><td style="text-align:left;">命令</td></tr><tr><td>Command line</td><td style="text-align:left;">命令行</td></tr><tr><td>Comment</td><td style="text-align:left;">评论</td></tr><tr><td>注解，注释</td><td style="text-align:left;"></td></tr><tr><td>Commit</td><td style="text-align:left;">提交</td></tr><tr><td>Communication</td><td style="text-align:left;">通信</td></tr><tr><td>Community</td><td style="text-align:left;">社区</td></tr><tr><td>Compatibility</td><td style="text-align:left;">兼容性</td></tr><tr><td>Compatible</td><td style="text-align:left;">兼容的</td></tr><tr><td>Compile, Compilation</td><td style="text-align:left;">编译</td></tr><tr><td>Compile time, Compile-time</td><td style="text-align:left;">编译期，编译时</td></tr><tr><td>Compiler</td><td style="text-align:left;">编译器</td></tr><tr><td>Component</td><td style="text-align:left;">组件</td></tr><tr><td>Composition</td><td style="text-align:left;">组合</td></tr><tr><td>Compress</td><td style="text-align:left;">压缩</td></tr><tr><td>Concurrency</td><td style="text-align:left;">并发性，并发</td></tr><tr><td>Concurrent</td><td style="text-align:left;">并发的；同时的</td></tr><tr><td>Configuration</td><td style="text-align:left;">配置</td></tr><tr><td>Connect, Connection</td><td style="text-align:left;">连接</td></tr><tr><td>Constant</td><td style="text-align:left;">常量</td></tr><tr><td>Constraint</td><td style="text-align:left;">约束；限制</td></tr><tr><td>Constructor</td><td style="text-align:left;">构造函数</td></tr><tr><td>Container</td><td style="text-align:left;">容器</td></tr><tr><td>Context</td><td style="text-align:left;">背景（关系）；环境；上下文；内容</td></tr><tr><td>Continuous delivery</td><td style="text-align:left;">持续交付</td></tr><tr><td>Continuous deployment</td><td style="text-align:left;">持续部署</td></tr><tr><td>Continuous integration</td><td style="text-align:left;">持续集成</td></tr><tr><td>Control</td><td style="text-align:left;">控件</td></tr><tr><td>Copy</td><td style="text-align:left;">复制 (win)；拷贝 (mac)</td></tr><tr><td>Coroutine</td><td style="text-align:left;">协程，协同程序</td></tr><tr><td>Coupling</td><td style="text-align:left;">耦合</td></tr><tr><td>Crash</td><td style="text-align:left;">崩溃 (win/mac)；故障 (win)</td></tr><tr><td>Create</td><td style="text-align:left;">创建</td></tr><tr><td>Cursor</td><td style="text-align:left;">光标</td></tr><tr><td>Custom</td><td style="text-align:left;">自定义</td></tr><tr><td>Data</td><td style="text-align:left;">数据</td></tr><tr><td>Data link layer</td><td style="text-align:left;">数据链路层</td></tr><tr><td>Data structure</td><td style="text-align:left;">数据结构</td></tr><tr><td>Database</td><td style="text-align:left;">数据库</td></tr><tr><td>Database schema</td><td style="text-align:left;">数据库架构，数据库模式</td></tr><tr><td>Deadlock</td><td style="text-align:left;">死锁</td></tr><tr><td>Debug</td><td style="text-align:left;">调试</td></tr><tr><td>Debugger</td><td style="text-align:left;">调试器</td></tr><tr><td>Declare, Declaration</td><td style="text-align:left;">声明</td></tr><tr><td>Default</td><td style="text-align:left;">默认</td></tr><tr><td>Definition</td><td style="text-align:left;">定义；清晰度</td></tr><tr><td>Delegate, Delegation</td><td style="text-align:left;">委托</td></tr><tr><td>Dependency</td><td style="text-align:left;">依赖</td></tr><tr><td>Derived class</td><td style="text-align:left;">派生类</td></tr><tr><td>Design pattern</td><td style="text-align:left;">设计模式</td></tr><tr><td>Destructor</td><td style="text-align:left;">析构函数</td></tr><tr><td>Detect, Detection</td><td style="text-align:left;">检测</td></tr><tr><td>Device</td><td style="text-align:left;">设备</td></tr><tr><td>Dialog</td><td style="text-align:left;">对话框</td></tr><tr><td>Digital</td><td style="text-align:left;">数字的；数字化</td></tr><tr><td>Digital signature</td><td style="text-align:left;">数字签名</td></tr><tr><td>Digital certificate</td><td style="text-align:left;">数字证书</td></tr><tr><td>Directory</td><td style="text-align:left;">目录</td></tr><tr><td>Disk</td><td style="text-align:left;">盘</td></tr><tr><td>Disk image</td><td style="text-align:left;">磁盘映像</td></tr><tr><td>Dispatch</td><td style="text-align:left;">分派；调度</td></tr><tr><td>Distributed</td><td style="text-align:left;">分布式</td></tr><tr><td>Distribute, Distribution</td><td style="text-align:left;">分发；分配；分布</td></tr><tr><td>Distribution</td><td style="text-align:left;">发行（版本）</td></tr><tr><td>Document</td><td style="text-align:left;">文档；文稿</td></tr><tr><td>Domain</td><td style="text-align:left;">域</td></tr><tr><td>Driver</td><td style="text-align:left;">驱动程序</td></tr><tr><td>Drop-down, Dropdown (noun)</td><td style="text-align:left;">下拉菜单</td></tr><tr><td>Drop-down, Dropdown (verb)</td><td style="text-align:left;">下拉</td></tr><tr><td>Drop-down menu</td><td style="text-align:left;">下拉菜单 (win/mac)</td></tr><tr><td>Drop-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Dynamic binding</td><td style="text-align:left;">动态绑定</td></tr><tr><td>Element</td><td style="text-align:left;">元素；元件</td></tr><tr><td>Email, E-mail</td><td style="text-align:left;">电子邮件</td></tr><tr><td>Enable</td><td style="text-align:left;">启用</td></tr><tr><td>Encapsulation</td><td style="text-align:left;">封装</td></tr><tr><td>Entity</td><td style="text-align:left;">实体</td></tr><tr><td>Enumeration</td><td style="text-align:left;">枚举</td></tr><tr><td>Equal</td><td style="text-align:left;">相等的</td></tr><tr><td>Equality</td><td style="text-align:left;">相等性，相等</td></tr><tr><td>Escape code</td><td style="text-align:left;">转义码</td></tr><tr><td>Event</td><td style="text-align:left;">事件</td></tr><tr><td>Exception</td><td style="text-align:left;">异常</td></tr><tr><td>Explicit</td><td style="text-align:left;">显式</td></tr><tr><td>Export</td><td style="text-align:left;">导出</td></tr><tr><td>Expression</td><td style="text-align:left;">表达式</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展（程序、功能）</td></tr><tr><td>Extension</td><td style="text-align:left;">扩展名</td></tr><tr><td>Feature</td><td style="text-align:left;">特色，特点</td></tr><tr><td>Feature (vs. Function)</td><td style="text-align:left;">（特殊的）功能</td></tr><tr><td>Feedback</td><td style="text-align:left;">反馈</td></tr><tr><td>Field</td><td style="text-align:left;">字段，栏位；域</td></tr><tr><td>File</td><td style="text-align:left;">文件</td></tr><tr><td>Filter</td><td style="text-align:left;">过滤器</td></tr><tr><td>Find</td><td style="text-align:left;">查找</td></tr><tr><td>Firmware</td><td style="text-align:left;">固件</td></tr><tr><td>Flag</td><td style="text-align:left;">标记</td></tr><tr><td>Flash memory</td><td style="text-align:left;">闪存</td></tr><tr><td>Flush</td><td style="text-align:left;">刷新</td></tr><tr><td>对齐，齐平</td><td style="text-align:left;"></td></tr><tr><td>Folder</td><td style="text-align:left;">文件夹</td></tr><tr><td>Font</td><td style="text-align:left;">字体</td></tr><tr><td>Form</td><td style="text-align:left;">表单</td></tr><tr><td>Format (noun)</td><td style="text-align:left;">格式</td></tr><tr><td>Format (verb)</td><td style="text-align:left;">格式化</td></tr><tr><td>Forward</td><td style="text-align:left;">转发，转送，转寄</td></tr><tr><td>Fragment</td><td style="text-align:left;">片段</td></tr><tr><td>Frame</td><td style="text-align:left;">帧；框架</td></tr><tr><td>Frame rate FPS (frames per second)</td><td style="text-align:left;">帧率</td></tr><tr><td>Framework</td><td style="text-align:left;">框架</td></tr><tr><td>Frozen</td><td style="text-align:left;">冻结，锁定</td></tr><tr><td>Full screen, Fullscreen</td><td style="text-align:left;">全屏</td></tr><tr><td>Function</td><td style="text-align:left;">函数</td></tr><tr><td>Function (vs. Feature)</td><td style="text-align:left;">（一般的）功能</td></tr><tr><td>Functionality</td><td style="text-align:left;">功能</td></tr><tr><td>Game</td><td style="text-align:left;">游戏</td></tr><tr><td>Gateway</td><td style="text-align:left;">网关</td></tr><tr><td>General</td><td style="text-align:left;">通用的</td></tr><tr><td>Generate</td><td style="text-align:left;">生成</td></tr><tr><td>Generic</td><td style="text-align:left;">通用的</td></tr><tr><td>Generics</td><td style="text-align:left;">泛型</td></tr><tr><td>Global</td><td style="text-align:left;">全局的</td></tr><tr><td>Group box</td><td style="text-align:left;">分组框，群组框</td></tr><tr><td>Graph</td><td style="text-align:left;">图</td></tr><tr><td>Handle</td><td style="text-align:left;">句柄</td></tr><tr><td>Handler</td><td style="text-align:left;">处理程序，处理器</td></tr><tr><td>Hardware</td><td style="text-align:left;">硬件</td></tr><tr><td>Hash</td><td style="text-align:left;">哈希</td></tr><tr><td>Header file</td><td style="text-align:left;">头文件</td></tr><tr><td>Heap</td><td style="text-align:left;">堆</td></tr><tr><td>Help</td><td style="text-align:left;">帮助</td></tr><tr><td>Hierarchy</td><td style="text-align:left;">层次结构</td></tr><tr><td>High Definition</td><td style="text-align:left;">高清晰度，高清</td></tr><tr><td>Host file</td><td style="text-align:left;">主机文件</td></tr><tr><td>Home folder</td><td style="text-align:left;">主文件夹 (win)；个人文件夹 (mac)</td></tr><tr><td>Home page</td><td style="text-align:left;">主页</td></tr><tr><td>Icon</td><td style="text-align:left;">图标</td></tr><tr><td>IDE</td><td style="text-align:left;">集成开发环境</td></tr><tr><td>Identifier</td><td style="text-align:left;">标识符</td></tr><tr><td>Idle</td><td style="text-align:left;">闲置</td></tr><tr><td>Image</td><td style="text-align:left;">影像；图像，图片；映像</td></tr><tr><td>Immutable</td><td style="text-align:left;">不可变的；不可更改的</td></tr><tr><td>Implement</td><td style="text-align:left;">实现</td></tr><tr><td>Implementation</td><td style="text-align:left;">实现</td></tr><tr><td>Implicit</td><td style="text-align:left;">隐式</td></tr><tr><td>Import</td><td style="text-align:left;">导入</td></tr><tr><td>Indent</td><td style="text-align:left;">缩进</td></tr><tr><td>Info</td><td style="text-align:left;">简介</td></tr><tr><td>Information</td><td style="text-align:left;">信息</td></tr><tr><td>Inheritance</td><td style="text-align:left;">继承</td></tr><tr><td>Initialization</td><td style="text-align:left;">初始化</td></tr><tr><td>Inline</td><td style="text-align:left;">内联</td></tr><tr><td>Instance</td><td style="text-align:left;">实例</td></tr><tr><td>Integrate</td><td style="text-align:left;">集成</td></tr><tr><td>Integrated</td><td style="text-align:left;">集成的</td></tr><tr><td>Integrity</td><td style="text-align:left;">完整性</td></tr><tr><td>Interact, Interaction</td><td style="text-align:left;">交互</td></tr><tr><td>Interface</td><td style="text-align:left;">接口</td></tr><tr><td>Internal Storage</td><td style="text-align:left;">内存 (仅手机等便携装置，民间称谓)</td></tr><tr><td>Internationalization (I18N)</td><td style="text-align:left;">国际化</td></tr><tr><td>Internet</td><td style="text-align:left;">互联网</td></tr><tr><td>Interpreter</td><td style="text-align:left;">解释器</td></tr><tr><td>Invoke</td><td style="text-align:left;">调用</td></tr><tr><td>Iterate</td><td style="text-align:left;">迭代； 重复、循环（访问）</td></tr><tr><td>Iteration</td><td style="text-align:left;">迭代</td></tr><tr><td>Iterator</td><td style="text-align:left;">迭代器</td></tr><tr><td>Kernel</td><td style="text-align:left;">内核</td></tr><tr><td>Key</td><td style="text-align:left;">密钥</td></tr><tr><td>Keybind</td><td style="text-align:left;">快捷键</td></tr><tr><td>Lag</td><td style="text-align:left;">延迟</td></tr><tr><td>Layout</td><td style="text-align:left;">布局，配置</td></tr><tr><td>Lazy loading</td><td style="text-align:left;">延迟加载；懒加载</td></tr><tr><td>Library</td><td style="text-align:left;">程序库，函数库</td></tr><tr><td>Link</td><td style="text-align:left;">链接</td></tr><tr><td>Link time</td><td style="text-align:left;">链接期</td></tr><tr><td>Linked list</td><td style="text-align:left;">链表</td></tr><tr><td>Linker</td><td style="text-align:left;">链接器</td></tr><tr><td>List</td><td style="text-align:left;">列表</td></tr><tr><td>Listener</td><td style="text-align:left;">监听器</td></tr><tr><td>Literals</td><td style="text-align:left;">字面值，字面量</td></tr><tr><td>Literal constant</td><td style="text-align:left;">字面常量</td></tr><tr><td>Load</td><td style="text-align:left;">加载</td></tr><tr><td>Load time</td><td style="text-align:left;">加载期</td></tr><tr><td>Loader</td><td style="text-align:left;">加载器</td></tr><tr><td>Local</td><td style="text-align:left;">局部的，本地的；本地（主机）</td></tr><tr><td>Localization (L10N)</td><td style="text-align:left;">本地化</td></tr><tr><td>Local variable</td><td style="text-align:left;">局部变量</td></tr><tr><td>Lock</td><td style="text-align:left;">锁定</td></tr><tr><td>Log</td><td style="text-align:left;">日志</td></tr><tr><td>Log in, Login</td><td style="text-align:left;">登录</td></tr><tr><td>Log out, Logout</td><td style="text-align:left;">退出；注销</td></tr><tr><td>Loop</td><td style="text-align:left;">循环</td></tr><tr><td>Map, Mapping</td><td style="text-align:left;">映射</td></tr><tr><td>Match</td><td style="text-align:left;">匹配</td></tr><tr><td>Memory</td><td style="text-align:left;">内存</td></tr><tr><td>Menu</td><td style="text-align:left;">菜单</td></tr><tr><td>Message</td><td style="text-align:left;">消息；信息</td></tr><tr><td>Metadata</td><td style="text-align:left;">元数据</td></tr><tr><td>Middleware</td><td style="text-align:left;">中间件，中间软件</td></tr><tr><td>Mobile</td><td style="text-align:left;">移动</td></tr><tr><td>Moderate, Moderation</td><td style="text-align:left;">审核</td></tr><tr><td>Modifier</td><td style="text-align:left;">修饰符</td></tr><tr><td>Module</td><td style="text-align:left;">模块</td></tr><tr><td>Monomorphism</td><td style="text-align:left;">单态</td></tr><tr><td>Motherboard</td><td style="text-align:left;">主板</td></tr><tr><td>Mouse</td><td style="text-align:left;">鼠标</td></tr><tr><td>Mouse pointer</td><td style="text-align:left;">鼠标指针</td></tr><tr><td>Multitasking</td><td style="text-align:left;">多任务（处理）</td></tr><tr><td>Mutable</td><td style="text-align:left;">可变的</td></tr><tr><td>Mutex</td><td style="text-align:left;">互斥</td></tr><tr><td>Native</td><td style="text-align:left;">原生</td></tr><tr><td>Navigate, Navigation</td><td style="text-align:left;">导航</td></tr><tr><td>Navigator</td><td style="text-align:left;">导航器</td></tr><tr><td>Nested</td><td style="text-align:left;">嵌套的</td></tr><tr><td>Network</td><td style="text-align:left;">网络</td></tr><tr><td>New</td><td style="text-align:left;">新建</td></tr><tr><td>Notarization</td><td style="text-align:left;">公证</td></tr><tr><td>Object</td><td style="text-align:left;">对象</td></tr><tr><td>Object code</td><td style="text-align:left;">目标代码</td></tr><tr><td>Object file</td><td style="text-align:left;">目标文件</td></tr><tr><td>Object-oriented</td><td style="text-align:left;">面向对象</td></tr><tr><td>Online</td><td style="text-align:left;">在线</td></tr><tr><td>Operand</td><td style="text-align:left;">操作数，运算元</td></tr><tr><td>Operating system</td><td style="text-align:left;">操作系统</td></tr><tr><td>Operator</td><td style="text-align:left;">操作符，运算符</td></tr><tr><td>Optimize, Optimization</td><td style="text-align:left;">优化</td></tr><tr><td>Overflow</td><td style="text-align:left;">溢出（上溢出）</td></tr><tr><td>Overlay</td><td style="text-align:left;">叠加面板</td></tr><tr><td>Overload</td><td style="text-align:left;">重载</td></tr><tr><td>Override</td><td style="text-align:left;">覆盖，重写</td></tr><tr><td>Pack</td><td style="text-align:left;">打包，压缩</td></tr><tr><td>Package (noun)</td><td style="text-align:left;">（程序、软件）包</td></tr><tr><td>Package (verb)</td><td style="text-align:left;">打包，封装</td></tr><tr><td>Pane</td><td style="text-align:left;">窗格 (win) 面板 (mac)</td></tr><tr><td>Parallelism</td><td style="text-align:left;">并行性，并行</td></tr><tr><td>Parameter</td><td style="text-align:left;">参数（也称为形式参数，形参）</td></tr><tr><td>Parse</td><td style="text-align:left;">解析</td></tr><tr><td>Partition</td><td style="text-align:left;">分割；（硬盘）分区</td></tr><tr><td>Paste</td><td style="text-align:left;">粘贴</td></tr><tr><td>Patch</td><td style="text-align:left;">补丁 (win) 修补程序 (mac)</td></tr><tr><td>Pattern</td><td style="text-align:left;">模式；样式</td></tr><tr><td>Performance</td><td style="text-align:left;">性能</td></tr><tr><td>Persistence</td><td style="text-align:left;">持久性</td></tr><tr><td>Photo</td><td style="text-align:left;">照片</td></tr><tr><td>Physical layer</td><td style="text-align:left;">物理层</td></tr><tr><td>Picklist</td><td style="text-align:left;">选择列表</td></tr><tr><td>Placeholder</td><td style="text-align:left;">占位符</td></tr><tr><td>Pluggability</td><td style="text-align:left;">可插入性</td></tr><tr><td>Plugin</td><td style="text-align:left;">插件</td></tr><tr><td>Pointer</td><td style="text-align:left;">指针</td></tr><tr><td>Polymorphism</td><td style="text-align:left;">多态</td></tr><tr><td>Port</td><td style="text-align:left;">端口</td></tr><tr><td>Power bank</td><td style="text-align:left;">移动电源，充电宝</td></tr><tr><td>Presentation layer</td><td style="text-align:left;">表示层</td></tr><tr><td>Preset</td><td style="text-align:left;">预设</td></tr><tr><td>Print</td><td style="text-align:left;">打印</td></tr><tr><td>Printer</td><td style="text-align:left;">打印机</td></tr><tr><td>Procedure</td><td style="text-align:left;">过程</td></tr><tr><td>Process</td><td style="text-align:left;">进程</td></tr><tr><td>Profile</td><td style="text-align:left;">配置文件 (win) 描述文件 (mac)</td></tr><tr><td>Profile</td><td style="text-align:left;">评测</td></tr><tr><td>Profile (or Personal profile)</td><td style="text-align:left;">个人资料</td></tr><tr><td>Profiler</td><td style="text-align:left;">（性能）分析器</td></tr><tr><td>Program</td><td style="text-align:left;">程序</td></tr><tr><td>Project</td><td style="text-align:left;">项目</td></tr><tr><td>Protocol</td><td style="text-align:left;">协议</td></tr><tr><td>Provision, Provisioning</td><td style="text-align:left;">预配</td></tr><tr><td>Proxy (or Proxy server)</td><td style="text-align:left;">代理服务器</td></tr><tr><td>Pseudo code</td><td style="text-align:left;">伪代码</td></tr><tr><td>Pull-down list</td><td style="text-align:left;">下拉列表</td></tr><tr><td>Quality</td><td style="text-align:left;">质量</td></tr><tr><td>Queue</td><td style="text-align:left;">队列</td></tr><tr><td>Quit unexpectedly</td><td style="text-align:left;">意外退出</td></tr><tr><td>Radian</td><td style="text-align:left;">弧度</td></tr><tr><td>Radio button</td><td style="text-align:left;">单选按钮</td></tr><tr><td>RAM (Random Access Memory)</td><td style="text-align:left;">随机存取存储器</td></tr><tr><td>Read</td><td style="text-align:left;">读</td></tr><tr><td>Read-only</td><td style="text-align:left;">只读</td></tr><tr><td>Recovery</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Recursion</td><td style="text-align:left;">递归</td></tr><tr><td>Redirect, Redirection</td><td style="text-align:left;">重定向</td></tr><tr><td>Reference</td><td style="text-align:left;">参考</td></tr><tr><td>Register</td><td style="text-align:left;">寄存器；注册</td></tr><tr><td>Release</td><td style="text-align:left;">（发行、发布）版本</td></tr><tr><td>Remote</td><td style="text-align:left;">远程</td></tr><tr><td>Render</td><td style="text-align:left;">渲染</td></tr><tr><td>Resolution</td><td style="text-align:left;">分辨率</td></tr><tr><td>Response</td><td style="text-align:left;">响应</td></tr><tr><td>Response body</td><td style="text-align:left;">响应正文</td></tr><tr><td>Response header</td><td style="text-align:left;">响应头</td></tr><tr><td>Restore</td><td style="text-align:left;">还原 (win)，恢复 (mac)</td></tr><tr><td>Return</td><td style="text-align:left;">返回；恢复</td></tr><tr><td>Revoke, Revocation</td><td style="text-align:left;">撤销</td></tr><tr><td>Rollback</td><td style="text-align:left;">回滚，回退</td></tr><tr><td>Routine</td><td style="text-align:left;">程序</td></tr><tr><td>Run</td><td style="text-align:left;">运行</td></tr><tr><td>Runtime, Run-time</td><td style="text-align:left;">运行期，运行时；运行环境</td></tr><tr><td>Runtime environment (RTE), Runtime system</td><td style="text-align:left;">运行环境；运行系统</td></tr><tr><td>Save</td><td style="text-align:left;">保存</td></tr><tr><td>Sampling</td><td style="text-align:left;">取样</td></tr><tr><td>Scalar</td><td style="text-align:left;">标量</td></tr><tr><td>Schedule</td><td style="text-align:left;">调度</td></tr><tr><td>Scheduler</td><td style="text-align:left;">调度器，调度程序</td></tr><tr><td>Scope</td><td style="text-align:left;">（作用、有效）范围，域</td></tr><tr><td>Scroll bar</td><td style="text-align:left;">滚动条</td></tr><tr><td>Script</td><td style="text-align:left;">脚本</td></tr><tr><td>SDK (Software Development Kit)</td><td style="text-align:left;">软件开发工具包 (win) 软件开发套件 (mac)</td></tr><tr><td>Search engine</td><td style="text-align:left;">搜索引擎</td></tr><tr><td>Security</td><td style="text-align:left;">安全性</td></tr><tr><td>Segment</td><td style="text-align:left;">段</td></tr><tr><td>Server</td><td style="text-align:left;">服务器</td></tr><tr><td>Server-side</td><td style="text-align:left;">服务器端</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session</td><td style="text-align:left;">会话</td></tr><tr><td>Session layer</td><td style="text-align:left;">会话层</td></tr><tr><td>Set up</td><td style="text-align:left;">设置</td></tr><tr><td>Settings</td><td style="text-align:left;">设置</td></tr><tr><td>Shortcut</td><td style="text-align:left;">快捷</td></tr><tr><td>Shortcut key</td><td style="text-align:left;">快捷键</td></tr><tr><td>Sign in, sign-in</td><td style="text-align:left;">登录</td></tr><tr><td>Sign out, sign-out</td><td style="text-align:left;">退出，注销</td></tr><tr><td>Silicon</td><td style="text-align:left;">硅</td></tr><tr><td>Simulation</td><td style="text-align:left;">模拟</td></tr><tr><td>Signature</td><td style="text-align:left;">签名</td></tr><tr><td>Slider</td><td style="text-align:left;">滑块</td></tr><tr><td>Smart</td><td style="text-align:left;">智能</td></tr><tr><td>Smartphone</td><td style="text-align:left;">智能手机</td></tr><tr><td>SMS (Short Message Service)</td><td style="text-align:left;">短信</td></tr><tr><td>Snip</td><td style="text-align:left;">截图</td></tr><tr><td>Source code</td><td style="text-align:left;">源代码，源码</td></tr><tr><td>Stack</td><td style="text-align:left;">栈</td></tr><tr><td>Star rating</td><td style="text-align:left;">星级评分</td></tr><tr><td>Statement</td><td style="text-align:left;">语句</td></tr><tr><td>Status bar</td><td style="text-align:left;">状态栏</td></tr><tr><td>Stepper</td><td style="text-align:left;">步进器</td></tr><tr><td>Stream</td><td style="text-align:left;">（数据）流</td></tr><tr><td>String</td><td style="text-align:left;">字符串</td></tr><tr><td>String interpolation</td><td style="text-align:left;">字符串插值</td></tr><tr><td>Stuttering</td><td style="text-align:left;">-</td></tr><tr><td>Subclass</td><td style="text-align:left;">子类</td></tr><tr><td>Subroutine</td><td style="text-align:left;">子例程</td></tr><tr><td>Superclass</td><td style="text-align:left;">超类</td></tr><tr><td>Support</td><td style="text-align:left;">支持</td></tr><tr><td>Suspend</td><td style="text-align:left;">暂停（权限）</td></tr><tr><td>Synchronize</td><td style="text-align:left;">同步</td></tr><tr><td>Synchronous</td><td style="text-align:left;">同步的</td></tr><tr><td>Tab</td><td style="text-align:left;">标签（页）</td></tr><tr><td>Tag</td><td style="text-align:left;">标签</td></tr><tr><td>Task</td><td style="text-align:left;">任务</td></tr><tr><td>Template</td><td style="text-align:left;">模板</td></tr><tr><td>Text</td><td style="text-align:left;">文本</td></tr><tr><td>Text box</td><td style="text-align:left;">文本框</td></tr><tr><td>Thread</td><td style="text-align:left;">线程</td></tr><tr><td>Top-up</td><td style="text-align:left;">充值</td></tr><tr><td>Token</td><td style="text-align:left;">标记 (win) 令牌 (mac)</td></tr><tr><td>权杖；代币</td><td style="text-align:left;"></td></tr><tr><td>Traverse</td><td style="text-align:left;">遍历</td></tr><tr><td>Tray (or System tray)</td><td style="text-align:left;">系统托盘</td></tr><tr><td>Tree</td><td style="text-align:left;">树</td></tr><tr><td>Tuple</td><td style="text-align:left;">元组</td></tr><tr><td>Tutorial</td><td style="text-align:left;">教程</td></tr><tr><td>Type</td><td style="text-align:left;">类型</td></tr><tr><td>Universal</td><td style="text-align:left;">通用的</td></tr><tr><td>Variable</td><td style="text-align:left;">变量</td></tr><tr><td>Video</td><td style="text-align:left;">视频</td></tr><tr><td>View</td><td style="text-align:left;">查看；显示；视图</td></tr><tr><td>Voice</td><td style="text-align:left;">语音</td></tr><tr><td>Volume</td><td style="text-align:left;">卷 (win)；宗卷 (mac)</td></tr><tr><td>Window</td><td style="text-align:left;">窗口</td></tr><tr><td>Widget</td><td style="text-align:left;">窗口部件；小部件</td></tr><tr><td>Wildcard</td><td style="text-align:left;">通配符</td></tr><tr><td>Workspaces</td><td style="text-align:left;">工作区</td></tr><tr><td>Write</td><td style="text-align:left;">写</td></tr></tbody></table></div><!----><!----><div class="vp-doc-copyright" data-v-a703f9d3><h2 id="doc-copyright" tabindex="-1" class="vp-doc-header" data-v-309da98c><a href="#doc-copyright" class="header-anchor" data-v-309da98c><span data-v-309da98c><!--[-->版权所有<!--]--></span></a></h2><div class="hint-container tip copyright-container" data-v-22c67d2a><!----><!----><p data-v-22c67d2a><span data-v-22c67d2a>许可证：</span><a class="vp-link no-icon link" href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noreferrer" data-v-22c67d2a data-v-442a52aa><!--[-->署名 4.0 国际 (CC-BY-4.0)<!--]--><!----></a><!--[--><span class="vpi-license-cc" data-v-22c67d2a></span><span class="vpi-license-by" data-v-22c67d2a></span><!--]--></p></div></div></div></main><footer class="vp-doc-footer" data-v-a703f9d3 data-v-fda6bbae><!--[--><!--]--><!----><!----><nav class="prev-next" data-v-fda6bbae><div class="pager" data-v-fda6bbae><!----></div><div class="pager" data-v-fda6bbae><a class="vp-link no-icon link pager-link next" href="/article/84q5qcf5/" data-v-fda6bbae data-v-442a52aa><!--[--><span class="desc" data-v-fda6bbae>下一页</span><span class="title" data-v-fda6bbae>计算机网络基础</span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button style="display:none;" type="button" class="vp-back-to-top" aria-label="back to top" data-v-d90a7a26 data-v-bcf8d9a6><span class="percent" data-allow-mismatch data-v-bcf8d9a6>0%</span><span class="show icon vpi-back-to-top" data-v-bcf8d9a6></span><svg aria-hidden="true" data-v-bcf8d9a6><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-bcf8d9a6></circle></svg></button><footer class="vp-footer" vp-footer data-v-d90a7a26 data-v-400675cf><!--[--><div class="container" data-v-400675cf><p class="message" data-v-400675cf>Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="./">正茂资源库</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-BA0_WWK8.js" defer></script></body></html>